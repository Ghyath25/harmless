

#This file provides the reader for expression : @expression getIdf
#The goal of this reader is to give the list of the expIdf that
#are used inside an expression:
# -> primary usage: the 'enable' condition inside a timing
#    We have to add an implentation hook in each accessor of the 
#    idf (associated to a register) to take into account the condition.
# -> secondary usage: to get the idf used inside an expression for 
#    static analysis. In an assignment, what are the dependancies
#    of the idf that is written.

list @expIdfList {
  @expIdf idf
}

getter @expression getIdf
  ?let  @varIdfStruct idfStruct
  -> @expIdfList outList
{
  outList = .emptyList
  for (exp) in [self getExpressionChildren] do
    outList += [exp getIdf !idfStruct]
  end
}

override getter @expIdf getIdf
  ?let  @varIdfStruct idfStruct
  -> @expIdfList outList
{ 
  outList = .emptyList
  #if it is a return from a function call, we should
  #parse the return instruction of the function
  switch detectedType
    case componentCall:
      #ok. We have to parse the function. Will be donne in 3 parts:
      #1 - the 'return' instruction is an assignment (that is traced)
      #2 - analysis of the instruction list backward (=> this is the processStaticInfo)
      #3 - add the assignements from the function call to remove internal idf.

      #message "traitement:"+[self string]+"\n"

      @instructionList instList = [idfStruct.componentMap getInstList !idfList]
      @parameterDefList paramDef = [idfStruct.componentMap getParamDefList !idfList]
      @expressionlist paramList = [idfList paramListAtIndex !1]
        
      #message "paramDef"+[paramDef description]+"\n"

      #  @varIdfStruct nextIdfStruct = idfStruct 
      
      @varIdfStruct nextIdfStruct = idfStruct 
      
      [paramDef getInlinedInsts !paramList !@expressionContext.component 
                                  !@location.here !@location.here
                                  !idfStruct !?nextIdfStruct
                                  ?@instructionList instListCall]
      @instructionList fullInstList = instListCall+instList
      #message [fullInstList harmlessCode !0 !false]
      @symbolValueMap symbolValueMap = .emptyMap
      @staticInfoMapRegWrite regWriteAccessMap = .emptyMap
      @stringset memSpaceWriteAccess = .emptySet 
      [fullInstList processStaticInfo !idfStruct !?symbolValueMap !?regWriteAccessMap !?memSpaceWriteAccess !true]
      #message [regWriteAccessMap debug]
      

 #     @instructionList instList = [idfStruct.componentMap getInstList !idfList]
 #     #get the last return instruction
 #     @bool found = false
 #     for > (inst) in instList while not found do 
 #       cast inst
 #         case >= @instReturn ret:
 #           outList += [[ret exp] getIdf !idfStruct]
 #           found = true
 #         else
 #       end
 #     end
    case unknown,structMember,localVar,tabularAccess,
         registerAccess,registerBitField,memoryAccess,
         periphCall,timing,signal: #nothing for now
      outList += !self
  end
}



# vim:ft=galgas:ts=2:sw=2:tw=0
