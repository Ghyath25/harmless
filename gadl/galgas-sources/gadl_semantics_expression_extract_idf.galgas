

#This file provides the reader for expression : @expression getIdf
#The goal of this reader is to give the list of the expIdf that
#are used inside an expression:
# -> primary usage: the 'enable' condition inside a timing
#    We have to add an implentation hook in each accessor of the 
#    idf (associated to a register) to take into account the condition.
# -> secondary usage: to get the idf used inside an expression for 
#    static analysis. In an assignment, what are the dependancies
#    of the idf that is written.

list @expIdfList {
  @expIdf idf
}

getter @expression getIdf
  ?let  @varIdfStruct idfStruct
  -> @expIdfList outList
{
  outList = .emptyList
  for (exp) in [self getExpressionChildren] do
    outList += [exp getIdf !idfStruct]
  end
}

override getter @expIdf getIdf
  ?let  @varIdfStruct idfStruct
  -> @expIdfList outList
{ 
  outList = .emptyList
  #if it is a return from a function call, we should
  #parse the return instruction of the function
  switch detectedType
    case componentCall:
      @instructionList instList = [idfStruct.componentMap getInstList !idfList]
      #get the last return instruction
      @bool found = false
      for > (inst) in instList while not found do 
        cast inst
          case >= @instReturn ret:
            outList += [[ret exp] getIdf !idfStruct]
            found = true
          else
        end
      end
    case unknown,structMember,localVar,tabularAccess,
         registerAccess,registerBitField,memoryAccess,
         periphCall,timing,signal: #nothing for now
      outList += !self
  end
}


#############################################################################
# search for component calls
# used for static analysis
#############################################################################

#getter @expression hasComponentCalls
#  -> @bool memAccess
#{
#  memAccess = false
#  for (exp) in [self getExpressionChildren] while not memAccess do
#    memAccess = memAccess | [exp hasMemAccess]
#  end
#}



# vim:ft=galgas:ts=2:sw=2:tw=0
