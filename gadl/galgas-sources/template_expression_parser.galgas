#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL template expression parser definition                               *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax template_expression_parser (template_scanner){

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <relation_term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <relation_factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <simple_expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <variable>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@TvarPath path

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <relation_term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while
    $|$
    @Tvalue leftOperand = outValue
    @Tvalue rightOperand
    @Ttype firstOperandType = outResultType
    @Ttype secondOperandType
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    outValue.mUnsigned64Value = [leftOperand mUnsigned64Value] | [rightOperand mUnsigned64Value]
    matchOrOperatorForTemplate (
      !firstOperandType
      !secondOperandType
      ?outResultType
    )
  while
    $^$
    @Tvalue leftOperand = outValue
    @Tvalue rightOperand
    @Ttype firstOperandType = outResultType
    @Ttype secondOperandType
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    outValue.mUnsigned64Value = [leftOperand mUnsigned64Value] ^ [rightOperand mUnsigned64Value]
    matchXorOperatorForTemplate (
      !firstOperandType
      !secondOperandType
      ?outResultType
    )
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <relation_factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while
    $&$
    @Tvalue leftOperand = outValue
    @Tvalue rightOperand
    @Ttype firstOperandType = outResultType
    @Ttype secondOperandType
    <relation_factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    outValue.mUnsigned64Value = [leftOperand mUnsigned64Value] & [rightOperand mUnsigned64Value]
    matchAndOperatorForTemplate (
      !firstOperandType
      !secondOperandType
      ?outResultType
   )
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <simple_expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  select
  or
    $==$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mUnsigned64Value] == [rightExpression mUnsigned64Value]
    case unsignedType :
      result = [leftExpression mUnsigned64Value] == [rightExpression mUnsigned64Value]
    case stringType :
      result = [leftExpression mStringValue] == [rightExpression mStringValue]
    case enumType :
      result = [leftExpression mStringValue] == [rightExpression mStringValue]
    case listType, structType, mapType:
      error @location.here: "lists, structs and maps may not be compared" : result
    case unconstructedType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue.mUnsigned64Value = if result then 1L else 0L end
  or
    $!=$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mUnsigned64Value] != [rightExpression mUnsigned64Value]
    case unsignedType :
      result = [leftExpression mUnsigned64Value] != [rightExpression mUnsigned64Value]
    case stringType :
      result = [leftExpression mStringValue] != [rightExpression mStringValue]
    case enumType :
      result = [leftExpression mStringValue] != [rightExpression mStringValue]
    case listType, structType, mapType:
      error @location.here: "lists, structs and maps may not be compared": result
    case unconstructedType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue.mUnsigned64Value = if result then 1L else 0L end
  or
    $<=$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mUnsigned64Value] <= [rightExpression mUnsigned64Value]
    case unsignedType :
      result = [leftExpression mUnsigned64Value] <= [rightExpression mUnsigned64Value]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue.mUnsigned64Value = if result then 1L else 0L end
  or
    $>=$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mUnsigned64Value] >= [rightExpression mUnsigned64Value]
    case unsignedType :
      result = [leftExpression mUnsigned64Value] >= [rightExpression mUnsigned64Value]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue.mUnsigned64Value = if result then 1L else 0L end
  or
    $>$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mUnsigned64Value] > [rightExpression mUnsigned64Value]
    case unsignedType :
      result = [leftExpression mUnsigned64Value] > [rightExpression mUnsigned64Value]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue.mUnsigned64Value = if result then 1L else 0L end
  or
    $<$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mUnsigned64Value] < [rightExpression mUnsigned64Value]
    case unsignedType :
      result = [leftExpression mUnsigned64Value] < [rightExpression mUnsigned64Value]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue.mUnsigned64Value = if result then 1L else 0L end
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while 
    $<<$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    left_shift_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] << [[rightExpression mUnsigned64Value] uint]
  while 
    $>>$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    right_shift_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] >> [[rightExpression mUnsigned64Value] uint]
  while 
    $+$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    addition_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] + [rightExpression mUnsigned64Value]
  while 
    $.$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    concatenation_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mStringValue = [leftExpression mStringValue] + [rightExpression mStringValue]
  while 
    $-$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    addition_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] - [rightExpression mUnsigned64Value]
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while 
    $*$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    multiply_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] * [rightExpression mUnsigned64Value]
  while 
    $/$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    divide_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] / [rightExpression mUnsigned64Value]
  while 
    $mod$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    modulo_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue.mUnsigned64Value = [leftExpression mUnsigned64Value] mod [rightExpression mUnsigned64Value]
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $($
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  $)$
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $not$
  @Tvalue expression
  @Ttype operandType
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expression
    ?operandType
  outValue = valueWithUnsigned(!1L - [expression mUnsigned64Value])
  checkNotOperatorForTemplate ( !operandType ?outResultType)
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $~$
  @Tvalue value
  @Ttype operandType
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?value
    ?operandType
  outValue = valueWithUnsigned(!~ [value mUnsigned64Value])
  checkBitComplementOperatorForTemplate ( !operandType ?outResultType)
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $yes$
  outValue = valueWithUnsigned(!1L)
  outResultType = @Ttype. boolType
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $no$
  outValue = valueWithUnsigned(!0L)
  outResultType = @Ttype. boolType
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @luint64 literalInt
  $unsigned_literal_integer64$ ?literalInt
  outValue = valueWithUnsigned(![literalInt uint64])
  outResultType = @Ttype. unsignedType
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal string value                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $string$ ?var @lstring literalString
  outValue = valueWithString(![literalString string])
  outResultType = @Ttype. stringType
}

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   template method call :   [expression method !... ]                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $[$

  @Tvalue expressionValue
  @Ttype expressionType
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expressionValue
    ?expressionType

  $identifier$ ?var  @lstring templateMethodName

  var expressionList =@TexpressionList.emptyList{}
  select
  or
    $:$
    repeat
      @Tvalue expression
      @Ttype resultType
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
      expressionList += !expression !resultType
    while
      $,$
    end
  end

  $]$

  templateMethodInvocation (
    !expressionType
    !expressionValue
    !templateMethodName
    !expressionList
    ?outResultType
    ?outValue
 )
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @TvarPath path
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path
  select
    searchField ( !path !inVariableMap ?outResultType ?outValue ?*)
  or
    @lstring functionOrVariableName
    [path first ?functionOrVariableName ?*]
  #--- Search for function name
    @function f
    if not @function. isFunctionDefined { ![functionOrVariableName string]} then
      error functionOrVariableName : "there is no '" + functionOrVariableName + "' function defined in GADL template language" : f
    else
      f = @function. functionWithName { ![functionOrVariableName string]}
    end
  #--- Parse actual arguments
    var actualArgumentList =@TexpressionList.emptyList{}
    $($
    repeat
      @Tvalue expression
      @Ttype resultType
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
      actualArgumentList += !expression !resultType
    while
      $,$
    end
    $)$
  #--- Check arguments
    var actualArgumentObjectList =@objectlist.emptyList{}
    let @typelist formalParameterList = [f formalParameterTypeList]
    if [formalParameterList length] != [actualArgumentList length] then
      error functionOrVariableName: "this function is invoked with "
      + [[actualArgumentList length] string]
      + " parameter" + if [actualArgumentList length] > 1 then "s" else "" end
      + ", but requires " 
      + [[formalParameterList length] string]
      + " parameter" + if [formalParameterList length] > 1 then "s" else "" end
      : outValue, outResultType
    else
      @uint idx = 1
      for () formal_ in  formalParameterList, () actual_ in  actualArgumentList do
        switch actual_mType
        case boolType :
          if formal_mValue != `@bool then
            typeError ( !functionOrVariableName !formal_mValue !"boolean" !idx)
          end
          actualArgumentObjectList += ![if [actual_mValue mUnsigned64Value] == 0L then false else true end object]
        case unsignedType :
          if formal_mValue != `@uint64 then
            typeError ( !functionOrVariableName !formal_mValue !"unsigned" !idx)
          end
          actualArgumentObjectList += ![[actual_mValue mUnsigned64Value] object]
        case stringType :
          if formal_mValue != `@string then
            typeError ( !functionOrVariableName !formal_mValue !"string" !idx)
          end
        case enumType :
          if formal_mValue != `@string then
            typeError ( !functionOrVariableName !formal_mValue !"enum" !idx)
          end
          actualArgumentObjectList += ![[actual_mValue mStringValue] object]
        case listType, structType, mapType :
          typeError ( !functionOrVariableName !formal_mValue !"string" !idx)
        case unconstructedType:
          error @location.here: "internal error, unconstructed type found"
        end
        idx ++     
      end
      outResultType = @Ttype. unsignedType
      outValue = valueWithUnsigned(!0L)
      if @uint. errorCount == 0 then
        let @object result = [f invoke !actualArgumentObjectList ![functionOrVariableName location]]
        if [result objectDynamicType] == `@uint64 then
          outResultType = @Ttype. unsignedType
          outValue.mUnsigned64Value = ( result as @uint64)
        elsif [result objectDynamicType] == `@uint then
          outResultType = @Ttype. unsignedType
          outValue.mUnsigned64Value = [( result as @uint) uint64]
        elsif [result objectDynamicType] == `@bool then
          outResultType = @Ttype. boolType
          outValue.mUnsigned64Value = [( result as @bool) uint64]
        elsif [result objectDynamicType] == `@string then
          outResultType = @Ttype. stringType
          outValue.mStringValue = ( result as @string)
        else
          error functionOrVariableName : "this function does not return an unsigned, boolean or string value"
        end
      end
    end
  end
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @TvarPath path
  $exists$ <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path

  @Ttype variableType
  @Tvalue variableValue
  @bool varExists

  searchFieldIfExists ( !path !inVariableMap ?variableType ?variableValue ?varExists)

  select
    $default$
    @Tvalue expression
    @Ttype resultType
    $($
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?expression
      ?resultType
    $)$
    if varExists then
      outResultType = variableType
      outValue = variableValue
    else
      outResultType = resultType
      outValue = expression
    end
  or
    outResultType = @Ttype. boolType
    if varExists then
      outValue = valueWithUnsigned(!1L)
    else
      outValue = valueWithUnsigned(!0L)
    end
  end
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string  inPath
  ?let @string  inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @TvarPath variableName
  $typeof$ <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?variableName
  @Ttype variableType
  @Tvalue variableValue
  searchField ( !variableName !inVariableMap ?variableType ?variableValue ?*)
  outResultType = @Ttype. enumType
  outValue = valueWithString(![variableType messageGoilTemplateType])
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  select
    $true$
    outValue = valueWithUnsigned(!1L)
  or
    $false$
    outValue = valueWithUnsigned(!0L)
  end
  outResultType = @Ttype. boolType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $@$ $identifier$ ?var @lstring enumValue
  outValue = valueWithString(![enumValue string])
  outResultType = @Ttype. enumType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $emptylist$
  outValue = @Tvalue. new { !0L !"" !@TfieldMapList. emptyList !@TfieldMap. emptyMap}
  outResultType = @Ttype. listType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $emptymap$
  outValue = @Tvalue. new { !0L !"" !@TfieldMapList. emptyList !@TfieldMap. emptyMap}
  outResultType = @Ttype. mapType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $mapof$
  @TvarPath path
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path
  $by$
  $identifier$ ?var @lstring key
  
  @Ttype variableType
  @Tvalue variableValue
  @location where
  searchField ( !path !inVariableMap ?variableType ?variableValue ?where)
  if variableType != @Ttype. listType then
    error where: "list expected": outValue, outResultType
  else
    # get the elements of the list to build a map, each key being
    # one of the field of the elements of the list
    var resultMap =@TfieldMap.emptyMap{}
    for () in  [variableValue mMapListValue] do
      if [mMap hasKey ![key string]] then
        # the specified key is found, get it and check it is a string
        @Ttype keyType
        @Tvalue keyValue
        [mMap searchKey !key ?keyType ?keyValue]
        if keyType == @Ttype. stringType then
          @lstring keyVal = @lstring. new { ![keyValue mStringValue] ![mMap locationForKey ![key string]]}
          [!?resultMap insertKey !keyVal !@Ttype. structType !valueWithMap(!mMap)]
        else
          error [mMap locationForKey ![key string]]: "the list element specified key is not a string"
        end
      else
        error @location.here: "the list element has not the specified key"
      end
    end
    outResultType = @Ttype. mapType
    outValue = valueWithMap(!resultMap)
  end
}

##------------------------------------------------------------------------------*
#
#rule <factor>
#  ??@string inPrefix
#  ??@string inPath
#  ??@string inTemplateDirectory
#  ??@TfieldMap inVariableMap
#  !@Tvalue outValue
#  !@Ttype outResultType
#:
#  @string resultString := "";
#  $templateresult$;
#  select
#    $if$; $exists$;
#    @bool found;
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !false
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  or
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !true
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  end select;
#  outValue := [@Tvalue new !0L !resultString ![@TfieldMapList emptyList]];
#  outResultType := [@Ttype stringType];
#end rule;

}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    &    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc matchAndOperatorForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case boolType , boolType :
    outResultType = inLeftExpressionType
  case unsignedType , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "operand type error : (" + [inLeftExpressionType messageGoilTemplateType] +
           " & " + [inRightExpressionType messageGoilTemplateType] + ") is not valid" 
           : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    |    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc matchOrOperatorForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case boolType , boolType :
    outResultType = inLeftExpressionType
  case unsignedType , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "operand type error : (" + [inLeftExpressionType messageGoilTemplateType] +
           " | " + [inRightExpressionType messageGoilTemplateType] + ") is not valid" 
           : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    ^    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc matchXorOperatorForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case boolType , boolType :
    outResultType = inLeftExpressionType
  case unsignedType , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "operand type error : (" + [inLeftExpressionType messageGoilTemplateType] +
           " | " + [inRightExpressionType messageGoilTemplateType] + ") is not valid" 
           : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    N O T    O P E R A T O R                                   *
#                                                                           *
#---------------------------------------------------------------------------*

proc checkNotOperatorForTemplate
  ?let @Ttype inOperandType
  !@Ttype outResultType {
  if inOperandType != @Ttype. boolType then
    error @location.here : "the 'not' operator is not defined for an "
    + [inOperandType messageGoilTemplateType] + " type"
  end
  outResultType = inOperandType
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ~    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc checkBitComplementOperatorForTemplate
  ?let @Ttype inOperandType
  !@Ttype outResultType {
  outResultType = inOperandType
  if inOperandType != @Ttype. unsignedType then
    error @location.here : "the ~ operator is not defined for an "
    + [inOperandType messageGoilTemplateType] + " type"
  end
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    C O M P A R I S O N S                          *
#                                                                           *
#---------------------------------------------------------------------------*

proc comparison_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType {
  match inLeftExpressionType , inRightExpressionType
  case boolType     , boolType :
  case unsignedType , unsignedType :
  case stringType   , stringType :
  case enumType     , enumType :
  else
    error @location.here : "comparison between " + [inLeftExpressionType messageGoilTemplateType] +
           " and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    <    <=    >    >=   C O M P A R I S O N S     *
#                                                                           *
#---------------------------------------------------------------------------*

proc magnitude_comparison_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType {
  match inLeftExpressionType , inRightExpressionType
  case boolType      , boolType :
  case unsignedType      , unsignedType :
  case stringType    , stringType :
  else
    error @location.here : "comparison between " + [inLeftExpressionType messageGoilTemplateType] +
           " and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S H I F T    O P E R A T O R                               *
#                                                                           *
#---------------------------------------------------------------------------*

proc left_shift_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType    , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "shift between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*

proc right_shift_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType    , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "shift between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    A D D I T I O N    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

proc addition_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType      , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "addition between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    C O N C A T E N A T I O N    O P E R A T O R               *
#                                                                           *
#---------------------------------------------------------------------------*

proc concatenation_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case stringType        , stringType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "addition between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S U B S T R A C T I O N    O P E R A T O R                 *
#                                                                           *
#---------------------------------------------------------------------------*

proc substraction_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType      , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "substraction between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M U L T I P L Y    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

proc multiply_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType      , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "multiplication between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    D I V I D E    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

proc divide_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType      , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "division between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M O D U L O    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

proc modulo_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case unsignedType      , unsignedType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "modulo between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#------------------------------------------------------------------------------*
#                                                                              *
#  A R G U M E N T    L I S T    S I G N A T U R E                             *
#                                                                              *
#------------------------------------------------------------------------------*

func argumentListSignature
  ?let @TexpressionList inParameterTypeList
  -> @string outResult {
  outResult = " this method call has "
  outResult += [[inParameterTypeList length] string] + " argument"
  outResult += if [inParameterTypeList length] > 0 then "s" else "" end
  for () in  inParameterTypeList
  before outResult += ": "
  do outResult += [mType messageGoilTemplateType]
  between outResult += ", "
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#  C H E C K    I N V O C A T I O N    H A S   N O    A R G U M E N T          *
#                                                                              *
#------------------------------------------------------------------------------*

proc checkInvocationHasNoArgument
  ?let @Ttype inType
  ?let @lstring inMethodName
  ?let @TexpressionList inParameterTypeList {
  if [inParameterTypeList length] > 0 then
    error inMethodName:"calling '" + inMethodName + "' on a "
    + [inType messageGoilTemplateType] + " type requires no argument; "
    + argumentListSignature (!inParameterTypeList)
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#  M E T H O D    I N V O C A T I O N                                          *
#                                                                              *
#------------------------------------------------------------------------------*

proc templateMethodInvocation
  ?let @Ttype inType
  ?let @Tvalue inValue
  ?let @lstring inMethodName
  ?let @TexpressionList inParameterTypeList
  !@Ttype outResultType
  !@Tvalue outResultValue {
  switch inType
  case boolType :
    if [inMethodName string] == "trueOrFalse" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (
        ! if [inValue mUnsigned64Value] > 0L then "true" else "false" end
      )
    elsif [inMethodName string] == "yesOrNo" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (
        ! if [inValue mUnsigned64Value] > 0L then "yes" else "no" end
      )
    elsif [inMethodName string] == "unsigned" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. unsignedType
      outResultValue = inValue
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType
    end
  case unsignedType :
    if [inMethodName string] == "string" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mUnsigned64Value] string])
    elsif [inMethodName string] == "hexString" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mUnsigned64Value] hexString])
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType
    end
  case stringType :
    if [inMethodName string] == "HTMLRepresentation" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mStringValue] HTMLRepresentation])
    elsif [inMethodName string] == "identifierRepresentation" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mStringValue] identifierRepresentation])
    elsif [inMethodName string] == "lowercaseString" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mStringValue] lowercaseString])
    elsif [inMethodName string] == "length" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. unsignedType
      outResultValue = valueWithUnsigned (![[[inValue mStringValue] length] uint64])
    elsif [inMethodName string] == "stringByCapitalizingFirstCharacter" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mStringValue] stringByCapitalizingFirstCharacter])
    elsif [inMethodName string] == "uppercaseString" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. stringType
      outResultValue = valueWithString (![[inValue mStringValue] uppercaseString])
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType
    end
  case listType :
    if [inMethodName string] == "length" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. unsignedType
      outResultValue = valueWithUnsigned (![[[inValue mMapListValue] length] uint64])
    elsif [inMethodName string] == "first" then
      checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
      outResultType = @Ttype. structType
      @TfieldMap firstElement
      [[inValue mMapListValue] first ?firstElement]
      outResultValue = valueWithStruct (!firstElement)
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType
    end
  case enumType, structType, mapType:
    error inMethodName: "this template method is not defined" : outResultValue, outResultType
  case unconstructedType:
    error @location.here: "internal error, unconstructed type found": outResultValue, outResultType
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   function call        :   function_name (..., ...)                          *
#   variable             :   variable_name                                     *
#                                                                              *
#------------------------------------------------------------------------------*

proc typeError
  ?let @lstring inFunctionName
  ?let @type inActualType
  ?let @string inExpectedTypeName
  ?let @uint inParameterIndex {
  @string m = "the function requires the parameter " + [inParameterIndex string]
  + " to be " + inExpectedTypeName + "; its type is "
  if inActualType == `@bool then
    m += "boolean"
  elsif inActualType == `@uint64 then
    m += "unsigned"
  elsif inActualType == `@string then
    m += "string"
  else
    m += "a not allowed type"
  end
  error inFunctionName : m
}