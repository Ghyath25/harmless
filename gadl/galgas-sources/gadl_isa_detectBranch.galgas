# new approach, get static info (including branch detection).

# donc staticInfo est une map (clé l'instruction traitée) qui contient 
# => une map (clé registre en écriture)
#    Pour chaque registre écrit:
#     => conditionnellement?
#     => valeur connu statiquement? => n'est pas redondant avec l'expression?
#     => expression pour connaitre la valeur dynamiquement.
# => une map (clé registre en lecture)
#     => conditionnellement?

# un truc à mettre à jour: TODO TODO TODO!!
# si on fait un accès à un composant qui retourne une valeur… ça ne marchera pas
# car l'accès est vu à l'intérieur d'une expression. Il faut toutes les parser :-/
# TODO: gestion des accès mémoire forcément, ça casse tout :-/

# TODO: pour le isConst, il suffit de parcourir la liste des depList opur tester 
#       le paramètre isConst… à moins que ce soit le valueUnkown?
#       => non, car il y a les accès mémoire aussi.

# This is the main map
# Key is the instruction.
# It contains:
# * regWriteAccessMap: map of regs that are written (key is the var written)
map @staticInfoMap {
  @staticInfoMapRegWrite regWriteAccessMap
  @stringset memSpaceWriteAccess #set of memspace that are written.
  insert insertKey error message "the '%K' for staticInfoMapRegWritec info is already defined in %L" 
  search searchKey error message "the '%K' for static info is not defined"
}

map @staticInfoMapRegWrite {
  @expIdfList depList      #dependancies, i.e. registers and local vars that affect values.
#  @bool memAccess          #does var value depends on mem access (mem access read…)
  @stringset memSpaceReadAccess #does the value depends on a mem access (store mem space names).
#  @bool valueUnknown       #true if value may not be known statically.
#  @expression exp          #expression to get value if available
  insert insertKey error message "the '%K' for static reg write info is already defined in %L" 
  search searchKey error message "the '%K' for static reg write info is not defined"
}

# This is the routine that is called from an external file.
# memChunk is defined in the core: Used to know if a mem access is in register or main mem
getter  @decodedBehaviorMap getStaticInfo
  ?let  @varIdfStruct idfStruct
  ?let  @memoryParamMap unused memChunk
  -> @staticInfoMap staticInfoMap
{
  staticInfoMap = @staticInfoMap.emptyMap
  for () in  self do
    @symbolValueMap symbolValueMap = .emptyMap
    @staticInfoMapRegWrite regWriteAccessMap = .emptyMap
    @stringset memSpaceWriteAccess = .emptySet 

    [instList processStaticInfo !idfStruct !?symbolValueMap 
                                  !?regWriteAccessMap !?memSpaceWriteAccess !true]
    #[[regWriteAccessMap removeDuplicates] debugRegWriteAccessMap]
    [!?staticInfoMap insertKey !lkey ![regWriteAccessMap removeDuplicates] !memSpaceWriteAccess]
  end
}

proc setStaticInfoTemplates
  ?let @decodedBehaviorMap decodedBehaviorMap 
  ?let @varIdfStruct unused idfStruct
  ?let @staticInfoMap staticInfoMap
  ?! @TfieldMap cfg {
  #get static information about instructions
  var staticData =@TfieldMapList.emptyList{}
  for (@lstring               instName
       @staticInfoMapRegWrite regWriteAccessMap
       @stringset memSpaceWriteAccess) in staticInfoMap do
    #name
    var instStruct =@TfieldMap.emptyMap{}
    addLStringValue (!?instStruct !"instID" !instName)
    #get code in harmless style
    [decodedBehaviorMap searchKey !instName ?* ?@instructionList instList ?*]
    var instCode = [[instList harmlessCode !0] HTMLRepresentation]
    addStringValue (!?instStruct !lstringWith(!"harmlessCode") !instCode)
    #data deps
    addListValue(!?instStruct !lstringWith(!"staticInfoWrite") ![regWriteAccessMap fillTemplate])
    #write mem access
    addListValue(!?instStruct !lstringWith(!"memSpaceWriteAccess") !stringSetToList(!memSpaceWriteAccess !"name"))
    #end
    staticData += !instStruct
  end
  addListValue ( !?cfg !lstringWith(!"staticData") !staticData)  
}

getter @staticInfoMapRegWrite fillTemplate
  -> @TfieldMapList staticInfoList
{
  staticInfoList = @TfieldMapList.emptyList
  for () in self do
    var regWritten =@TfieldMap.emptyMap{}
    addLStringValue(!?regWritten !"regName" !lkey)
    var regDepList = @TfieldMapList.emptyList
    for (idfDep) in depList do
      var regDep =@TfieldMap.emptyMap{}
      addStringValue(!?regDep !lstringWith(!"reg") ![idfDep harmlessCode])
      regDepList += !regDep
    end
    addBoolValue (!?regWritten !lstringWith(!"staticallyDefined") ![self isDefinedStatically !lkey])
    addListValue(!?regWritten !lstringWith(!"regDepWriteList") !regDepList)
    addListValue(!?regWritten !lstringWith(!"memSpaceReadAccess") !stringSetToList(!memSpaceReadAccess !"name"))
    staticInfoList += !regWritten
  end
}


method @instructionList processStaticInfo
  ?let  @varIdfStruct idfStruct
  ?! @symbolValueMap symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @stringset memSpaceWriteAccess
  ?let @bool goInsideFunc
{
  for > () in self do #start with last instruction.
    [inst processStaticInfo !idfStruct !?symbolValueMap !?regWriteAccessMap !?memSpaceWriteAccess !goInsideFunc]
    #message [inst generateCode !0 !@codeCtx. C]+"\n";
  end
}

method @instruction processStaticInfo
  ?let  @varIdfStruct unused idfStruct
  ?! @symbolValueMap unused symbolValueMap
  ?! @staticInfoMapRegWrite unused regWriteAccessMap
  ?! @stringset unused memSpaceWriteAccess
  ?let @bool unused goInsideFunc
  {}

func updateDepsForVar
  ?let @staticInfoMapRegWrite regWriteAccessMap #map to update
  ?let @lstring varNameWritten #updated var name
  ?let @expIdfList varDepList  #dependancies of the newly updated var.
  ?let @stringset varMemSpaceReadAccess #memSpaceRead by the newly updated var
  ->@staticInfoMapRegWrite newRegWriteAccessMap
{
  #we have for instance: C = A+B => C depends on A and B
  # so, if C is a dep of another idfs, let's say:
  # D = C+E
  # is should be:
  # - removed from the list of deps to these idfs (D)
  # - and replaced by A and B
  # => D deps of E,A,B. D inherits memReadAccess of C
  # the removal of duplicates is done at the end of the function.
  @staticInfoMapRegWrite newRegWriteAccessMapTmp = .emptyMap
  for () in regWriteAccessMap do
    @stringset newMemSpaceReadAccess = memSpaceReadAccess
    #foreach reg that is written
    #message "check "+[lkey string]+" with "+[varNameWritten string]+"\n"
    @expIdfList idfDepList = .emptyList
    for (idfDep) in depList do #@expIdf idf
      #we check each dependancy
      @bool depUpdated = false
      if [idfDep detectedType] == @idfType.registerAccess |
         [idfDep detectedType] == @idfType.localVar then
         [[idfDep idfList] first ?var @lstring varNameDep ?* ?* ?* ?* ?* ?*]
         #message "\tdep "+[varNameDep string]+"\n"
         #one dependency is 'varNameWritten'
         if [varNameDep string] == [varNameWritten string] then
           #message "\t\tupdate "+[varNameWritten string]+" in "+[lkey string]+"\n"
           depUpdated=true
         end
      #elsif [idfDep detectedType] == @idfType.memoryAccess then
      #  message "detect mem read '"+[idfDep getMemSpaceName]+"'\n"
      #  memSpaceReadAccess += ![idfDep getMemSpaceName]
      end
      #add all except the updated one
      if not depUpdated then
        #not updated => the var write does not depends on varNameWritten
        #message "\t\tadd "+[[idfDep idfList] string]+"\n"
        idfDepList += !idfDep
      else
        #updated => the var write depends on varNameWritten,
        #we should replace it by the dependencies of 'varNameWritten'
        #message "\t\treplacement of "+[varNameWritten string]+" with ";
        #[regWriteAccessMap searchKey !varNameWritten ?@expIdfList depWList ?*]
        idfDepList += varDepList
        newMemSpaceReadAccess += varMemSpaceReadAccess
      end
    end
    [!?newRegWriteAccessMapTmp insertKey !lkey !idfDepList !newMemSpaceReadAccess]
  end
  newRegWriteAccessMap = [newRegWriteAccessMapTmp removeDuplicates]
}

#in an assigment, we detect the dependencies of a var access.
override method @instAssignment processStaticInfo
  ?let  @varIdfStruct idfStruct
  ?! @symbolValueMap unused symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @stringset unused memSpaceWriteAccess
  ?let @bool unused goInsideFunc
{
  #tmp: => TODO: registerBitField, 2 valeurs. Pas dur, mais attention si modif
  # du registre complet!
  if [idfAssign detectedType] == @idfType.registerAccess |
     [idfAssign detectedType] == @idfType.localVar then
    [[idfAssign idfList] first ?var @lstring varNameWritten ?* ?* ?* ?* ?* ?*]
#    message "**** processing write of "+[varNameWritten string]+"****\n"
    #get deps.
    @expIdfList depList = .emptyList
    #depList = [exp getIdf !depList !idfStruct]
    depList += [exp getIdf !idfStruct]

    #is there a read access on a mem space?
    var memSpaceReadAccess = @stringset.emptySet
    for (idfDep) in depList do #@expIdf idf    
      if [idfDep detectedType] == @idfType.memoryAccess then
        #message "detect mem read '"+[idfDep getMemSpaceName]+"'\n"
        memSpaceReadAccess += ![idfDep getMemSpaceName]
      end
    end 

    #insert reg access (write) into map
    if not [regWriteAccessMap hasKey ![varNameWritten string]] then 
      #if it is already ok, don't update, as we
      #get instructions in reverse order.
      [!?regWriteAccessMap insertKey !varNameWritten !depList !memSpaceReadAccess]
    end
    #We update dependencies
    regWriteAccessMap = updateDepsForVar(!regWriteAccessMap !varNameWritten !depList !memSpaceReadAccess)
    #final    
#    debugRegWriteAccessMap(!regWriteAccessMap)
  end
}

override method @instFunctionCall processStaticInfo
  ?let @varIdfStruct idfStruct
  ?! @symbolValueMap symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @stringset memSpaceWriteAccess
  ?let @bool goInsideFunc
  {
    switch [exp detectedType]
    case unknown,structMember,localVar,tabularAccess,registerAccess,registerBitField:
      error loc: "internal error: invalid detected type for a function call"+
                 [[exp detectedType] string]
    case componentCall:
      if goInsideFunc then
        #TODO: alias de variables.
        @instructionList instList = [idfStruct.componentMap getInstList ![exp idfList]]
        @parameterDefList paramDef = [idfStruct.componentMap getParamDefList ![exp idfList]]
        @expressionlist paramList = [[[self exp] idfList] paramListAtIndex !1]

        @varIdfStruct nextIdfStruct = idfStruct 
        [paramDef getInlinedInsts !paramList !@expressionContext.component 
                                  !loc !loc
                                  !idfStruct !?nextIdfStruct 
                                  ?@instructionList instListCall]
        @instructionList fullInstList = instListCall+instList
        [fullInstList processStaticInfo !idfStruct !?symbolValueMap !?regWriteAccessMap !?memSpaceWriteAccess !goInsideFunc]
      end
    case memoryAccess: #mem write access to a mem space.
      #get mem space name from the instruction
      memSpaceWriteAccess += ![[self exp] getMemSpaceName]
    case periphCall,timing,signal: #nothing here.
      error loc: "internal error: no static information available for peripherals, timings and signals"
  end
}

override method @instIf processStaticInfo
  ?let @varIdfStruct idfStruct
  ?! @symbolValueMap symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @stringset memSpaceWriteAccess
  ?let @bool goInsideFunc
{
  @staticInfoMapRegWrite regWriteAccessMapIf   = regWriteAccessMap
  @staticInfoMapRegWrite regWriteAccessMapElse = regWriteAccessMap
  
  @symbolValueMap symbolValueMapIf   = symbolValueMap
  @symbolValueMap symbolValueMapElse = symbolValueMap

  @stringset memSpaceWriteAccessIf   = memSpaceWriteAccess
  @stringset memSpaceWriteAccessElse = memSpaceWriteAccess

  #in an if statement, it depends on both if and else.
  # *******
  #TODO: À refaire: c'est faux: il faut prendre le max des 2
  #actuellement, si on regarde la première branche et qu'il y a un accès
  #alors l'accès dans la 2e branche sera simplement ignoré (puisque c'est une maj)
  #il faut faire le traitement à la main.

  # *******
  [instIfList processStaticInfo   !idfStruct 
                                  !?symbolValueMapIf 
                                  !?regWriteAccessMapIf 
                                  !?memSpaceWriteAccessIf
                                  !goInsideFunc]
  [instElseList processStaticInfo !idfStruct 
                                  !?symbolValueMapElse 
                                  !?regWriteAccessMapElse 
                                  !?memSpaceWriteAccessElse
                                  !goInsideFunc]

  memSpaceWriteAccess = memSpaceWriteAccessIf | memSpaceWriteAccessElse
  #1 -> merge the two regWriteAccessMap maps (if and else)
  @staticInfoMapRegWrite regWriteAccessMapMerged = .emptyMap
  for (lkey depList memSpaceReadAccess) in regWriteAccessMapIf 
  do
    if [regWriteAccessMapElse hasKey ![lkey string]] then
      #value written in the 2 branches. Merge.
      [regWriteAccessMapElse searchKey !lkey ?@expIdfList depListElse
                                             ?@stringset memSpaceReadAccessElse]
      [!?regWriteAccessMapMerged insertKey !lkey !depList+depListElse
                                           !(memSpaceReadAccess | memSpaceReadAccessElse)] 
    else
      #value written in one branch only. Add in merge map.
      [!?regWriteAccessMapMerged insertKey !lkey !depList !memSpaceReadAccess]
    end
  end
  for (lkey depList memSpaceReadAccess) in regWriteAccessMapElse do
    if not [regWriteAccessMapIf hasKey ![lkey string]] then
      #value written in the other branch only. Add in merge map.
      [!?regWriteAccessMapMerged insertKey !lkey !depList !memSpaceReadAccess]
    end
  end  
  #2 -> moreover, for each reg that have been written inside a instIf block, 
  #it also depends on the condition expression.
  ######################################################
  #TODO: c'est ici qu'on defini un saut conditionnel…
  #      mais la cible peut être connue.
  #      À mettre à jour.
  ######################################################
  for (lkey depList *) in regWriteAccessMapMerged do
    #@expIdfList depListUpdated =  depList + [cond getIdf !depList !idfStruct]
    @expIdfList depListUpdated =  depList + [cond getIdf !idfStruct]
    [!?regWriteAccessMapMerged setDepListForKey !depListUpdated ![lkey string]]
  end
  #3 -> combine the 2 maps regWriteAccessMap and regWriteAccessMapMerged
  for (lkey depList memSpaceReadAccess) in regWriteAccessMapMerged do
    if not [regWriteAccessMap hasKey ![lkey string]] then 
      #if reg is in the map, it will be written after (as we
      #get instructions in reverse order.
      [!?regWriteAccessMap insertKey !lkey !depList !memSpaceReadAccess]
    end
    #message "update deps\n"
    #We update dependencies
    regWriteAccessMap = updateDepsForVar(!regWriteAccessMap !lkey !depList !memSpaceReadAccess)
    #message "done update \n"
  end
}

#there are duplicates in the dependency lists
#for instance:
# A = B+C
# D = B+A  => D depends on B-B-C.
getter @staticInfoMapRegWrite removeDuplicates 
 -> @staticInfoMapRegWrite newInfoMap
{
  newInfoMap = .emptyMap
  for () in self do
    @stringset set=.default
    @expIdfList updatedDepList =.emptyList
    for (@expIdf idf) in depList do
      @string key = [idf string]
      if not [set hasKey !key] then 
        #not a duplicate
        updatedDepList += !idf
        set += !key
      end
    end
    [!?newInfoMap insertKey !lkey !updatedDepList !memSpaceReadAccess]
  end
}

#This getter returns true if the variable can be
#defined statically). This means that a var that only depends on hard-coded
#values in the instruction format is a const.
getter @staticInfoMapRegWrite isDefinedStatically
 ? @lstring regName
 ->@bool const
{
  const = true
  if [self hasKey ![regName string]] then
    [self searchKey !regName ?@expIdfList depList ?@stringset memSpaceReadAccess]
    if [memSpaceReadAccess count] > 0 then
      const = false #value depends on a memory access
    else
      for dep in depList while const do
        const = [[dep idf] isDefinedStatically]
      end
    end
  else
    error regName: "internal error: The value is not written"
  end
}

# vim:ft=galgas:ts=2:sw=2:tw=0
