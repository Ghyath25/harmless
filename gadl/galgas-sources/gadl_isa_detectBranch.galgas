# new approach, get static info (including branch detection).

# donc staticInfo est une map (clé l'instruction traitée) qui contient 
# => une map (clé registre en écriture)
#    Pour chaque registre écrit:
#     => conditionnellement?
#     => valeur connu statiquement? => n'est pas redondant avec l'expression?
#     => expression pour connaitre la valeur dynamiquement.
# => une map (clé registre en lecture)
#     => conditionnellement?

# un truc à mettre à jour: TODO TODO TODO!!
# si on fait un accès à un composant qui retourne une valeur… ça ne marchera pas
# car l'accès est vu à l'intérieur d'une expression. Il faut toutes les parser :-/
# TODO: gestion des accès mémoire forcément, ça casse tout :-/

# TODO: pour le isConst, il suffit de parcourir la liste des depList opur tester 
#       le paramètre isConst… à moins que ce soit le valueUnkown?
#       => non, car il y a les accès mémoire aussi.

# This is the main map
# Key is the instruction.
# It contains:
# * regWriteAccessMap: map of reg that are written (key is the var written)
# * regReadAccessMap: map of reg that are read (key is the var written)
map @staticInfoMap {
  @staticInfoMapRegWrite regWriteAccessMap
  @staticInfoMapRegRead regReadAccessMap
  insert insertKey error message "the '%K' for static info is already defined in %L" 
  search searchKey error message "the '%K' for static info is not defined"
}


map @staticInfoMapRegWrite {
  @expIdfList depList      #dependancies, i.e. registers and local vars that affect values.
  @bool memAccess          #does var value depend on mem access
#  @bool valueUnknown       #true if value may not be known statically.
#  @expression exp          #expression to get value if available
  insert insertKey error message "the '%K' for static reg write info is already defined in %L" 
  search searchKey error message "the '%K' for static reg write info is not defined"
}

map @staticInfoMapRegRead {
  @bool memAccess #does var value depend on mem access
  insert insertKey error message "the '%K' for static reg read info is already defined in %L" 
  search searchKey error message "the '%K' for static reg read info is not defined"
}


# This is the routine that is called from an external file.
getter @decodedBehaviorMap getStaticInfo
  ?let  @varIdfStruct idfStruct
  -> @staticInfoMap staticInfoMap
{
  staticInfoMap = @staticInfoMap.emptyMap
  for () in  self do
    @symbolValueMap symbolValueMap = .emptyMap
    @staticInfoMapRegWrite regWriteAccessMap = .emptyMap
    @staticInfoMapRegRead regReadAccessMap = .emptyMap

#   if [lkey string] == "e200z4_SP_Check_abs_bc_bd_bi_bo_d_f_statPred_updatelr_z" then #complexe
#   if [lkey string] == "e200z4_br_half_load_notu_ra_rb_rd_x" then      
    if [lkey string] == "e200z4_SP_Check_abs_b_li_updatelr" then #simple
      message "instruction "+[lkey string];
      [instList processStaticInfo !idfStruct !?symbolValueMap 
                                  !?regWriteAccessMap !?regReadAccessMap !true]
      message ":\n"
    end
    

    [[regWriteAccessMap removeDuplicates] debugRegWriteAccessMap]
    [!?staticInfoMap insertKey !lkey ![regWriteAccessMap removeDuplicates] !regReadAccessMap]
  end
}

method @instructionList processStaticInfo
  ?let  @varIdfStruct idfStruct
  ?! @symbolValueMap symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @staticInfoMapRegRead regReadAccessMap
  ?let @bool goInsideFunc
{
  for > () in self do #start with last instruction.
    [inst processStaticInfo !idfStruct !?symbolValueMap !?regWriteAccessMap !?regReadAccessMap !goInsideFunc]
    #message [inst generateCode !0 !@codeCtx. C]+"\n";
  end
}

method @instruction processStaticInfo
  ?let  @varIdfStruct unused idfStruct
  ?! @symbolValueMap unused symbolValueMap
  ?! @staticInfoMapRegWrite unused regWriteAccessMap
  ?! @staticInfoMapRegRead unused regReadAccessMap
  ?let @bool unused goInsideFunc
  {}

func updateDepsForVar
  ?let @staticInfoMapRegWrite regWriteAccessMap
  ?let @lstring varNameWritten
  ->@staticInfoMapRegWrite newRegWriteAccessMap
{
  #we have for instance: C = A+B => C depends on A and B
  # so, if C is a dep of another idfs, let's say:
  # D = C+E
  # is should be:
  # - removed from the list of deps to these idfs (D)
  # - and replaced by A and B
  # TODO: remove duplicates.
  newRegWriteAccessMap = @staticInfoMapRegWrite.emptyMap
  for () in regWriteAccessMap do
    #foreach reg that is written
    #message "check "+[lkey string]+" with "+[varNameWritten string]+"\n"
    @expIdfList idfDepList = .emptyList
    for (idfDep) in depList do#@expIdf idf
      #we check each dependency
      @bool depUpdated = false
      if [idfDep detectedType] == @idfType.registerAccess |
         [idfDep detectedType] == @idfType.localVar then
         [[idfDep idfList] first ?var @lstring varNameDep ?* ?* ?* ?* ?* ?*]
         #message "\tdep "+[varNameDep string]+"\n"
         #one dependency is 'varNameWritten'
         if [varNameDep string] == [varNameWritten string] then
           #message "\t\tupdate "+[varNameWritten string]+" in "+[lkey string]+"\n"
           depUpdated=true
         end
      end
      #add all except the updated one
      if not depUpdated then
        #not updated => the var write does not depends on varNameWritten
        #message "\t\tadd "+[[idfDep idfList] string]+"\n"
        idfDepList += !idfDep
      else
        #updated => the var write depends on varNameWritten,
        #we should replace it by the dependencies of 'varNameWritten'
        #message "\t\treplacement of "+[varNameWritten string]+" with ";
        [regWriteAccessMap searchKey !varNameWritten ?@expIdfList depWList ?*]
        idfDepList += depWList
      end
    end
    [!?newRegWriteAccessMap insertKey !lkey !idfDepList !memAccess]
  end
}

#debug method.
method @staticInfoMapRegWrite debugRegWriteAccessMap
{
  for () in self
  before message "\tdeps:\n"
  do
    message "\t\t"+[lkey string]+":"
    for (idfDep) in depList do
      message [[idfDep idfList] string]
    between message ", "
    end
    message " --> "
    if not [self isConst !lkey] then message "not " end
    message "const"
  between message "\n"
  after message "\n"
  end
}

#in an assigment, we detect the dependencies of a var access.
override method @instAssignment processStaticInfo
  ?let  @varIdfStruct idfStruct
  ?! @symbolValueMap unused symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @staticInfoMapRegRead unused regReadAccessMap
  ?let @bool unused goInsideFunc
{
  #tmp: => TODO: registerBitField, 2 valeurs. Pas dur, mais attention si modif
  # du registre complet!
  if [idfAssign detectedType] == @idfType.registerAccess |
     [idfAssign detectedType] == @idfType.localVar then
    [[idfAssign idfList] first ?var @lstring varNameWritten ?* ?* ?* ?* ?* ?*]
#    message "**** processing write of "+[varNameWritten string]+"****\n"
    #get deps.
    @expIdfList depList = .emptyList
    depList = [exp getIdf !depList !idfStruct]

    #insert reg access (write) into map
    if not [regWriteAccessMap hasKey ![varNameWritten string]] then 
      #if it is already ok, don't update, as we
      #get instructions in reverse order.
      #TODO: conditionnalAccess to be computed.
      #TODO: value known
      [!?regWriteAccessMap insertKey !varNameWritten !depList !false]
    end
    #We update dependencies
    regWriteAccessMap = updateDepsForVar(!regWriteAccessMap !varNameWritten)
    #final    
#    debugRegWriteAccessMap(!regWriteAccessMap)
  end
}

override method @instFunctionCall processStaticInfo
  ?let @varIdfStruct idfStruct
  ?! @symbolValueMap symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @staticInfoMapRegRead regReadAccessMap 
  ?let @bool goInsideFunc
  {
    switch [exp detectedType]
    case unknown,structMember,localVar,tabularAccess,registerAccess,registerBitField:
      error loc: "internal error: invalid detected type for a function call"+
                 [[exp detectedType] string]
    case componentCall:
      if goInsideFunc then
        #TODO: alias de variables.
        @instructionList instList = [idfStruct.componentMap getInstList ![exp idfList]]
        @parameterDefList paramDef = [idfStruct.componentMap getParamDefList ![exp idfList]]
        @expressionlist paramList = [[[self exp] idfList] paramListAtIndex !1]

        @varIdfStruct nextIdfStruct = idfStruct 
        [paramDef getInlinedInsts !paramList !@expressionContext.component 
                                  !loc !loc
                                  !idfStruct !?nextIdfStruct 
                                  ?@instructionList instListCall]
        @instructionList fullInstList = instListCall+instList
        [fullInstList processStaticInfo !idfStruct !?symbolValueMap !?regWriteAccessMap !?regReadAccessMap !goInsideFunc]
      end
    case memoryAccess:
      #TODO: on peut recuperer de l'info ici => c'est une ecriture
    case periphCall,timing,signal: #nothing here.
  end
}

override method @instIf processStaticInfo
  ?let @varIdfStruct idfStruct
  ?! @symbolValueMap symbolValueMap
  ?! @staticInfoMapRegWrite regWriteAccessMap
  ?! @staticInfoMapRegRead regReadAccessMap 
  ?let @bool goInsideFunc
{
  @staticInfoMapRegWrite regWriteAccessMapIf   = regWriteAccessMap
  @staticInfoMapRegWrite regWriteAccessMapElse = regWriteAccessMap
  
  @symbolValueMap symbolValueMapIf   = symbolValueMap
  @symbolValueMap symbolValueMapElse = symbolValueMap
  
  @staticInfoMapRegRead regReadAccessMapIf   = regReadAccessMap
  @staticInfoMapRegRead regReadAccessMapElse = regReadAccessMap
  #in an if statement, it depends on both if and else.
  # *******
  #TODO: À refaire: c'est faux: il faut prendre le max des 2
  #actuellement, si on regarde la première branche et qu'il y a un accès
  #alors l'accès dans la 2e branche sera simplement ignoré (puisque c'est une maj)
  #il faut faire le traitement à la main.

  # *******
  [instIfList processStaticInfo   !idfStruct 
                                  !?symbolValueMapIf 
                                  !?regWriteAccessMapIf 
                                  !?regReadAccessMapIf 
                                  !goInsideFunc]
  [instElseList processStaticInfo !idfStruct 
                                  !?symbolValueMapElse 
                                  !?regWriteAccessMapElse 
                                  !?regReadAccessMapElse
                                  !goInsideFunc]
  #1 -> merge the two regWriteAccessMap maps (if and else) => checked.
  @staticInfoMapRegWrite regWriteAccessMapMerged = .emptyMap
  for (lkey depList memAccess) in regWriteAccessMapIf do
    message " -- > "+[lkey string]+"\n"
    if [regWriteAccessMapElse hasKey ![lkey string]] then
      #value written in the 2 branches. Merge.
      [regWriteAccessMapElse searchKey !lkey ?@expIdfList depListElse
                                             ?@bool memAccessElse]
      [!?regWriteAccessMapMerged insertKey !lkey !depList+depListElse
                                           !(memAccess | memAccess)] 
    else
      message "else\n"
      #value written in one branch only. Add in merge map.
      [!?regWriteAccessMapMerged insertKey !lkey !depList !memAccess]
    end
  end
  for (lkey depList memAccess) in regWriteAccessMapElse do
    if not [regWriteAccessMapIf hasKey ![lkey string]] then
      #value written in the other branch only. Add in merge map.
      [!?regWriteAccessMapMerged insertKey !lkey !depList !memAccess]
    end
  end  
  #2 -> moreover, for each reg that have been written inside a instIf block, 
  #it also depends on the condition expression.    
  for (lkey depList *) in regWriteAccessMapMerged do
    @expIdfList depListUpdated =  depList + [cond getIdf !depList !idfStruct]
    [!?regWriteAccessMap setDepListForKey !depListUpdated ![lkey string]]
  end
  #3 -> combine the 2 maps regWriteAccessMap and regWriteAccessMapMerged
  for (lkey depList memAccess) in regWriteAccessMapMerged do
    if not [regWriteAccessMap hasKey ![lkey string]] then 
      #if it is already ok, don't update, as we
      #get instructions in reverse order.
      [!?regWriteAccessMap insertKey !lkey !depList !memAccess]
    end
    #We update dependencies
    regWriteAccessMap = updateDepsForVar(!regWriteAccessMap !lkey)
  end
}

#there are duplicates in the dependencies.
getter @staticInfoMapRegWrite removeDuplicates 
 -> @staticInfoMapRegWrite newInfoMap
{
  newInfoMap = .emptyMap
  for () in self do
    @stringset set=.default
    @expIdfList updatedDepList =.emptyList
    for (@expIdf idf) in depList do
      @string key = [idf string]
      if not [set hasKey !key] then 
        #not a duplicate
        updatedDepList += !idf
        set += !key
      end
    end
    [!?newInfoMap insertKey !lkey !updatedDepList 
                  !memAccess]
  end
}

#This getter returns true if the variable is const (i.e. its value can be
#defined statically). This means that a var that only depends on hard-coded
#values in the instruction format is a const.
getter @staticInfoMapRegWrite isConst
 ? @lstring regName
 ->@bool const
{
  const = true
  if [self hasKey ![regName string]] then
    [self searchKey !regName ?@expIdfList depList ?@bool memAccess]
    if memAccess then
      const = false #value depends on a memory access
    else
      for dep in depList while const do
        const = [[dep idf] isConst]
      end
    end
  else
    error regName: "internal error: The value is not written"
  end
}
# vim:ft=galgas:ts=2:sw=2:tw=0
