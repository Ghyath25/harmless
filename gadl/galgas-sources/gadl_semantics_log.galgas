#############################################################################
# generate information for log templates
#############################################################################

# First generate the expression in Harmless (instead of unreadable C generated code).

############# getter @expression harmlessCode

abstract getter @expression harmlessCode
  -> @string
;

override getter @expDummy harmlessCode
  -> @string code
{code = lstringWith(!expCode)}

override getter @expBinary harmlessCode
  -> @string code
{
  code = "("+[expLeft harmlessCode]
  if    id == 0 then code += ")*("
  elsif id == 1 then code += ")/("
  elsif id == 2 then code += ")%("
  elsif id == 3 then code += ")+("
  elsif id == 4 then code += ")-("
  elsif id == 5 then code += ")>>("
  elsif id == 6 then code += ")<<("
  elsif id == 7 then code += ")<("
  elsif id == 8 then code += ")>("
  elsif id == 9 then code += ")<=("
  elsif id == 10 then code += ")>=("
  elsif id == 11 then code += ")=("
  elsif id == 12 then code += ")!=("
  elsif id == 13 then code += ")&("
  elsif id == 14 then code += ")^("
  elsif id == 15 then code += ")|("
  elsif id == 16 then code += ")&&("
  elsif id == 17 then code += ")^^("
  elsif id == 18 then code += ")||("
  elsif id == 19 then code += ") ror ("
  elsif id == 20 then code += ") rol ("
  elsif id == 21 then code += ") cat ("
  end
  code += [expRight harmlessCode]+")"
}

override getter @expBitFieldOp harmlessCode
  -> @string code
{
  code = [expField harmlessCode]
  for () in fList 
  before code += "{"
  do code += [expFrom harmlessCode] 
  if not only1Exp then code += ".." + [expTo harmlessCode] end
  between code += ", "
  after code += "}"
  end
}

override getter @expCast harmlessCode
  -> @string code
{
  code = "(" + [type string] + ")("+ [expCasted harmlessCode] + ")"
}

override getter @expIdf harmlessCode
  -> @string code
{
  #code = [self string] #TODO This is for debug, no parameters, nor tab expression indexes!
  code = ""
  for (@lstring idf @idfItemType type @expressionlist paramList ...) in idfList 
  do
    code+=[idf string]
    for param in paramList
    before 
      if type == @idfItemType.functionCall then code += "(" end
      if type == @idfItemType.tabular then code += "[" end
    do
      code += [[param exp] harmlessCode]
    between code += ","
    after
      if type == @idfItemType.functionCall then code += ")" end
      if type == @idfItemType.tabular then code += "]" end
    end
  between code += "."
  end
}

override getter @expInstructionAddress harmlessCode
  -> @string code
{
  code = "instruction address"
}

override getter @expInstructionSize harmlessCode
  -> @string code
{
  code = "instruction size"
}

override getter @expIntConst harmlessCode
  -> @string code
{
  code = ""
  if negative then code += "-" end
  code += [value string]
}

override getter @expUnary harmlessCode
  -> @string code
{
  code = "("+[exp harmlessCode]
  if    id == 0 then code = "!"
  elsif id == 1 then code = "~"
  elsif id == 2 then code = "-"
  end
  code += [exp harmlessCode]
}

############# getter @instruction harmlessCode

abstract getter @instruction harmlessCode
  ?let @uint unused nbTabs
  -> @string

getter @instructionList harmlessCode
  ?let @uint nbTabs
  -> @string code
{
  code = ""
  for (inst) in self
  do code += tabs(!nbTabs) + [inst harmlessCode !nbTabs] + "\n"
  end
}

override getter @instAssignment harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  code = [idfAssign harmlessCode]
  for () in flist 
  before code += "{"
  do code += [expFrom harmlessCode] 
  if not only1Exp then code += ".." + [expTo harmlessCode] end
  between code += ", "
  after code += "}"
  end
  code += " := " + [exp harmlessCode]
}

override getter @instDeclaration harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  code = [type string] + " " + [self name]
}

override getter @instError harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  if onlyWarn then code = "warning " else code = "error " end
  code += [msg string]
}

override getter @instFunctionCall harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  code = [exp harmlessCode]
}

override getter @instIf harmlessCode
  ?let @uint nbTabs
  -> @string code
{
  code = "if " + [cond harmlessCode] + " then\n"
  code += [instIfList harmlessCode !nbTabs+1]
  if [instElseList length] != 0 then 
    code += tabs(!nbTabs) + "else\n"
    code += [instElseList harmlessCode !nbTabs+1]
  end 
  code += tabs(!nbTabs)+"end if"
}

override getter @instLoop harmlessCode
  ?let @uint nbTabs
  -> @string code
{
  code = "loop " + [guard harmlessCode] + "\n"
  code += tabs(!nbTabs) + "while " + [expCondition harmlessCode] + "do\n"
  code += [loopInstList harmlessCode !nbTabs+1]
  code += tabs(!nbTabs) + "end loop"
}

override getter @instMessage harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  code = "print " + [msg string]
}

override getter @instNop harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
 code = "nop"+[cond harmlessCode]+"instruction"
}

override getter @instPrint harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  code = "print " + [exp harmlessCode]
}

override getter @instReturn harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
 code = "return "+[exp harmlessCode]
}

override getter @instTypeDefinition harmlessCode
  ?let @uint unused nbTabs
  -> @string code
{
  code = "'typedef of "+[idf string]+"'"
}

# vim:ft=galgas:ts=2:sw=2
