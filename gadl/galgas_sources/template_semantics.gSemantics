#---------------------------------------------------------------------------*
#                                                                           *
#  Types for GOIL templates                                                 *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

# * addBoolValue
# * addUnsignedValue
# * addLUnsignedValue
# * addStringValue
# * addLStringValue
# * addListValue
# * addStructValue
# * addEnumValue

semantics template_semantics :

function tabsTpl 
  ?? @uint nbTabulation
  -> @string code
:
  code := "";
  @uint val := nbTabulation;
  loop nbTabulation + 1:
  while val > 0 do
    code .= "\t";
    val--;
  end loop;
end function;


#------------------------------------------------------------------------------*

enum @Ttype {
  boolType,
  unsignedType,
  stringType,
  listType,
  mapType,
  structType,
  enumType,
  unconstructedType
}

#------------------------------------------------------------------------------*

reader @Ttype messageGoilTemplateType -> @string outResult :
  switch selfcopy
    when boolType : outResult := "bool";
    when unsignedType : outResult := "unsigned";
    when stringType : outResult := "string";
    when listType : outResult := "list";
    when mapType : outResult := "map";
    when structType : outResult := "struct";
    when enumType : outResult := "enum";
    when unconstructedType : outResult := "unconstructed";
  end switch; 
end reader; 

#------------------------------------------------------------------------------*

list @TtypeList {
  @Ttype mType;
}

#------------------------------------------------------------------------------*

map @TfieldMap {
  @Ttype  mType;
  @Tvalue mValue; 
  insert insertKey error message "a template field named '%K' is already declared in %L";
  search searchKey error message "there is no template field named '%K'";
  remove removeKey error message "there is no template field named '%K' to delete";
}

#------------------------------------------------------------------------------*

list @TfieldMapList {
  @TfieldMap mMap feature setter;
}

#------------------------------------------------------------------------------*

struct @Tvalue {
  @uint64 mUnsigned64Value;
  @string mStringValue;
  @TfieldMapList mMapListValue;
  @TfieldMap mStructValue;
}

#------------------------------------------------------------------------------*

list @TexpressionList {
  @Tvalue mValue;
  @Ttype mType;
}

#------------------------------------------------------------------------------*

list @TenumationList {
  @Tvalue mEnumeratedValue;
  @string mPrefix;
}

#------------------------------------------------------------------------------*

function valueWithBool
  ??@bool inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    ![inValue uint64]
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithUnsigned
  ??@uint64 inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !inValue
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithString
  ??@string inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !inValue
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithStruct
  ??@TfieldMap inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !""
    ![@TfieldMapList emptyList]
    !inValue
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithMap
  ??@TfieldMap inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !""
    ![@TfieldMapList emptyList]
    !inValue
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithVoid
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

routine addBoolValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@bool inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype boolType]
    !valueWithBool[!inValue]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addUnsignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@uint64 inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype unsignedType]
    !valueWithUnsigned[!inValue]
    #[@goilTemplateValue new !inValue !"" ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addLUnsignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@string inVariableName
  ??@luint64 inValue
:
  addUnsignedValue !?ioTemplateVariableMap ![@lstring new !inVariableName ![inValue location]] ![inValue uint64];
end routine;

#------------------------------------------------------------------------------*

routine addStringValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype stringType]
    !valueWithString[!inValue]
    #[@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addLStringValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@string inVariableName
  ??@lstring inValue
:
  addStringValue !?ioTemplateVariableMap ![@lstring new !inVariableName ![inValue location]] ![inValue string];
end routine;

#------------------------------------------------------------------------------*

routine addListValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@TfieldMapList inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype listType]
    ![@Tvalue new !0L !"" !inValue ![@TfieldMap emptyMap]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addStructValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@TfieldMap inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype structType]
    ![@Tvalue new !0L !"" ![@TfieldMapList emptyList] !inValue]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addEnumValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype enumType]
    !valueWithString[!inValue]
    #[@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*
function stringSetToList
  ?? @stringset stringSet
  ?? @string idName
  -> @TfieldMapList TfieldMapList
:
  #store the set in a list.
  TfieldMapList := [@TfieldMapList emptyList];
  foreach stringSet (@string id) do
    @TfieldMap body [emptyMap];
    addStringValue !?body ![@lstring new !idName !here] !id;
    TfieldMapList += !body;
  end foreach;
end function;

#------------------------------------------------------------------------------*

list @TvarPath {
  @lstring item;
  @lstring key;
}

#------------------------------------------------------------------------------*

routine searchField
  ?@TvarPath variable
  ??@TfieldMap inTemplateFieldMap
  !@Ttype variableType
  !@Tvalue variableValue
  !@location variableLocation
:
  @lstring field;
  @lstring key;
  variableLocation := here;
  [!?variable popFirst ?field ?key];
  [inTemplateFieldMap searchKey !field ?variableType ?variableValue];
  variableLocation := [inTemplateFieldMap locationForKey ![field string]];
  if [key string] != "" & variableType == [@Ttype mapType] then
    @TfieldMap mapMap := [variableValue mStructValue];
    [mapMap searchKey !key ?variableType ?variableValue];
    variableLocation := [mapMap locationForKey ![key string]];
  end if;
  if [variable length] > 0 then
    if variableType == [@Ttype structType] then
      searchField !variable ![variableValue mStructValue] ?variableType ?variableValue ?variableLocation;
    else
      variableLocation := here;
      error field: "struct variable expected": variableValue;
    end if;
  end if;
end routine;

#------------------------------------------------------------------------------*

routine searchFieldIfExists
  ?@TvarPath variable
  ??@TfieldMap inTemplateFieldMap
  !@Ttype variableType
  !@Tvalue variableValue
  !@bool found
:
  @lstring field;
  @lstring key;
  [!?variable popFirst ?field ?key];
  
  if [inTemplateFieldMap hasKey ![field string]] then
    [inTemplateFieldMap searchKey !field ?variableType ?variableValue];
    if [key string] != "" & variableType == [@Ttype mapType] then
      if [[variableValue mStructValue] hasKey ![key string]] then
        [[variableValue mStructValue] searchKey !key ?variableType ?variableValue];
        found := true;
      else
        found := false;
      end if;
    else
      found := true;
    end if;
  else
    variableType := [@Ttype unconstructedType];
    variableValue := valueWithVoid[];
    found := false;
  end if;
  if [variable length] > 0 & found then
    if variableType == [@Ttype structType] then
      searchFieldIfExists !variable ![variableValue mStructValue] ?variableType ?variableValue ?found;
    else
      found := false;
    end if;
  end if;
end routine;

########################################################################
## file managment TOOLS
########################################################################
#Open "fullFilename" and get its content. If it is different than the "content" in 
#argument, the file is updated. This is useful to prevent the make tool to rebuild an 
#unmodified file.
routine writeOnDiskIfUpdated
  ?? @string fullFilename
  ?? @string content
:
  @bool overwrite := true;
  #check if the file exists.
  if [fullFilename fileExists] then
    @string currentFileContent := [@string stringWithContentsOfFile !fullFilename];
    if currentFileContent == content then
      #file not changed.
      overwrite := false;
    end if;
  end if;
  if overwrite then
    [content makeDirectoryAndWriteToFile !fullFilename];
  end if;
end routine;  

#give full filename path
#if the file does not begins with '/', a "./" is added to use a correct relative path.
function getFullFileName
  ?? @string relativeDirectory
  ?? @string filename
  ->  @string fullFilename
:
  @string sourceFilePath := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent];
  if sourceFilePath == "" then
    if [[@string stringWithSourceFilePath] firstCharacterOrNul] != '/' then
      sourceFilePath := ".";
    end if;
  end if;
  fullFilename := [filename absolutePathFromPath !sourceFilePath."/".relativeDirectory];
  #message "file : ". fullFilename."\n";
end function;

#create the file and update if it does not exists.
routine createFile
  ?? @string directory
  ?? @string filename
  ?? @string content
:
  @string fullFilename := getFullFileName[!directory !filename];
  #[contentWithPreamble makeDirectoryAndWriteToFile !fullFilename];
  writeOnDiskIfUpdated !fullFilename ! content;
end routine;

########################################################################
## routines to get a log of the template data structure.
########################################################################

#debug value.
function printValue
  ?? @Ttype mType 
  ?? @Tvalue mValue
  ?? @uint nbTab
  -> @string str
:
  str := "";
  switch mType
  when boolType:
    if [mValue mUnsigned64Value] != 0L then str .= "true"; else str .= "false"; end if;
  when unsignedType:
    str .= [[mValue mUnsigned64Value] string];
  when stringType:
    str .= getXMLCompliant[![mValue mStringValue]];
  when listType:
    str .= extractListTemplateStructureRec[![mValue mMapListValue] !nbTab+1].tabsTpl[!nbTab];
  when mapType:
    str .= extractMapTemplateStructureRec[![mValue mStructValue] !nbTab+1].tabsTpl[!nbTab];
  when structType:
    str .= extractMapTemplateStructureRec[![mValue mStructValue] !nbTab+1].tabsTpl[!nbTab];
  when enumType:
    str .= [mValue mStringValue];
  when unconstructedType:
  end switch;
end function;

function getXMLCompliant
  ?  @string base
  -> @string xml
:
  xml := [base stringByReplacingStringByString !"&" !"&amp;"]; #XML
  xml := [xml stringByReplacingStringByString !"<" !"&lt;"];   #XML
  xml := [xml stringByReplacingStringByString !">" !"&gt;"];   #XML
  xml := [xml stringByReplacingStringByString !"\"" !"&quot;"];#XML
  xml := [xml stringByReplacingStringByString !"'" !"&apos;"]; #XML
end function;

#map type (recursive)
function extractMapTemplateStructureRec
  ?? @TfieldMap templateVariableMap
  ?? @uint nbTab
  -> @string str
:
  str := "";
  foreach templateVariableMap (@lstring key @Ttype mType @Tvalue mValue) do
    str .= "\n".tabsTpl[!nbTab]."<item key=\"".[key string]."\" type=\"".[mType messageGoilTemplateType]."\">";
    str .= printValue[!mType !mValue !nbTab];
    str .= "</item>";
  end foreach;
end function;

#list type (recursive)
function extractListTemplateStructureRec
  ?? @TfieldMapList templateVariableList
  ?? @uint nbTab
  -> @string str
:
  str := "";
  foreach templateVariableList (@TfieldMap fieldMap) do
    str .= extractMapTemplateStructureRec[!fieldMap !nbTab];
  end foreach;
  str .= "\n";
end function;

routine extractTemplateStructure
  ?? @TfieldMap templateVariableMap
  ?? @string filename
:
 @string str := "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>";
 str .= extractMapTemplateStructureRec[!templateVariableMap !0];
 str.= "\n</root>";
 createFile !"." !filename !str;
end routine;

#function getTemplateString
#  ?? @TfieldMap inTemplateFieldMap
#  ?? @lstring key
#  -> @string str
#:
#  @Tvalue variableValue;
#  @Ttype variableType;
#  searchField !path !inTemplateVariableMap ?variableType ?variableValue ?outWhere;
#end function;
end semantics;
# vim:ft=ggs:ts=2:sw=2
