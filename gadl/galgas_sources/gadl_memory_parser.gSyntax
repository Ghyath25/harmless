syntax gadl_memory_parser ("gadl_lexique.gLexique") :
  import "gadl_semantics_AST_expression.gSemantics" ;
  import "gadl_memory.gSemantics" ;
  import "gadl_semantics.gSemantics" ; #intMap

nonterminal <expression> !@ASTExpression exp;

rule <memorySpace>
  ?! @ASTmemSpaceMap ASTmemSpaceMap
:
  @bool isProgram := false;
  select
    $program$; isProgram:=true;
  or
  end select;
  $memory$;
  $space$;
  $idf$ ?@lstring memSpaceName;
  $width$;
  $unumber$ ?@luint64 lwidth;
  @uint width := [[lwidth uint64] uint];
  @boolMap methodMap [emptyMap];

  @uint stride := 1; #may be not defined. Use default.  
  select
  or
    $stride$; 
    @luint64 strideL;
    $unumber$ ?strideL;
    stride := [[strideL uint64] uint];
  end select;

  #possible accessors.

  [!?ASTmemSpaceMap insertKey !memSpaceName !width !isProgram !stride];
end rule;


rule <memoryChunk>
  ?! @ASTmemoryParamMap memChunk
  ?! @stringlist memChunkOrder
:
  #value initialized because Galgas can't verify that
  #they will have a parameter.
  @uint64 width := 0L;
  @ASTExpression expSize := [@ASTIntConst new !here !1L !false ![@varKind unsigned]]; #dummy value
  @memType access := [@memType rom];
  @bool widthDefined := false;
  @bool sizeDefined := false;
  @bool typeDefined := false;


  $memory$;
  @lstring name;
  $idf$ ?name;
  ${$;
  repeat
  while
    select
      $width$; $:=$;
      $unumber$ ?@luint64 lwidth;
      width := [lwidth uint64];
      widthDefined := true;
    or
      $size$; $:=$;
      <expression> ?expSize;
      sizeDefined := true;
    or
      $type$; $:=$;
      select
        $ROM$; access := [@memType rom];
      or
        $RAM$; access := [@memType ram];
      or
        $register$; access := [@memType GPR];
      end select;
      typeDefined := true;
    end select;
  end repeat;
  if not widthDefined then
    error here : "The memory chunk does not define any memory width (in bits)";
  end if;
  if not sizeDefined then
    error here : "The memory chunk does not define any memory size (in bytes)";
  end if;
  if not typeDefined then
    error here : "The memory chunk does not define any memory type (ram, rom, register or GPR)";
  end if;
  $}$;
  $maps$; $to$;
  @memoryMapping memoryMapping;
  <memoryMapping> ?memoryMapping;
  [!?memChunk insertKey !name !width !expSize !access !memoryMapping];
  memChunkOrder += ![name string]; 
end rule;

rule <memoryMapping>
  ! @memoryMapping memoryMapping
:
  @lstring memSpaceName;
  $idf$ ?memSpaceName;
  $:$;
  @luint64 address;
  $unumber$ ?address;
  memoryMapping := [@memoryMapping new !memSpaceName !address];
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
