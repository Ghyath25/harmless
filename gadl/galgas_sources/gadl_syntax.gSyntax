syntax gadl_syntax ("gadl_lexique.gLexique") :

import "gadl_options.gOption" ;
import "gadl_semantics_instruction.gSemantics" ;
import "gadl_instruction_properties.gSemantics";
import "gadl_semantics_detect_branch.gSemantics";
import "gadl_semantics_instruction_cycle.gSemantics" ;
import "gadl_semantics_peripherals.gSemantics" ;
import "gadl_grammar_include.gGrammar";
import "gadl_micro_architecture.gSemantics" ;
import "gadl_semantics_timingSection.gSemantics" ;
import "gadl_semantics_signalSection.gSemantics" ;
import "gadl_filewrappers.gSemantics" ;

nonterminal  <start_symbol> ;

nonterminal <default>
  ?! @defaultSection defaultValues
label secondPass
  ?! @defaultSection defaultValues
  ?? @componentMap componentMap
;

#component
nonterminal  <component>  
  ?! @varMap varMap 
  ?! @componentMap componentMap
  ?! @uint nbCyclicParts #id used to identify "foreach" sections.
;

#pipeline
nonterminal  <pipeline> 
  ?? @architectureMap architectureMap
  ?! @pipelineMap pipelineMap
;

#assembly of global pipeline
nonterminal <machine>
  ?? @componentMap componentMap
  ?! @machineMap machineMap
  ?? @pipelineMap pipelineMap
;

#architecture
nonterminal  <architecture>
  ?! @architectureMap archMap
  ?? @componentMap componentMap
;

#behavior
nonterminal  <behavior>  
  ?? @varMap varMap 
  ?! @behaviorPrototypeMap behaviorPrototypeMap 
label secondPass
  ?! @behaviorMap behaviorMap 
  ?? @varMap varMap 
  ?? @componentMap componentMap
  ?! @behaviorPrototypeMap behaviorPrototypeMap 
  ?! @uint internalBehaviorId
;

#format
nonterminal  <format>  
  ?? @luint instructionSize
  ?! @formatMap formatMap
  ?! @uint internalFormatId
;

#syntax
nonterminal  <printNumberType>
  ?! @printNumberTypeMap typeMap
;

nonterminal <syntax>
  ?! @syntaxMap syntaxMap
  ?! @varMap fieldMap 
  ?! @uint internalSyntaxId
;

#instCycle (without any pipeline)
nonterminal  <instCycle>
  ?! @uint internalInstCycleId
  ?? @componentMap componentMap
  ?! @instCycleMap instCycleMap
;
nonterminal  <timing>
  ?? @varMap globalVarMap
  ?! @uint internalInstCycleId
  ?? @componentMap componentMap
  ?! @timingMap timingMap
;

#example: 
# in model1, model2 { ...
# in * except model1, model2 {
# in model1, model2 except model1 -> model1 is not allowed...
# => in * except model1 <=> all models, but not model1.
rule <inModel>
  ?? @lstring modelName
  !  @bool isInModel
:
  $in$;
  isInModel := false;
  repeat
    select
      @lstring isInModelName;
      $idf$ ?isInModelName; 
      isInModel := isInModel | ([isInModelName string] == [modelName string]);
    or
      $*$; #joker.
      isInModel := true;
    end select;
  while
    $,$;
  end repeat;
  select
  or
    $except$;
    repeat
      @lstring isInModelName;
      $idf$ ?isInModelName; 
      #isInModel becomes false if modelName is in the except list.
      isInModel := isInModel & not ([isInModelName string] == [modelName string]);
    while
      $,$;
    end repeat;
  end select;
  ${$;
end rule;

rule <includeFile>
  ?! @defaultSection defaultValues
  ?! @varMap globalVarMap
  ?! @componentMap componentMap
  ?! @behaviorPrototypeMap behaviorPrototypeMap
  ?? @lstring modelName
#  ?! @branchTargetBufferList branchTargetBufferList
#  ?! @fifoList fifoList
:
  $include$ ;
  @lstring file_name ;
  $caracterStr$ ?file_name ;
  grammar gadl_grammar_include in file_name !?defaultValues !?globalVarMap !?componentMap !?behaviorPrototypeMap !modelName;# !?branchTargetBufferList !?fifoList;
label secondPass
  ?! @defaultSection defaultValues
  ?! @machineMap machineMap
  ?! @pipelineMap pipelineMap
  ?! @architectureMap archMap
  ?! @behaviorMap behaviorMap
  ?? @varMap globalVarMap
  ?! @behaviorPrototypeMap behaviorPrototypeMap
  ?! @formatMap formatMap
  ?? @componentMap componentMap
  ?! @varMap fieldMap
  ?! @syntaxMap syntaxMap
  ?! @instCycleMap instCycleMap
  ?! @printNumberTypeMap typeMap
  ?? @lstring modelName
  ?! @uint internalFormatId
  ?! @uint internalBehaviorId
  ?! @uint internalSyntaxId
  ?! @uint internalInstCycleId
  ?! @timingMap timingMap
:
  $include$ ;
  @lstring file_name ;
  $caracterStr$ ?file_name ;
  grammar gadl_grammar_include label secondPass in file_name
          !? defaultValues
          !?machineMap   !?pipelineMap
          !?archMap             !?behaviorMap  !globalVarMap
          !?behaviorPrototypeMap !? formatMap   !componentMap
          !?fieldMap            !?syntaxMap    !?instCycleMap !? typeMap
          !modelName !?internalFormatId !?internalBehaviorId
          !? internalSyntaxId !? internalInstCycleId !?timingMap;
end rule;

#################################################
#   main model. This is the start symbol for one model.
#
#   first pass:
#     parse components -> fill component map.
#     get behavior prototypes.
#     get defaults instruction size, and endianness
#
#   second pass:
#     all the other things :)
# end foreach
#################################################
rule <mainModel>
  ?! @defaultSection defaultValues
  ?! @varMap globalVarMap
  ?! @componentMap componentMap
  ?! @behaviorPrototypeMap behaviorPrototypeMap
  ?? @lstring modelName
:
  @uint nbCyclicParts := 0;
  repeat
  while
    @bool isInModelComponent;
    <inModel> !modelName ?isInModelComponent;
    parse
    when isInModelComponent:
      <mainModel> !?defaultValues !?globalVarMap
                  !?componentMap  !?behaviorPrototypeMap
                  !modelName;# !?branchTargetBufferList !?fifoList;
    else <mainModel> parse;
    end parse;
    $}$;
  while
    <includeFile> !?defaultValues !?globalVarMap !?componentMap !?behaviorPrototypeMap !modelName;# !?branchTargetBufferList !?fifoList;
  while 
    <default> !?defaultValues;
  while
    <component> !?globalVarMap !?componentMap !?nbCyclicParts; #define memory registers
  while
    <pipeline> parse;
  while
    <machine> parse;
  while
    <architecture> parse;
  while
    <format> parse;
  while 
    <behavior> !globalVarMap !?behaviorPrototypeMap;
  while
    <syntax> parse;
  while
    <instCycle> parse;
  while
    <timing> parse;
  while 
    <printNumberType> parse;
  end repeat;
label secondPass
  ?! @defaultSection defaultValues
  ?! @machineMap machineMap
  ?! @pipelineMap pipelineMap
  ?! @architectureMap archMap
  ?! @behaviorMap behaviorMap
  ?? @varMap globalVarMap
  ?! @behaviorPrototypeMap behaviorPrototypeMap
  ?! @formatMap formatMap
  ?? @componentMap componentMap
  ?! @varMap fieldMap
  ?! @syntaxMap syntaxMap
  ?! @instCycleMap instCycleMap
  ?! @printNumberTypeMap typeMap
  ?? @lstring modelName
  ?! @uint internalFormatId
  ?! @uint internalBehaviorId
  ?! @uint internalSyntaxId
  ?! @uint internalInstCycleId
  ?! @timingMap timingMap
:
  #the error detection of instruction size should not 
  #be in the <default> terminal... because default part
  #could be forgotten in description :-/
  if [[defaultValues instructionSize] uint] == 0 then 
    error here: "no default instruction size specified! ";
  end if;
  #component map is filled and must not be modified again.
  repeat
  while
    @bool isInModelComponent;
    <inModel> !modelName ?isInModelComponent;
    parse
    when isInModelComponent:
      <mainModel> secondPass
                  !? defaultValues
                  !?machineMap   !?pipelineMap
                  !?archMap             !?behaviorMap  !globalVarMap
                  !?behaviorPrototypeMap !? formatMap   !componentMap
                  !?fieldMap            !?syntaxMap    !?instCycleMap !? typeMap
                  !modelName !?internalFormatId !?internalBehaviorId
                  !? internalSyntaxId !? internalInstCycleId !?timingMap;
    else <mainModel> parse;
    end parse;
    $}$;
  while
    <includeFile> secondPass
                  !? defaultValues
                  !?machineMap   !?pipelineMap
                  !?archMap             !?behaviorMap  !globalVarMap
                  !?behaviorPrototypeMap !? formatMap   !componentMap
                  !?fieldMap            !?syntaxMap    !?instCycleMap !? typeMap
                  !modelName !?internalFormatId !?internalBehaviorId
                  !? internalSyntaxId !? internalInstCycleId !?timingMap;
  while 
    <default> secondPass !?defaultValues !componentMap;
  while
    <component> parse;
  while
    <pipeline> !archMap !?pipelineMap;
  while
    <machine> !componentMap !?machineMap !pipelineMap;
  while
    <architecture> !?archMap !componentMap;
  while
    <format> ![defaultValues instructionSize] !?formatMap !?internalFormatId; 
  while
     <behavior> secondPass !? behaviorMap !globalVarMap !componentMap !?behaviorPrototypeMap !?internalBehaviorId;
  while
     <syntax> !?syntaxMap !?fieldMap !?internalSyntaxId;
  while
     <instCycle> !?internalInstCycleId !componentMap !?instCycleMap;
  while
     <timing> !globalVarMap !?internalInstCycleId !componentMap !?timingMap;
  while 
     <printNumberType> !?typeMap;
  end repeat;
end rule;

function getModelNameList
  ?? @lstringlist modelNameListInit
  -> @lstringlist modelNameList
:
  @string modelNameOption := [option gadl_options.modelName value];
  if modelNameOption != "" then
    modelNameList := [@lstringlist emptyList];
    #a model is defined in the option.
    #search the model in the list.
    @bool found := false;
    foreach modelNameListInit (@lstring modelName) do
      if modelNameOption == [modelName string] then 
        found := true;
      end if;
    end foreach;
    #empty the list, as we use the one in argument.
    if found then
      #The list contains only the model in parameter.
      modelNameList += ![@lstring new !modelNameOption !here];
    else
      #generate an error. 
      error here: "the model in argument list (".modelNameOption.") is not defined in the description";
    end if;
  else
    modelNameList := modelNameListInit;
  end if;
end function;

# Start symbol.
# It searches for models defined, and 
# parse mainModel 2 times for each model.
rule <start_symbol> :
  @lstringlist modelNameListDef [emptyList];
  $model$; 
  repeat
    @lstring modelName;
    $idf$ ?modelName; 
    modelNameListDef += !modelName;
  while
    $,$;
  end repeat;
  ${$; 
  @lstringlist modelNameList := getModelNameList[!modelNameListDef];
  #generate a simulator for each model.
  parse loop [modelNameList length]
  while [modelNameList length] > 0 do
    #get current model name.
    @lstring modelName;
    [!?modelNameList popFirst ?modelName];
    #test fields.
    @varMap globalVarMap [emptyMap];
    @behaviorMap behaviorMap [emptyMap];
    @componentMap componentMap := [@componentMap emptyMap];
    @behaviorPrototypeMap behaviorPrototypeMap := [@behaviorPrototypeMap  emptyMap];
    @formatMap formatMap := [@formatMap emptyMap];
    @printNumberTypeMap typeMap := [@printNumberTypeMap emptyMap];
    @syntaxMap syntaxMap := [@syntaxMap emptyMap];
    @instCycleMap instCycleMap [emptyMap];
    @varMap fieldMap := [@varMap emptyMap];
    @timingMap timingMap [emptyMap];

    #micro-architecture dependant stuff.
    @architectureMap archMap := [@architectureMap emptyMap];
    @pipelineMap pipelineMap := [@pipelineMap emptyMap];
    @machineMap machineMap := [@machineMap emptyMap];

    @lstring emptyLString := [@lstring new !"" !here];
    @luint emptyLUint := [@luint new !0 !here];
    @defaultSection defaultValues := [@defaultSection new !emptyLUint !false !emptyLString 
                                    !emptyLString !emptyLString !emptyLString 
                                    !emptyLString !emptyLString !emptyLString
                                    !emptyLString !emptyLString];

    @TfieldMap templateStruct := [@TfieldMap emptyMap];

    #internal format node id. Start from 0 and is incremented each time an internal node is generated
    @uint internalFormatId := 0;
    @uint internalBehaviorId := 0;
    @uint internalSyntaxId := 0;
    @uint internalInstCycleId := 0;
    #first pass: 
    #  * get behavior prototypes.
    #  * all for components (including memory)
    parse do 
      <mainModel> !?defaultValues !?globalVarMap
                  !?componentMap  !?behaviorPrototypeMap
                  !modelName;# !?branchTargetBufferList !?fifoList;
    #second pass. The rest ;-)
    rewind
      <mainModel> secondPass
                  !?defaultValues
                  !?machineMap   !?pipelineMap
                  !?archMap             !?behaviorMap  !globalVarMap
                  !?behaviorPrototypeMap !? formatMap   !componentMap
                  !?fieldMap            !?syntaxMap    !? instCycleMap !? typeMap
                  !modelName !?internalFormatId !?internalBehaviorId
                  !?internalSyntaxId !? internalInstCycleId !?timingMap;
    end parse;
    $}$;
  
    #MODELNAME, DATE, HEADER_C, INST_DEFAULT_C_SIZE, IS_BIG_ENDIAN, DEBUG_COMPONENT, HOST_COMPILATION_64_BITS
    initTemplateWithDefaults !?templateStruct !modelName !defaultValues;    
        
    #program counter size. 
    #keys: PC_SIZE_IN_BITS, PC_SIZE_IN_BYTES, PC_C_TYPE are added by the memory component, according to 
    #      the program counter defined in description... but this is not the case if the behavior is not used
    #      In that case, we use a 32 bits program counter:
    #a program counter should be defined (and only one).
    #exception, if the noBehavior option is used, the model can have no PC.
    programCounterAccess !?templateStruct !globalVarMap ;

    
    ##########################################################################################
    # format
    ##########################################################################################
    @instructionImplementationMap impMap;
    instructionFormatPart ![modelName string] !defaultValues !?templateStruct !formatMap ?impMap; 
    generateInstConstructorAndDef !?templateStruct !impMap !formatMap;  

    ##########################################################################################
    # behavior
    ##########################################################################################
    @decodedInstBehaviorMap decodedInstBehaviorMap := instructionBehaviorPart[!behaviorMap !modelName !impMap];
    generateInstructionBehaviorImplementation !behaviorPrototypeMap !?templateStruct !impMap !decodedInstBehaviorMap; 
    @instructionListMap instListMap := getInstructionListMap[!decodedInstBehaviorMap !behaviorPrototypeMap];

    ##########################################################################################
    #syntax.
    ##########################################################################################
    instructionSyntaxPart !modelName !syntaxMap !impMap !?templateStruct !typeMap;

    ##########################################################################################
    # components
    ##########################################################################################
    #write component generated code.
    generateComponentImplementationFiles !?templateStruct !?componentMap;

    ##########################################################################################
    # branch detection (instruction that updates the program counter.
    ##########################################################################################
    @branchInstMap branchInstMap := getBranchInstructions[!componentMap !instListMap];
    updateTemplateForJumpInstructions !branchInstMap !?templateStruct;

    ##########################################################################################
    #temporal new approach with micro-architecture.
    # This part handles only the pipeline, excluding stuff related to mem hierarchy 
    # (signals and timings), even if signals are defined in the architure part.
    ##########################################################################################
    microArchPart !instListMap !defaultValues !modelName
                  !impMap !globalVarMap !componentMap
                  !machineMap !pipelineMap !archMap
                  !?templateStruct;
  
    ##########################################################################################
    #instCycles 
    ##########################################################################################
    instCyclePart !decodedInstBehaviorMap !impMap !instCycleMap !?templateStruct;

    ##########################################################################################
    #peripherals 
    ##########################################################################################
    peripheralsPart !?templateStruct !componentMap ! globalVarMap;

    ##########################################################################################
    #timing part (timed automata related to memory hierarchy).
    ##########################################################################################
    timingPart !?templateStruct !timingMap !modelName;
    signalCheckPart !archMap !timingMap;

    ##########################################################################################
    # template generation
    ##########################################################################################
    prepareLogTemplates !impMap !defaultValues !?templateStruct;
    @string gadlLog := computeTemplate[!"" !templateStruct !"root"];
    if [option gadl_options.templateLogFile value] then
      extractTemplateStructure !templateStruct !"templateLog.xml";
    end if;

    ##########################################################################################
    # filewrappers: add binary files inside the gadl compiler.
    ##########################################################################################
    addFileWrappers !modelName;
  end parse;
end rule ;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
