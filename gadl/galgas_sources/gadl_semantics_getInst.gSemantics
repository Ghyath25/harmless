semantics gadl_semantics_getInst:
  import "gadl_options.gOption" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_GetExp.gSemantics" ;

#in this file, 
# functions:
# * getInst -> convert a list of @ASTInstruction to a list of @instruction.
#           -> performs all required checks
# * checkNoReturn ?? @instructionList instList -> verification.
# * checkNoTypeDef?? @instructionList instList -> verification.
# routines
# getInst -> the same as the function, but get back the idfStruct also.

# readers:
# * @ASTInstruction getInst -> used by 'getInst' function.

routine getInst
  ?? @ASTInstructionList ASTInstList
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instructionList instList
:
  #check correct use of 'return'
  @symbolValueMap symbolMapCopy := symbolMap;
  instList := [@instructionList emptyList];
  foreach ASTInstList (@ASTInstruction ASTinst) do
    @instruction inst;
    [ASTinst getInst !ctx !?symbolMapCopy !?idfStruct ?inst];
    instList += !inst;
  end foreach;

  #check that there is no return statement (except last instruction).
  if [instList length] > 1 then
    @instructionList instListTmp := instList; #get a copy
    [!?instListTmp popLast ?*];               #remove last instruction.
    checkNoReturn !instListTmp;               #and check for no return inst.
  end if;
  #log idfStructcopy;
end routine;

function getInst
  ?? @ASTInstructionList ASTInstList
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @instructionList instList
:
  @varIdfStruct idfStructcopy := idfStruct;  
  getInst !ASTInstList !ctx !symbolMap !?idfStructcopy ?instList;
end function;

abstract method @ASTInstruction getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
;

override method @ASTInstIf getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #check that condition is a boolean.
  #condition
  @expression newCond := [cond getExp !ctx !symbolMap !idfStruct];
  [[newCond type] checkBool];

  @instructionList instIfList   := getInst[!ASTifList !ctx !symbolMap !idfStruct];
  @instructionList instElseList := getInst[!ASTelseList !ctx !symbolMap !idfStruct];

  checkNoReturn !instIfList;
  checkNoReturn !instElseList;

  inst := [@instIf new !loc !newCond !instIfList !instElseList];
  #TODO: merge symbolMap
end method;

override method @ASTInstReturn getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  @expression newExp := [exp getExp !ctx !symbolMap !idfStruct];
  inst := [@instReturn new !loc !newExp];
end method;

override method @ASTInstNop getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  @expression newExp := [exp getExp !ctx !symbolMap !idfStruct];
  inst := [@instNop new !loc !ctx !newExp];
end method;

override method @ASTInstLoop getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #check that there is no return instruction.
  @expression newGuard := [guard getExp !ctx !symbolMap !idfStruct];
  @expression newExpCondition := [expCondition getExp !ctx !symbolMap !idfStruct];
  @instructionList newLoopInstList := getInst[!loopInstList !ctx !symbolMap !idfStruct];
  checkNoReturn !newLoopInstList;

  inst := [@instLoop new !loc !newGuard !newExpCondition !newLoopInstList];
end method;

override method @ASTInstError getInst
  ?? @expressionContext unused ctx
  ?! @symbolValueMap unused symbolMap
  ?! @varIdfStruct unused idfStruct
  !  @instruction inst
:
  inst := [@instError new !loc !onlyWarn !msg];
end method;

override method @ASTInstPrint getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  @expression newExp := [exp getExp !ctx !symbolMap !idfStruct];
  inst := [@instPrint new !loc !newExp];
end method;

override method @ASTInstMessage getInst
  ?? @expressionContext unused ctx
  ?! @symbolValueMap unused symbolMap
  ?! @varIdfStruct unused idfStruct
  !  @instruction inst
:
  inst := [@instMessage new !loc !msg];
end method;

override method @ASTInstFunctionCall getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #Check that expression is effectively a function call TODO.
  #Check types of arguments TODO.
  @expression newIdf := [idf getExp !ctx !symbolMap !idfStruct];
  if not (newIdf is == @expIdf) then
    error loc:"internal error. Treated as function call but this is not a function call.";
  end if;
  @expIdf expIdf := (cast newIdf : @expIdf);
  switch [expIdf detectedType]
  when unknown:
    error loc: "The identifier is unknown";
  when structMember,localVar,tabularAccess,registerAccess,registerBitField:
    error loc: "This is not a function call, but it was excepted here.";
  when componentCall,memoryAccess:
    #checkCorrectAssignType ![expIdf type] !newExp ![expIdf lstring];
  end switch;
  inst := [@instFunctionCall new !loc !expIdf];
end method;

override method @ASTInstAssignment getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #check that variable idf is not a constant value.
  #check that variable idf is an idf (not a function call).
  #check that value asigned is not of type 'void' (in case of scalar).
  #check that left operand is an idf expression.
  #check for type compatibility (cannot assign a tabular to a scalar..) TODO
  @expression newIdf := [idf getExp !ctx !symbolMap !idfStruct];
  @expression newExp := [exp getExp !ctx !symbolMap !idfStruct];
  
  cast [newExp type]
  when == @varBaseType vbt : #basic type.
    if [vbt size] == 0 then
      error loc: "The expression in assignment returns void";
    end if;
  else
  end cast;

  if not (newIdf is == @expIdf) then
    error loc:"the left expression in assignment does not refer to an identifier.";
  end if;
  @expIdf expIdf := (cast newIdf : @expIdf);
  #TODO: checkCorrectAssignType
  switch [expIdf detectedType]
  when unknown:
    error loc: "The identifier is unknown";
  when structMember,localVar,tabularAccess,registerAccess,registerBitField:
    if [expIdf isConst] then
      @string errorStr := "Variable \'".[expIdf string]."\' is declared constant. It should not be assigned.";
      error loc: errorStr;
    end if;
    checkCorrectAssignType ![expIdf type] !newExp ![expIdf lstring];
  when componentCall,memoryAccess:
    error loc: "Cannot assign a function call or a memory access";
  end switch;
  #get the intruction.
  @fieldList flist := fieldListFromAST[!ctx !symbolMap !idfStruct !astFList];  
  inst := [@instAssignment new !loc !expIdf !flist !newExp];
end method;

override method @ASTInstDeclaration getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap unused symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #check that var was not declared previously.
  #check that types has size > 0 bits
  #check that size < 128 bits.
  #check that types exists.
  #check that we have the right to do that. TODO

  cast type
  when == @varBaseType vbt : #basic type.
    if [vbt size] == 0 then
      error loc: "The variable has a 0-bit size.";
    elsif [vbt size] > 128 then
      error loc: "Cannot handle variables greater than 128 bits.";
    end if;
  else
    #exists.
    checkTypeExists !type !idfStruct;
  end cast;
  #next depends of the type of data.
  switch access
  when localVar:
    #name of the var, using the suffix
    @lstring idfFull := [idfStruct getIdfPrePost !idf];
    #message "declare local var   ".idfFull."\n";
    @instDeclaration instDec := [@instDeclaration new !loc !type !idfFull !access !idfStruct->idfPrefixLocal];
    [!?idfStruct->varMap insertKey !idfFull !type !false !access !instDec];
    inst := instDec;
  when field: #a field used in the behavior view (ISA description).
    if ctx != [@expressionContext behavior] then
      error loc: "internal error in @ASTInstDeclaration. Have a 'field', but context is not behavior";
    end if;
    if not (type is >= @varBaseType) then
      error loc: "A 'field' can only be associated with a basic type (unsigned/signed/float)";
    end if;
    #a constant, without any prefix.
    @lstring idfField := [idfStruct getIdfPost !idf];
    #message "declare field       ".idfField."\n";
    @instDeclaration instDec := [@instDeclaration new !loc !type !idfField !access !""];
    [!?idfStruct->varMap insertKey !idfField !type !true ![@varClass localVar] !instDec];
    inst := instDec;
  when programCounter,GPR,SFR:
    @instDeclaration instDec := [@instDeclaration new !loc !type !idf !access !""];
    [!?idfStruct->varMap insertKey !idf !type !false !access !instDec];
    inst := instDec;
  when device:
    message "TODO: method @ASTInstDeclaration getInst with device";
    inst := [@instDeclaration new !loc !type !idf !access !""];
  when registerSlice:    
    error loc: "internal error in @ASTInstDeclaration should not be use in this ".
               "context -> @ASTInstDeclarationRegSlice" :inst;
  end switch;
end method;

override method @ASTInstDeclarationRegSlice getInst
  ?? @expressionContext ctx
  ?! @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #check that var was not declared previously.
  #check that types has size > 0 bits
  #check that size < reg size bits.
  #check that types exists.
  #check that we have the right to do that. TODO
  @fieldList flist := fieldListFromAST[!ctx !symbolMap !idfStruct !ASTfieldList];
  @varBaseType sliceType := [@varBaseType new ![@varKind unsigned] ![flist fieldsize !symbolMap] ![sliceName location]];
  #base register should be a varBaseType
  @varBaseType regType := (cast type : @varBaseType);
  if [regType size] < [sliceType size] then
    error sliceName: "The slice size is bigger than its base register.";
  end if;
  if access != [@varClass registerSlice] then
    error sliceName: "internal error: a registerSlice is expected in @ASTInstDeclarationRegSlice";
  end if;
  @instDeclarationRegSlice instRegSlice := [@instDeclarationRegSlice new !loc !type !idf !access !"" !sliceName !flist];
  [!?idfStruct->varMap insertKey ![instRegSlice name] !sliceType !false !access !instRegSlice];
  inst := instRegSlice;
end method;

override method @ASTInstTypeDefinition getInst
  ?? @expressionContext unused ctx
  ?! @symbolValueMap unused symbolMap
  ?! @varIdfStruct idfStruct
  !  @instruction inst
:
  #check that it does not exists yet.
  #check recursively that types in members exists.
  inst := [@instTypeDefinition new !loc !idf !memberList];
  #check recursively.
  foreach memberList (* @varAbstractType memberType) do
    checkTypeExists !memberType !idfStruct;
  end foreach;  
  #insert AFTER check to prevent recursion.
  [!?idfStruct->typedefMap insertKey !idf !memberList];
end method;

routine checkNoReturn
  ??  @instructionList instList
:
  foreach instList(@instruction inst) do
    cast inst
    when == @instReturn :
      error [inst loc]: "The return statement is not awaited here. It should be the last instruction ".
                        "and should not be set inside a block (if/loop)";
    else #ok
    end cast;
  end foreach;
end routine;

routine checkNoTypeDef
  ??  @instructionList instList
:
  foreach instList(@instruction inst) do
    cast inst
    when == @instTypeDefinition :
      error [inst loc]: "The type definition".
                        "and should not be set inside a block (if/loop)";
    else #ok
    end cast;
  end foreach;
end routine;


end semantics;
# vim:ft=ggs:ts=2:sw=2
