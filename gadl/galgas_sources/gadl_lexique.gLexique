lexique gadl_lexique indexing in "INDEXING":

#style for Cocoa text editor.
style keywordsStyle -> "Keywords:" ;
style delimitersStyle -> "Delimiters:" ;
style identifierStyle -> "Identifier symbols:" ;
style numberStyle -> "Number constants:" ;
style stringStyle -> "String constants:" ;
style referenceStyle -> "reference:" ;
style binaryMaskStyle -> "binary mask:" ;
style varStyle -> "variable type:" ;
style commentStyle -> "Comments:" ;

#indexing (Cocoa text editor capability)
indexing formatDef  : "format definition";
indexing formatCall : "format call";

#--------------- comments -------------------------------
# They must be defined before delimitors!! 
# '-' is a delimitor.
$__comment__$ error message "a comment" style commentStyle ;
rule "--" :
  repeat #accept all except 0xA (LF) and 0xD (CR)
    while '\u0001'->'\u0009' | '\u000B'| '\u000C'| '\u000E' -> '\uFFFD' : 
  end repeat ;
  drop $__comment__$ ;
end rule ; 

#-------------a character string---------------------
#example: 'this is 1 character [string].'
#There may be any character between '"' (ascii 0x22).
#0xA (LF) and 0xD (CR) are ignored.
#The caracter String is sent to the parser without the '"' delimitors.

@string carStr;
$caracterStr$ ! carStr error message "a character string" style stringStyle;
message carStrnotTerminated : "character string not terminated!";
rule  '"' :
  repeat 
    while '\u0001'->'\u0009' | '\u000B'| '\u000C'| '\u000E' -> '\u0021' | '\u0023' -> '\uFFFD' : 

    enterCharacterIntoString !?carStr !* ;
    while '\u000A' | '\u000D': #ignore
  end repeat;
   
  select when '"' :
  default 
    error carStrnotTerminated;
  end select;

  send $caracterStr$;
end rule;

#-------------a binary mask---------------------
#example: \m'1011-0---'
#There may be only 1,0 and - characters between "'"
#The caracter String is sent to the parser without the "'" delimitors.
#TODO: check for max length.

@string binaryMaskStr ;   
$binaryMask$ ! binaryMaskStr error message "a binary mask" style binaryMaskStyle;
#message badBinaryMaskStr : "binary mask not well formed!";
rule "\\m":
  repeat
  while '0'->'1' :
   enterCharacterIntoString !?binaryMaskStr !* ;
  while  '-':
   enterCharacterIntoString !?binaryMaskStr !* ;
  while  '_':
   #nothing...
  end repeat ;
#   select when"'" :
#   default 
#    error badBinaryMaskStr;
#   end select;   
  send  $binaryMask$ ;
end rule;

#------------------Reference----------------------------
#exemple: #ref
#a reference begins with the # character.
#The # is removed from the string for the syntax parser.

@string refStr;
$reference$ ! refStr error message "a reference label" style referenceStyle;
rule  '#':
  repeat 
  while 'a'->'z' |'A'->'Z' | '_' | '0'->'9':
    enterCharacterIntoString !?refStr !* ;
  end repeat;
  send $reference$;
end rule;

#------------------ post Reference----------------------------
#exemple: formatToCall@src
#when calling a format, the @src means that in references that are used in 'formatToCall',
#the 'src' string will be append to the ref name.

@string postRefStr;
$postReference$ ! postRefStr error message "a post reference label" style referenceStyle;
rule  '@':
  repeat 
  while 'a'->'z' |'A'->'Z' | '_' | '0'->'9':
    enterCharacterIntoString !?postRefStr !* ;
  end repeat;
  send $postReference$;
end rule;
#--------------- Delimitors -----------------------------------

list delimitorsList error message "the '%K' delimitor" style delimitersStyle:
 ":","..",".",",","{",  "}","[","]",":=",
"(",")",
"!", "~",
"*","/", "%",
"+","-",
"<<",  ">>",
"<",">", "<=",  ">=", 
"=", "!=", 
"&", "^", "|", "&&", "^^", "||",
"->";
rule list delimitorsList ;

#--------------- Decimal-----------------------------------

@uint64 number;
@sint64 snumber;
#snumber is used only to check that the signed number is not too large. 
#but the unsigned value is always sent to the parser. 
$snumber$  ! number error message "a decimal signed number" style numberStyle;
$unumber$  ! number error message "a decimal unsigned number" style numberStyle;
message snumberTooLarge : "signed number too large (>2**63-1)";
message numberTooLarge : "unsigned number too large (>2**64-1)";
message charNotABinDigit : "the character is not a binary digit" ;
message charNotAOctDigit : "the character is not an ocal digit" ;
message charNotADecDigit : "the character is not a decimal digit" ;
message charNotAHexDigit : "the character is not a hexadecimal digit" ;
message numberTypeNotRecognized : "Type of number unknown";

#number can be \b10011, \d12983 or \xAF48c, or signed numbers postfixed by 's'.
# the '_' char can be added for lisibility (not taken into account): ex \b0001_1001_1001
rule '\\' :
  select 
  when 'b' | 'B': #binary number
    repeat
    while '0'->'1':
      enterBinDigitIntoUInt64 !* !?number
      error numberTooLarge, charNotABinDigit ;
    while '_':
      #nothing
    end repeat ; 
  when 'd' | 'D': #decimal number
    repeat
    while '0'->'9':
      enterDigitIntoUInt64 !* !?number
      error numberTooLarge, charNotADecDigit ;
    while '_':
      #nothing
    end repeat ; 
  when 'o' | 'O': #octal number
    repeat
    while '0'->'7':
      enterOctDigitIntoUInt64 !* !?number
      error numberTooLarge, charNotAOctDigit ;
    while '_':
      #nothing
    end repeat ; 
  when 'x' | 'X': #hex number
    repeat
    while '0'->'9' | 'a'->'f' | 'A' -> 'F':
      enterHexDigitIntoUInt64 !* !?number
      error numberTooLarge, charNotAHexDigit ;
    while '_':
      #nothing
    end repeat ; 
  default 
    error numberTypeNotRecognized;
  end select;
  select 
  when 's' :
    convertUInt64ToSInt64 !number !?snumber error snumberTooLarge;
    send $snumber$;
  default
    send  $unumber$ ;
  end select;
end rule;

#number can be decimal: 193458
#TODO:update for '_' char.
rule '0'->'9' :
  enterDigitIntoUInt64 !* !?number
  error numberTooLarge, charNotADecDigit ;
  repeat
  while '0'->'9':
   enterDigitIntoUInt64 !* !?number
   error numberTooLarge, charNotADecDigit ;
   while '_': 
    #nothing
  end repeat ; 
  select 
  when "kb" :
    multiplyUInt64 !1024 !?number error numberTooLarge;
    send $unumber$;
  when "mb" : #1024*1024=1048576
    multiplyUInt64 !1048576 !?number error numberTooLarge;
    send $unumber$;
  when 's' :
    convertUInt64ToSInt64 !number !?snumber error snumberTooLarge;
    send $snumber$;
  default
    send  $unumber$ ;
  end select;
end rule;


#--------------- Keywords -----------------------------------
#
# NOTE: If a Keyword is added in this list, it also should be added 
# in the main.tex of the documentation file!
#
list keyWordList error message "the '%K' keyword" style keywordsStyle:
"model","except","include",                              #model
"port","device","architecture","write","shared",         #archi
"behavior","format","select",                            #ISS
"error","warning",                                       #error detection.
"component","void","every",                              #component
"interrupt",                                             #interrupt handling
"memory","space","width","type","RAM","ROM",           #memory
"register","stride","read","program","counter",
"pipeline","stage","machine",                            #pipeline
"bypass","release","in","maps","to","stall",
"default","fetch","debug",                               #global
"big","little","endian",                                 #global (endianness)
"typedef",                                               # structured types.
                                                         # 'in' expression.
"do","out","when","field","nop","on",                    #behavior
"slice","case","is","others",                            #format
"signed","or",
"syntax","switch","number","octal","decimal",            #syntax
"hexadecimal","binary","suffix","prefix",          
"jumpTaken","add","cycle","use",                         #cycles 
"timing","signal","emit","wait","for",                   #timing        
"broadcast","activation",                                #timing        
"return","print",                                        #implementation
"if","then","elseif","else","end",                       #conditional
"loop","while",                                          #loops 
"true","false","ror","rol","cat",                        #expression
"instruction","size","address",                          #expression
"core", "import","isa","from"                            #core
;
#-------------a variable .. and identifers (1/2).---------------------
# TODO: not terminated. u3f does not send an identifier for instance.
@string idStr ;
$idf$ ! idStr error message "an identifier" style identifierStyle;
# example u8, s32, u1 (<=>boolean).
@uint varSize;
$uvar$  ! varSize error message "an unsigned variable type" style varStyle;
rule 'u' :
  enterCharacterIntoString !?idStr !* ;
  select
  when '0'->'9' :
   repeat
    enterDigitIntoUInt !* !?varSize
    error numberTooLarge, charNotADecDigit ;
   while '0'->'9':
     end repeat ;
   send  $uvar$ ;
  default
   repeat
   while 'a'->'z' |'A'->'Z' | '_' | '0'->'9':
    enterCharacterIntoString !?idStr !* ;
   end repeat ; 
   send search idStr in keyWordList default $idf$ ;
  end select;
end rule;

$svar$  ! varSize error message "a signed variable type" style varStyle;
rule 's' :
  enterCharacterIntoString !?idStr !* ;
  select
  when '0'->'9' :
   repeat
    enterDigitIntoUInt !* !?varSize
    error numberTooLarge, charNotADecDigit ;
   while '0'->'9':
     end repeat ;
   send  $svar$ ;
  default
   repeat
   while 'a'->'z' |'A'->'Z' | '_' | '0'->'9':
    enterCharacterIntoString !?idStr !* ;
   end repeat ; 
   send search idStr in keyWordList default $idf$ ;
  end select;
end rule;

#------------------Identifiers (2/2) (see previous rule) -------------
rule 'a'->'z' |'A'->'Z'| '_':
   repeat
   enterCharacterIntoString !?idStr !* ;
   while 'a'->'z' |'A'->'Z' | '_' | '0'->'9':
   end repeat ; 
   send search idStr in keyWordList default $idf$ ;
end rule;

#--------------- spaces and escapes characters ----------
# The ';' is treated like a space
rule '\u0001'-> ' ' | ';':  
end rule ;


end lexique ;
# vim:ft=ggs:ts=2:sw=2
