semantics gadl_peripheral_templateExport:
  import "gadl_options.gOption" ;
  import "gadl_peripheral.gSemantics" ;
  import "gadl_semantics_implementation_code_generation.gSemantics" ;
  import "gadl_semantics_templateExport.gSemantics" ;

method @registerPeriphDefMap setInTemplate
  ?! @TfieldMap templateStruct
:
  @TfieldMapList registerPeriphDefTplList [emptyList];
  foreach selfcopy do
    @TfieldMap regPeriphDefTplBody [emptyMap];
    addLStringValue  !?regPeriphDefTplBody !"name"                  !lkey;
    addUnsignedValue !?regPeriphDefTplBody !lstringWith[!"address"] ![address uint64];
    if [readFuncCall string] != "" then
      addLStringValue  !?regPeriphDefTplBody !"readFunc"  !readFuncCall;
    end if;
    if [writeFuncCall string] != "" then
      addLStringValue  !?regPeriphDefTplBody !"writeFunc" !writeFuncCall;
    end if;
    addStringValue   !?regPeriphDefTplBody !lstringWith[!"type"]    ![[type getBaseType] getCType];
    registerPeriphDefTplList += !regPeriphDefTplBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"regList"] !registerPeriphDefTplList;
end method;

method @peripheralMap setInTemplate
  ?! @TfieldMap templateStruct
:
  @TfieldMapList peripheralList [emptyList];
  foreach selfcopy do
    @TfieldMap peripheralBody [emptyMap];
    #name
    addLStringValue !?peripheralBody !"name" !lkey;
    #memory size
    addUnsignedValue !?peripheralBody !lstringWith[!"memSize"] ![size uint64];
    #idfStruct related -> varMap only.
    [idfStruct setInTemplate !?peripheralBody];
    #methods
    addListValue !?peripheralBody !lstringWith[!"methodList"] ![functionMap getFunctionTemplate];
    #internal registers
    [registerPeriphDefMap setInTemplate !?peripheralBody];
    #devices.
    [instDeviceDecList setDeviceInTemplate !?peripheralBody];
    #typedef (type definitions)
    message "periph : ".[lkey string]."\n";
    foreach idfStruct->typedefMap do
      message "\t".[lkey string]."\n";
    end foreach;
    message [idfStruct->typedefMap generateCode !1 ![@codeCtx C]];
    peripheralList += !peripheralBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"peripheralList"] !peripheralList;
end method;


method @instructionList setDeviceInTemplate
  ?! @TfieldMap templateWithDev
:
  @TfieldMapList deviceDecListTpl [emptyList];
  foreach selfcopy do
    @TfieldMap deviceDecListTplBody [emptyMap];
    const @instDeclarationDevice instDevDec := (cast inst: @instDeclarationDevice);
    addLStringValue !?deviceDecListTplBody !"name" ![instDevDec name];
    addLStringValue !?deviceDecListTplBody !"memSpaceName"  ![[instDevDec address] memSpaceName];
    addLUnsignedValue !?deviceDecListTplBody !"baseAddress"  ![[instDevDec address] baseAddress];  
    @varDeviceType base := (cast [[instDevDec type] getFinalType] : @varDeviceType);
    addLStringValue !?deviceDecListTplBody !"type" ![base typeName];
    @uint nbDev := 1;
    if ([instDevDec type] is >= @varTabularType) then
      @varTabularType tabType := (cast [instDevDec type] : @varTabularType);
      #should not happen: not allowed by parser: double check!!
      if not ([tabType type] is == @varDeviceType) then
        error [base typeName]: "only the definition of a device, or a tab of devices is allowed here";
      end if;
      nbDev := [tabType length];
    end if;
    addUnsignedValue !?deviceDecListTplBody !lstringWith[!"nb"] ![nbDev uint64];
    #this information is also present in the IdfStruct, if any.
    addStringValue !?deviceDecListTplBody !lstringWith[!"declare"] ![inst generateCode !1 ![@codeCtx C]];
    deviceDecListTpl += !deviceDecListTplBody;
  end foreach;
  addListValue !?templateWithDev !lstringWith[!"deviceList"] !deviceDecListTpl;
end method;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
