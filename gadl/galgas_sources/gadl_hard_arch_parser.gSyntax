syntax gadl_hard_arch_parser ("gadl_lexique.gLexique") :

import "gadl_options.gOption" ;
import "gadl_semantics.gSemantics" ;
import "gadl_semantics_hard_arch.gSemantics" ;

rule <architecture>
  ?! @architectureMap archMap
  ?? @componentMap componentMap
:
  $architecture$;
  @lstring architectureName;
  $idf$ ?architectureName;
  ${$;
  @bool fetchFound := false;
  @deviceMap deviceMap [emptyMap];
  repeat
  while
    <device> !?deviceMap !componentMap !?fetchFound;
  end repeat;
  @signalConnectionList signalConnectionList;  
  @sharedPortActivationList sharedPortActivationList;
  select
    <signalSection> !deviceMap ?signalConnectionList ?sharedPortActivationList;
  or
    signalConnectionList := [@signalConnectionList emptyList];
    sharedPortActivationList := [@sharedPortActivationList emptyList];
  end select;
  $}$;
  if not fetchFound then
    error here : "\nThe port named : 'fetch', is not found\n";
  end if;
  @signalConnectPart signalConnectPart := [@signalConnectPart new !signalConnectionList !sharedPortActivationList];
  [!?archMap insertKey !architectureName !deviceMap !signalConnectPart];
end rule;

rule <device>
  ?! @deviceMap deviceMap
  ?? @componentMap componentMap
  ?! @bool fetchFound 
:
  @portMap  portMap [emptyMap];
  @aliasMap readAliasMap [emptyMap];
  @aliasMap writeAliasMap [emptyMap];
  $device$;
  @lstring deviceName;
  $idf$ ?deviceName;
  $:$;
  @lstring componentName;
  $idf$ ?componentName ;
  #TODO: verif inutile???
  if not [componentMap hasKey ![componentName string]] then
    error [componentName location]: "There is no component named :". componentName ."\n";
  end if;
  ${$;
  repeat
  while
    <aliasFunction> !?readAliasMap !?writeAliasMap !componentMap !componentName;
  while
    @bool isShared;
    select
      isShared := false;
    or
      $shared$;
      isShared := true;
    end select;
    $port$;
    @lstring portName;
    select 
      $fetch$;
      portName := [@lstring new !"fetch" !here];
      if fetchFound then
        error here: "The fetch port must be used only once.";
      end if;
      fetchFound := true;
    or
      $idf$ ?portName;
    end select;
    @functionAllowedToAPort functionAllowedToAPort;
    select
      #all functions allowed
      @luint nbOfPermission;
      select
        nbOfPermission := [@luint new !1 !here]; #default : 1 access.
      or
        <nbPermission> ?nbOfPermission;
      end select;
      functionAllowedToAPort := [@isAll new !nbOfPermission]; 
    or
      <functionAllowed> ?functionAllowedToAPort;
    end select;
    [!?portMap insertKey !portName !isShared !functionAllowedToAPort];
  end repeat;
  $}$;
  [!?deviceMap insertKey !deviceName !componentName !portMap !readAliasMap !writeAliasMap];
end rule;

rule <nbPermission>
  ! @luint nbOfPermission
:
  $($;
  @luint64 tmp;
  $unumber$ ?tmp;
  nbOfPermission := [@luint new ![[tmp uint64]uint] ![tmp location]];
  $)$;
end rule;

rule <readOrWrite>
  ! @lstring idf
:
  select
    $read$;
    idf := [@lstring new !"read" !here];
  or
    $write$;
    idf := [@lstring new !"write" !here];
  end select;
end rule;

rule <readOrWriteOrIdf>
  ! @lstring idf
:
  select
    $idf$ ?idf;
  or
    <readOrWrite> ?idf;
  end select;
end rule;

rule <readOrWriteOrFetchOrIdf>
  ! @lstring idf
:
  select
    $fetch$;
    idf := [@lstring new !"fetch" !here];
  or
    <readOrWriteOrIdf> ? idf;
  end select;
end rule;

rule <aliasFunction>
  ?! @aliasMap readAliasMap
  ?! @aliasMap writeAliasMap
  ?? @componentMap componentMap
  ?? @lstring componentName
:
  @bool isRead;
  select
    $read$;
    isRead := true;
  or
    $write$;
    isRead := false;
  end select;
  $is$;
  repeat
    @lstring methodName;
    $idf$ ?methodName;
    if isComponentMethodValid[!componentMap !componentName !methodName] then
      if isRead then
        [!?readAliasMap insertKey !methodName];
      else
        [!?writeAliasMap insertKey !methodName]; 
      end if;
    end if;
  while
    $|$;
  end repeat;
end rule;

#this rule allows to write ":x (2)" or ":x or y or z (2)" or ": except x,y,z".
rule <functionAllowed>
  ! @functionAllowedToAPort functionAllowedToAPort  
:
  $:$;
  select
    @lstring functionName;
    <readOrWriteOrIdf> ?functionName;
    select
      $($;
      @luint64 tmp;
      $unumber$ ?tmp;
      @luint nbOfPermission := [@luint new ![[tmp uint64]uint] ![tmp location]];
      $)$;
      functionAllowedToAPort := [@isWithNumber new !functionName !nbOfPermission];
    or
      $or$;
      @lstringlist functionAllowedList [emptyList];
      functionAllowedList += !functionName;
      repeat
        @lstring orFunctionAllowed;
        <readOrWriteOrIdf> ?orFunctionAllowed;
        functionAllowedList += !orFunctionAllowed;
      while
        $or$;
      end repeat;
      @luint nbOfPermission;
      select
        $($;
        @luint64 tmp;
        $unumber$ ?tmp;
        nbOfPermission := [@luint new ![[tmp uint64]uint] ![tmp location]];
        $)$;
      or
        nbOfPermission := [@luint new !1 !here];
      end select;
      functionAllowedToAPort := [@isOr new !functionAllowedList !nbOfPermission];
    or
      functionAllowedToAPort := [@isWithNumber new !functionName ![@luint new !1 !here]];
    end select;
  or
    $except$;
    @lstringlist functionExcludedList [emptyList];
    repeat
      @lstring functionName;
      <readOrWriteOrIdf> ?functionName;
      functionExcludedList += !functionName;
    while
      $,$;
    end repeat;
    functionAllowedToAPort := [@isExcept new !functionExcludedList];
  end select;
end rule;

################################################################################
# association of signals for timing sections.
################################################################################
rule <signalSection>
  ?? @deviceMap deviceMap
  !  @signalConnectionList signalConnectionList
  !  @sharedPortActivationList sharedPortActivationList
:
  sharedPortActivationList := [@sharedPortActivationList emptyList];
  signalConnectionList := [@signalConnectionList emptyList];
  $signal$; ${$;
  repeat
  while
    select
      <signalConnection> !?signalConnectionList;
    or
      <sharedPortConnection> !deviceMap !?sharedPortActivationList;
    end select;
  end repeat;
  $}$;
end rule;

rule <sharedPortConnection>
  ?? @deviceMap deviceMap
  ?! @sharedPortActivationList sharedPortActivationList
:
  @lstring deviceSrc;
  @lstring portSrc;
  @lstring deviceName;
  $shared$; $port$;
  $idf$ ?deviceSrc; $.$; 
  select
    $idf$ ?portSrc;
  or
    $fetch$; portSrc := [@lstring new !"fetch" !here];
  end select;
  #Check that port and devices are defined, and port is shared.
  @portMap portMap;
  @bool isShared;
  [deviceMap searchKey !deviceSrc ?* ?portMap ?* ?*];
  [portMap searchKey !portSrc ?isShared ?*];
  if not isShared then
    error here : "The port associated to a signal should be declared as \"shared\"";
  end if;
  $->$;
  $idf$ ?deviceName;
  sharedPortActivationList += !deviceSrc !portSrc !deviceName;
end rule;

rule <signalConnection>
  ?! @signalConnectionList signalConnectionList
:
  @lstring devNameSrc;
  @lstring devNameDst;
  @lstring sigNameSrc;
  @lstring sigNameDst;
  @bool noDst;
  $idf$ ?devNameSrc; $.$; $idf$ ?sigNameSrc;
  $->$;
  select
    $idf$ ?devNameDst; $.$; $idf$ ?sigNameDst;
    noDst := false;
  or
    devNameDst := [@lstring new !"" !here];
    sigNameDst := [@lstring new !"" !here];
    $*$;
    noDst := true;
  end select;
  signalConnectionList += !devNameSrc !devNameDst !sigNameSrc !sigNameDst !noDst;

end rule;

end syntax;
# vim:ft=ggs:ts=2:sw=2
