semantics gadl_semantics_components_extraction :
  import "gadl_semantics.gSemantics" ;  #@methodList
  import "gadl_semantics_behavior_data_structures.gSemantics"; #@decodedInstBehaviorMap
  import "gadl_components.gSemantics"; #getComponentMethodImplementationName
  import "gadl_semantics_behavior.gSemantics" ; #getInstructionList
  import "gadl_graph.gSemantics"; #@graphNode
  import "gadl_templates" ;#createFile
  

#############################################################################
## getting components inside an expression
#############################################################################
#default: not adding nodes.
method @expression getComponents 
  ?? @graphNodeList unused nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  rootNodeList := [@graphNodeList emptyList];
end method;

# * expDummy              -> nothing
# * expIntConst           -> nothing
# * expInstructionSize    -> nothing
# * expInstructionAddress -> nothing
# * expIdf                -> done -> here is the hard work!
# * expCast               -> done
# * expBitFieldOp         -> done
# * expUnary              -> done
# * expBinary             -> done

#@cIdf                    -> nothing.

#override method @cTabIndice  getComponents
#  ?? @graphNodeList nextNodeList # list of successors.
#  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
#:
#  [expIndice getComponents !nextNodeList ?rootNodeList];
#end method;

override method @expCast getComponents
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  [expCasted getComponents !nextNodeList ?rootNodeList];
end method;

override method @expBitFieldOp  getComponents
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  [expField getComponents !nextNodeList ?rootNodeList];
end method;

override method @expUnary  getComponents
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  [exp getComponents !nextNodeList ?rootNodeList];
end method;

#internal routine used by "getComponents" of @cExpression that
#handle 2 sub-expressions.
routine getComponentsIn2Expressions
  ?? @expression expRight
  ?? @expression expLeft
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  [expRight getComponents !nextNodeList ?rootNodeList];
  @graphNodeList currentNextNodeList := nextNodeList;
  if [rootNodeList length] > 0 then #there is a new root.
    currentNextNodeList := rootNodeList;
  end if;
  [expLeft getComponents !currentNextNodeList ?rootNodeList];
  if [rootNodeList length] == 0 then #nothing in the left part. return the right exp result.
    rootNodeList := currentNextNodeList;
  end if;
end routine;

override method @expBinary  getComponents
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  getComponentsIn2Expressions !expRight !expLeft !nextNodeList ?rootNodeList;
end method;

override method @expIdf getComponents
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  rootNodeList := [@graphNodeList emptyList];
  switch detectedType
    when unknown,registerAccess,registerBitField,localVar: #nothing.
    when structMember,tabularAccess: #maybe in parameter, or in the tab index.
      @graphNodeList currentNextNodeList := nextNodeList;
      foreach > idfList do
        foreach > paramList (@expression exp ...) do #foreach with reverse order.
          [exp getComponents !currentNextNodeList ?rootNodeList];
          if [rootNodeList length] > 0 then #there is a new root.
            currentNextNodeList := rootNodeList;
          end if;
        end foreach;
      end foreach;
      if [rootNodeList length] == 0 then #last chunk was not a root, get back the target.
        rootNodeList := currentNextNodeList;
      end if;
    when componentCall,memoryAccess:
      #parameters first.
      @graphNodeList currentNextNodeList := nextNodeList;
      foreach > idfList do      
        foreach > paramList (@expression exp ...) do #foreach with reverse order.
          [exp getComponents !currentNextNodeList ?rootNodeList];
          if [rootNodeList length] > 0 then #there is a new root.
            currentNextNodeList := rootNodeList;
          end if;
        end foreach;
      end foreach;
      #then component call.
      @lstringlist data [emptyList];
      foreach idfList do
        data += !idf;
      end foreach;
      rootNodeList := [@graphNodeList emptyList];
      @string uid := getGraphNodeUniqueId[![idfList string] !currentNextNodeList];
      rootNodeList += ![@graphNode new !data !currentNextNodeList !uid];
  end switch;
end method;

#############################################################################
## getting components inside instructions
#############################################################################

#default: not adding nodes.
method @instruction getComponents 
  ?? @graphNodeList unused nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  rootNodeList := [@graphNodeList emptyList];
end method;

override method @instFunctionCall getComponents ##this is the related instruction.
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  [exp getComponents !nextNodeList ?rootNodeList];
end method;

override method @instIf getComponents 
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  @graphNodeList IfNodeList   := [@graphNodeList emptyList];
  @graphNodeList ElseNodeList := [@graphNodeList emptyList];
  getComponentsInInstructionList !instIfList   !nextNodeList ?IfNodeList;
  getComponentsInInstructionList !instElseList !nextNodeList ?ElseNodeList;
  MergeGraphNodeList ?rootNodeList !IfNodeList !ElseNodeList;
#  rootNodeList := IfNodeList . ElseNodeList;
end method;

override method @instAssignment getComponents 
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  [exp getComponents !nextNodeList ?rootNodeList];
end method;

#recursive routine.
routine getComponentsInInstructionList
  ?? @instructionList instList   # the instruction list to process
  ?? @graphNodeList nextNodeList # list of successors.
  !  @graphNodeList rootNodeList # the root (may have 0, 1 or more nodes).
:
  rootNodeList := [@graphNodeList emptyList];
  @graphNodeList currentNextNodeList := nextNodeList;
  foreach > instList do #foreach with reverse order.
    [inst getComponents !currentNextNodeList ?rootNodeList];
    if [rootNodeList length] > 0 then #there is a new root.
      currentNextNodeList := rootNodeList;
    end if;
  end foreach;
  if [rootNodeList length] == 0 then #last chunk was not a root, get back the target.
    rootNodeList := currentNextNodeList;
  end if;
end routine;

#############################################################################
## extraction routines.
#############################################################################

routine getInstructionComponentGraph
  ?? @decodedBehaviorMap decodedBehaviorMap 
  ?? @defaultSection defaultValues #user fetch.
  !  @graphNodeMap componentAccessMap
:
  componentAccessMap := [@graphNodeMap emptyMap];
  foreach decodedBehaviorMap (@lstring instName * @instructionList instListConst *) do
    @instructionList instList := instListConst; #local copy.
    #we add the implicit fetch.
    @idfItemList idfList [emptyList];
    if not isThereAUserFetch[!defaultValues] then
      idfList += !lstringWith[!"__fetch_component"] ![@idfItemType basic] ![@expressionlist emptyList];
      idfList += !lstringWith[!"__implicit_fetch"] ![@idfItemType functionCall] ![@expressionlist emptyList];
    else
      idfList += ![defaultValues fetchComponentName] ![@idfItemType basic] ![@expressionlist emptyList];
      idfList += ![defaultValues fetchMethodName] ![@idfItemType functionCall] ![@expressionlist emptyList];
    end if;
    @varBaseType dummyType := [@varBaseType new ![@varKind unsigned] !0 !here];
    @expIdf idf := [@expIdf new !dummyType !idfList ![@idfType componentCall] !false !""];

    @instruction fetch := [@instFunctionCall new !here !idf];
    [!?instList insertAtIndex !fetch !0];
    #ok, done. Now, construct the graph.
    @graphNodeList nextNodeList [emptyList];
    @graphNodeList rootNodeList;
    getComponentsInInstructionList !instList !nextNodeList ?rootNodeList;
    @graphNode nodeRoot;
    #if there is more than 1 root:
    if [rootNodeList length] > 1 then
      @string uid := getGraphNodeUniqueId[!"root" !rootNodeList];
      nodeRoot := [@graphNode new ![@lstringlist emptyList] !rootNodeList !uid];
    elsif [rootNodeList length] == 1 then
      [rootNodeList first ?nodeRoot];
    else
      #empty node.
      @string uid := getGraphNodeUniqueId[!"root" !rootNodeList];
      nodeRoot := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList] !uid];
      #message "No root nodes found\n";
    end if;
    #Ok, got the graph in 'nodeRoot'. Store it.
    [!?componentAccessMap insertKey !instName !nodeRoot];
  end foreach;
end routine;

routine generateComponentAccessGraphViz
  ?? @graphNodeMap componentAccessMap
  ?? @string modelName
:
  foreach componentAccessMap (@lstring instName @graphNode nodeRoot) do
    #get the GraphViz output content.
    @string graphVizContent := graphNodeOutput[!nodeRoot ![instName string]];
    #message "create file for ".[instName string]." (".[[graphVizContent length] string].")\n";
    createFile !modelName."/log" ![instName string].".dot" !graphVizContent;
  end foreach;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
