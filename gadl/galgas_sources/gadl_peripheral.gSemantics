semantics gadl_peripheral :
  import "gadl_options.gOption" ;
  import "gadl_peripheral_AST.gSemantics" ;
  import "gadl_semantics_getInst.gSemantics" ; #getInst

map @registerPeriphDefMap
{
  @instructionList regDecList;
  @luint64 address;
  @lstring readFuncCall;
  @lstring writeFuncCall;
  @varBaseType type; #type of the register (u32, â€¦)
  insert insertKey error message "the '%K' peripheral register is already defined in %L" ; 
  search searchKey error message "the '%K' peripheral register is not defined" ;
  remove removeKey error message "the '%K' peripheral register is not defined. Can't remove it." ;
}

map @peripheralMap
{
  @luint64 size;
  @registerPeriphDefMap registerPeriphDefMap;
  @functionMap functionMap;
  @instructionList instDeviceDecList;
  @varIdfStruct idfStruct;

  insert insertKey error message "the '%K' peripheral is already defined in %L" ; 
  search searchKey error message "the '%K' peripheral is not defined" ;
  remove removeKey error message "the '%K' peripheral is not defined. Can't remove it." ;
}

method @ASTregisterPeriphDefMap getRegisterPeriphDefMap
  ?? @symbolValueMap symbolMap
  ?! @varIdfStruct idfStruct
  ?? @ASTFunctionMap ASTFunctionMap
  ?? @luint64 periphSize
  !  @registerPeriphDefMap registerPeriphDefMap
:
  @expressionContext ctx := [@expressionContext peripheral];
  registerPeriphDefMap := [@registerPeriphDefMap emptyMap];
  foreach selfcopy do
    #extract instruction declaration
    getInst !ASTregDecList !ctx !symbolMap !?idfStruct ?@instructionList regDecList;
    #check that type is a basic type.
    @varBaseType vbt := [type getBaseType];
    #check that mapping is possible: map+size of reg <= peripheral mem size.
    if [[address uint64] uint] + ([vbt size]/8) > [[periphSize uint64] uint] then
      error address:"The peripheral memory size is not large enough to map this register.";
    end if;
    #check that the Function call are defined.
    if [readFuncCall string] != "" then
      [ASTFunctionMap searchKey !readFuncCall ?@parameterDefList param ?@varAbstractType outType ?*];
      #no parameter for read.
      @parameterDefList paramExpected [emptyList];
      if not [param checkEqual !paramExpected ![readFuncCall location]] then
        error [readFuncCall location] : "The 'read' callback does not have correct parameters";
      end if;
      #check return type.
      if not [outType isVoid] then
        error [readFuncCall location] : "The 'read' should not return any value";
      end if;
    end if;
    if [writeFuncCall string] != "" then
      [ASTFunctionMap searchKey !writeFuncCall ?@parameterDefList param ?@varAbstractType outType ?*];
      #param: only 1 parameter, same type as the register size.
      @parameterDefList paramExpected [emptyList];
      paramExpected += !false !vbt ![@lstring new !"data" !here];
      if not [param checkEqual !paramExpected ![writeFuncCall location]] then
        error [writeFuncCall location] : "The 'write' callback does not have correct parameters";
      end if;
      #check return type.
      if not [outType isVoid] then
        error [writeFuncCall location] : "The 'write' should not return any value";
      end if;
    end if;
    #insert in map.
    [!?registerPeriphDefMap insertKey !lkey !regDecList !address !readFuncCall !writeFuncCall !vbt];
  end foreach;
end method;

reader @ASTperipheralMap getPeriphMap
  ->  @peripheralMap peripheralMap
:
  peripheralMap := [@peripheralMap emptyMap];
  @expressionContext ctx := [@expressionContext peripheral];

  foreach selfcopy do
    @varIdfStruct idfStruct [default];
    idfStruct->currentPeriphMethods := ASTFunctionMap; #methods defined for the current function.
    @symbolValueMap symbolMap [emptyMap];
    @registerPeriphDefMap registerPeriphDefMap;
    [ASTregisterPeriphDef getRegisterPeriphDefMap !symbolMap !?idfStruct !ASTFunctionMap !size ?registerPeriphDefMap];
    getInst !ASTDeviceDecList !ctx !symbolMap !?idfStruct ?@instructionList instDeviceDecList;
    #message "\nIdfStruct\n".[idfStruct string];
    @functionMap functionMap := [ASTFunctionMap getFunctionMap !ctx !idfStruct]; 
    [!?peripheralMap insertKey !lkey !size !registerPeriphDefMap !functionMap !instDeviceDecList !idfStruct];
    #tmp
    foreach instDeviceDecList do
      message "-> ".[inst generateCode !1 ![@codeCtx C]]."\n";
    end foreach;
  end foreach;
end reader;



end semantics ;
# vim:ft=ggs:ts=2:sw=2
