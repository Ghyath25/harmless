semantics gadl_varIdfStruct :
  import "gadl_options.gOption" ;
  import "gadl_variable.gSemantics" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_instruction.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  
##
#modifier @lstring cat
##return the idf with the prefix and suffix.
# define struct @varIdfStruct that embedds all the required information to 
#        handle idf in both exp/inst.
#
# -> reader @varIdfStruct getIdfPrePost
# -> reader @varIdfStruct getIdfPost
# -> reader @varIdfStruct string
#
# -> reader @varIdfStruct getReplacedIdf

# -> routine checkTypeExists

#utils..
modifier @lstring cat
  ?? @string str
:
  @lstring result := [@lstring new ![selfcopy string].str ![selfcopy location]];
  self := result;
end modifier;

map @lstringMap
{
  @lstring lstr;
  insert insertKey error message "the '%K' component is already defined in %L" ; 
  search searchKey error message "the '%K' component is not defined" ;
  remove removeKey error message "the '%K' component is not defined and cannot be removed." ;
}

#structure that store information that can be accessed
#inside an expression (through idf)

#*****************************************************************************
#* structure that store information that can be accessed
#* inside an expression (through idf)
#*****************************************************************************
#When an idf is found in an expression (in the GetExp reader)
#it searches for an entry in one of the members of this structure.
#in the order defined in the structure.
struct @varIdfStruct {
  @varMap varMap; #local vars as well as registers.
  @typedefMap typedefMap; #type defined.
  @string idfSuffixName; #TODO: one suffix for fields, one for other behaviors, 
  @string idfprefix;     #used for idf names (in behaviors for instance), when inlining code.
  @string idfPrefixCore; #prefix to access a core (components, mem,..)
  @string idfPrefixLocal; #prefix for local vars only (to prevent same names when inlining).TODO remove.
  @componentMap componentMap;
  @ASTFunctionMap currentPeriphMethods; #to get prototypes of methods defined in the current periph.
  #if an idf is in this map, it should be replaced in the code. This is used
  #when inlining a function with a 'out' parameter.
  @lstringMap replaceMap;
  @memSpaceMap memSpaceMap; #memory space (not defined in isa).
}

reader @varIdfStruct string
  -> @string str
:
  str := "varMap ".[varMap string]."\n";
  str .= "prefix ".idfprefix."\n";
  str .= "suffix ".idfSuffixName."\n";
  #str .= "componentMap ".[componentMap string]."\n"; #TODO
  foreach componentMap 
  before str .= "componentMap:\n";  
  do
    str.= "\t".[lkey string].":\n";
    foreach methodMap do
      str.= "\t\t".[lkey string]."\n";
    end foreach;
  end foreach;

  foreach replaceMap 
  before str .= "replaceMap:\n";  
  do str .= "\t".[lkey string]." -> ".[lstr string]."\n";
  end foreach;

  foreach memSpaceMap 
  before str .= "mem space map :\n";  
  do
    str.= "\t".[lkey string].", width ".[width string]." bits:\n";
    foreach methodMap do
      str.= "\t\t".[lkey string]."\n";
    end foreach;
    if isProgram then str .= "\t\tmem space to get the program code\n";
    end if;
  end foreach;
end reader;

#return the idf with the prefix and suffix.
reader @varIdfStruct getIdfPrePost
  ?? @lstring idf
  -> @lstring idfFull
:
  @string str := "";
  if idfprefix != "" then
    str := idfprefix."_";
  end if;
  str .= [[selfcopy getIdfPost !idf] string];
  idfFull := [@lstring new !str ![idf location]];
end reader;

#return the idf with only the suffix.
# -> used with '@..' in ISA description.
reader @varIdfStruct getIdfPost
  ?? @lstring idf
  -> @lstring idfFull
:
  @string str := "";
  str .= [idf string];
  if idfSuffixName != "" then
    str .= idfSuffixName;
  end if;
  idfFull := [@lstring new !str ![idf location]];
end reader;

#*****************************************************************************
# reader related to replaceMap.
#*****************************************************************************
reader @varIdfStruct getReplacedIdf
  ?? @lstring idf
  -> @lstring new
:
  if [selfcopy->replaceMap hasKey ![idf string]] then
    [selfcopy->replaceMap searchKey !idf ?new];
  else
    new := idf;
  end if;
end reader;

#*****************************************************************************
#* useful functions and routines.
#*****************************************************************************
# recursive routine. Check that members of a typedef are defined.
routine checkTypeExists
  ?? @varAbstractType type
  ?? @varIdfStruct idfStruct
:
  cast type
  when == @varStructType vst : #struct type.
    @lstring typeName := [vst typeName];
    @typedefMemberMap memberList;
    [idfStruct->typedefMap searchKey !typeName ?memberList];
    foreach memberList (* @varAbstractType memberType) do
      checkTypeExists !memberType !idfStruct;
    end foreach;
  else
    #either basic or tabular, no pb.
  end cast;
end routine;

#*****************************************************************************
#* Decorated structures that are used in the idfStruct.
#*****************************************************************************

#decorated structure for components.
map @componentMap {
  @functionMap methodMap;
  #idfStruct that embedds local vars (in varMap) and types
  #@varIdfStruct idfStruct;
  #instructions dedicated to type definitions and local var declaration.
  #@instructionList instDeclareList;
  insert insertKey error message "the '%K' component is already defined in %L" ; 
  search searchKey error message "the '%K' component is not defined" ;
  remove removeKey error message "the '%K' component is not defined and cannot be removed." ;
}

#function related structure.
list @parameterDefList {
  @bool out; #true out, false in.
  @varAbstractType type;
  @lstring name;
}

#not yet decorated structure for a function.
map @ASTFunctionMap {
  @parameterDefList param;
  @varAbstractType outType;
  @ASTInstructionList code;
  insert insertKey error message "the '%K' component method is already defined in %L" ; 
  search searchKey error message "the '%K' component method is not defined" ;
}

#decorated structure for a function.
map @functionMap {
  @parameterDefList param;
  @varAbstractType outType;
  @instructionList instList;
  insert insertKey error message "the '%K' component method is already defined in %L" ; 
  search searchKey error message "the '%K' component method is not defined" ;
}

map @memSpaceMap 
{
  @uint width;
  @functionMap methodMap; #accessors for ISA.
  @bool isProgram;
  @uint stride; #computed value, a bit shift.
  insert insertKey error message "the '%K' memory chunk is declared twice." ; 
  search searchKey error message "the '%K' memory chunk is not defined." ;
}


method @componentMap checkComponentMethod
  ?? @lstring componentName
  ?? @lstring methodName
:
  [selfcopy searchKey !componentName ?@functionMap methodMap];
  if [methodMap hasKey ![methodName string]] then
  else error [methodName location]: "No method named :". methodName ."in component ".componentName."\n";
  end if;
end method;


end semantics ;
# vim:ft=ggs:ts=2:sw=2
