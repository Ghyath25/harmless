semantics gadl_semantics_behavior :
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_behavior_data_structures.gSemantics";
  import "gadl_semantics_getInst.gSemantics";
  import "gadl_semantics_implementation_code_generation.gSemantics";
  import "gadl_semantics_format.gSemantics"; #getInstructionName
  import "gadl_templates.gSemantics" ;
  

routine instructionBehaviorPart
  ?? @ASTbehaviorMap ASTbehaviorMap
  ?? @instructionImplementationMap impMap
  ?? @string modelName
  ?? @varIdfStruct idfStruct
  ?! @TfieldMap templateStruct  
  !  @decodedBehaviorMap decodedBehaviorMap
:
  @varIdfStruct idfStructCopy := idfStruct;
  #for code generation
  #we have a pointer to the core using "_core"
  idfStructCopy->idfPrefixCore := "_core->";
  @decodedBehaviorList decodedBehaviorList := getDecodedBehaviorList[!ASTbehaviorMap !idfStructCopy];
  decodedBehaviorMap := [decodedBehaviorList getMap !modelName !impMap];
  [!?decodedBehaviorMap checkInstructionWithFormatPart !impMap];
  updateTemplateForBehavior !decodedBehaviorMap !?templateStruct;
  if [option .verbose_output value] then  
    message "There are ".[decodedBehaviorMap count]." behavior(s) ".
            "instructions (with a corresponding format)\n";
  end if;
  #test.
  #[decodedBehaviorList showBehaviorPath];
end routine;

#a root behavior is a behavior that is never called by another one.
#OK. Tested.
function detectRootBehaviors
  ??  @ASTbehaviorMap ASTbehaviorMap
  ->  @ASTbehaviorMap rootASTbehaviorMap
:
  #a root behavior is a behavior that is never called by another one.
  rootASTbehaviorMap := ASTbehaviorMap;
  foreach ASTbehaviorMap (* * @ASTBehBody body) do
    @ASTbehaviorChunkList chunkList := [body chunkList];
    foreach chunkList (@ASTbehaviorChunk chunk) do
      if (chunk is == @ASTbehChunkCall) then
        @ASTbehChunkCall chunkCall := (cast chunk : @ASTbehChunkCall) ;
        @lstring behaviorCallName := [chunkCall behaviorCallName];
        #ok. This behavior call another behavior:behaviorCallName.
        #Consequently, behaviorCallName is not a root. 
        #Remove it from rootBehaviorMap (if it has not been removed before.)
        if [rootASTbehaviorMap hasKey ![behaviorCallName string]] then
          [!?rootASTbehaviorMap removeKey !behaviorCallName ?* ?*];
        end if;
      end if;
    end foreach;
  end foreach;
end function;
###############################################################################
# generation of the instruction related information,
# based on the path of each behavior.
# it uses a list 'decodedBehaviorList' during build
# but, it is converted to a map after.
###############################################################################

reader @lstringlist string
  -> @string str
:
  str := "";
  foreach selfcopy(@lstring lkey) do str .= [lkey string];
  between str .= "_";
  end foreach;
end reader;


modifier @decodedBehaviorList addASTInstForAll
  ?? @ASTInstructionList ASTinstListToAdd
  ?! @varIdfStruct idfStruct
:
  #get the instruction related to the ASTInstruction
  @symbolValueMap symbolMap [emptyMap];
  @instructionList newInstlist;
  getInst !ASTinstListToAdd ![@expressionContext behavior] !symbolMap !?idfStruct ?newInstlist;
  #then add to each path;
  [!?self addInstForAll !newInstlist];
end modifier;

modifier @decodedBehaviorList addInstForAll
  ?? @instructionList instListToAdd
:
  #add to each path
  @decodedBehaviorList result [emptyList];
  foreach selfcopy do
     result += !refSet !path !instList.instListToAdd;
  end foreach;
  #update structure.
  self := result;
end modifier;

modifier @decodedBehaviorList addRefForAll
  ?? @stringset refsetToAdd
  ?? @lstringlist currentSuffix
:
  @string suffix := [currentSuffix string];
  @decodedBehaviorList result [emptyList];
  foreach selfcopy do
    @stringset set := refSet;
    foreach refsetToAdd do
      @string str := key . suffix;
      set += !str;
    end foreach;
    result += !set !path !instList;
  end foreach;
  self := result;
end modifier;

modifier @decodedBehaviorList addDebugPath
  ?? @lstring pathToAdd
:
  @decodedBehaviorList result [emptyList];
  foreach selfcopy do
    @lstringlist ls := path;
    ls += !pathToAdd;
    result += !refSet !ls !instList;
  end foreach;
  self := result;
end modifier;

#init with one empty path.
modifier @decodedBehaviorList addEmpty
:
  self += ![@stringset default] ![@lstringlist default] ![@instructionList default];
end modifier;

#concatenation.
modifier @decodedBehaviorList cat
  ?? @decodedBehaviorList other
:
  foreach other do
    self += !refSet !path !instList;
  end foreach;
end modifier;


function giveSequence
  ?? @lstringlist pathlist
  -> @string seq
:
  seq := "";
  foreach pathlist do
    seq.=[mValue string];
    if not [[mValue string] containsCharacter !'#'] then
      seq .= "(l.".[[mValue location] line].")";
    end if;
  between seq.=" -> ";
  end foreach;
end function;

#debug
method @decodedBehaviorList showBehaviorPath
:
  message "paths: (".[selfcopy length].")\n";
  foreach selfcopy do
    foreach refSet
    before message " (";
    do message "#".key;
    between message "-";
    after message ")";
    end foreach;

    message "\n\tfields:";
    @varBaseTypeMap fieldMap := [instList getDeclarations ![@varClass field]];
    foreach fieldMap do
      message [lkey string];
    between message " - ";
    end foreach;

    message "\n\tlocals:";
    @varBaseTypeMap localsMap := [instList getDeclarations ![@varClass localVar]];
    foreach localsMap do
      message [lkey string];
    between message " - ";
    end foreach;

    message "\npath:\n";
    message giveSequence[!path];

    message "\n\tcode:\n";
    @string code := generateCode[!instList !1 ![@codeCtx C]];
    message code."\n";

    message "\n";
  end foreach;
end method;

routine handleBehBody
  ?? @lstring behaviorName
  ?? @ASTBehBody body
  ?? @ASTbehaviorMap ASTbehaviorMap
  ?! @decodedBehaviorList current
  ?? @lstringlist currentSuffix
  ?? @varIdfStruct idfStructOrig #original idfStruct (without any locals)
  ?? @varIdfStruct idfStruct
:
  @varIdfStruct idfStructCopy := idfStruct;
  #prepare idfStruct
  idfStructCopy->idfSuffixName := [currentSuffix string];
  idfStructCopy->idfprefix := [behaviorName string];
  #add declaration fields
  [!?current addASTInstForAll ![body fieldList] !?idfStructCopy];
  #add declaration locals
  [!?current addASTInstForAll ![body varDeclarationList] !?idfStructCopy];
  #add declaration refs
  foreach [body referenceSet] do
    [!?current addDebugPath ![@lstring new !"#".key.currentSuffix !here]];
  end foreach;
  [!?current addRefForAll ![body referenceSet] !currentSuffix];

  foreach [body chunkList] do
    cast chunk
    when == @ASTbehChunkImplementation chImp:
      [!?current addASTInstForAll ![chImp instList] !?idfStructCopy];
    when == @ASTbehChunkCall           chCall:
      #classical call -> search the called bahavior
      @parameterDefList parameterDefList;
      @ASTBehBody bodyCall;
      [ASTbehaviorMap searchKey ![chCall behaviorCallName] ?parameterDefList ?bodyCall];
      #update varIdfStruct
      @bool gotARef := [[chCall postRefName] string] != "";
      @lstringlist copySuffix := currentSuffix;
      if gotARef then copySuffix += ![chCall postRefName]; end if;
      #prepare the next idfStruct -> without any local var defined.
      @varIdfStruct nextIdfStruct := idfStructOrig;
      nextIdfStruct->idfSuffixName := [copySuffix string];
      nextIdfStruct->idfprefix := [[chCall behaviorCallName] string];
      #check arguments and get related instructions to the function call.
      #a refaire: c'est l'ancien idfStruct pour l'exp, et le nouveau (prefix) pour l'idf.
      @instructionList instListToAdd;
      @location defLoc := [ASTbehaviorMap locationForKey ![[chCall behaviorCallName] string]];
      [parameterDefList getInlinedInsts ![chCall idfExpList] ![@expressionContext behavior] 
                                        ![[chCall behaviorCallName] location] !defLoc
                                        !idfStructCopy !?nextIdfStruct ?instListToAdd];
      [!?current addInstForAll !instListToAdd];      
      #call that behavior
      [!?current addDebugPath ![chCall behaviorCallName]];
      handleBehBody ![chCall behaviorCallName] !bodyCall !ASTbehaviorMap !?current !copySuffix !idfStructOrig !nextIdfStruct;
      #no pop of current suffix, because we work with a copy.
    when == @ASTbehChunkSelect         chSelect:
      @decodedBehaviorList merge [emptyList];
      foreach [chSelect bodyList](@ASTBehBody selectBody) do
        @decodedBehaviorList copy := current;
        [!?copy addDebugPath ![@lstring new !"select" ![selectBody loc]]];      
        handleBehBody !behaviorName !selectBody !ASTbehaviorMap !?copy !currentSuffix !idfStructOrig !idfStructCopy;
        [!?merge cat !copy];
      end foreach;
      current := merge;
    else
      error here : "internal error: handleBehBody with unknown behavior chunk";
    end cast;
  end foreach;
end routine;

function getDecodedBehaviorList
  ?? @ASTbehaviorMap ASTbehaviorMap
  ?? @varIdfStruct idfStruct
  -> @decodedBehaviorList decodedBehaviorList
:
  #Construct the list of chunks for each instruction.
  decodedBehaviorList := [@decodedBehaviorList emptyList];
  if [option .verbose_output value] then
    message "contructing behavior tree...";
  end if;
  @ASTbehaviorMap rootASTbehaviorMap := detectRootBehaviors[!ASTbehaviorMap];
  foreach rootASTbehaviorMap do
    if [option .verbose_output value] then
      message "\n\tfrom root ".[lkey string]."...";
    end if;  
    @decodedBehaviorList current [emptyList];
    [!?current addEmpty];
    [!?current addDebugPath !lkey];
    handleBehBody !lkey !body !ASTbehaviorMap !?current ![@lstringlist emptyList] !idfStruct !idfStruct;
    [!?decodedBehaviorList cat !current];
  end foreach;
  #debug
  #[decodedBehaviorList showBehaviorPath];
end function;

###############################################################################
# end of path extraction :
# * we have a decodedBehaviorList for each path.
# -> now we have to get a map, where the key is the instruction signature.
# -> and to restrict the map to instructions that have a format part 
#    associated.
###############################################################################

# extract the map from the list of decoded behaviors.
# remove paths which do not have any format associated
# WARNING: no check with format part done.
#          -> should call checkInstructionWithFormatPart after
reader @decodedBehaviorList getMap
  ?? @string modelName
  ?? @instructionImplementationMap impMap
  -> @decodedBehaviorMap decodedBehaviorMap
:
  decodedBehaviorMap := [@decodedBehaviorMap emptyMap];
  foreach selfcopy do
    @lstring instName := [@lstring new !getInstructionName[!refSet !modelName] !here];
    if [impMap hasKey ![instName string]] then
      #Ok. There is a corresponding format. Check for redundancy.
      if [decodedBehaviorMap hasKey ![instName string]] then
        error here: "2 behaviors paths may be used for the same instructions:";
        message "\n * ".giveSequence[!path];
        @lstringlist otherPath;
        [decodedBehaviorMap searchKey !instName ?* ?* ?otherPath];
        message "\n * ".giveSequence[!otherPath];
      else
        [!?decodedBehaviorMap insertKey !instName !refSet !instList !path];
      end if;
    end if;
  end foreach;
end reader;

#this modifier checks that the behavior have a corresponding 
#format:
# * if there is no format, no code will be generated
#   for that behavior (silently ignored)
# * if there is a matching format, it then checks that each field
#   is corectly used (size and sign), and same number.
# * NOTE: restrict map only to behavior with a valid format
modifier @decodedBehaviorMap checkInstructionWithFormatPart
  ?? @instructionImplementationMap impMap
:
  @decodedBehaviorMap resultDecodedBehaviorMap [emptyMap];
  foreach selfcopy do
    if [impMap hasKey ![lkey string]] then
      #ok matching.
      #then checks that each field is correctly set (name and type).
      @varBaseTypeMap varBaseTypeMap;
      [impMap searchKey !lkey ?* ?* ?* ?* ?* ?* ?varBaseTypeMap];
      
      #get fields:
      #TODO: get a @varBaseTypeMap from instList.
      #and add a reader for comparison.
      @varBaseTypeMap fieldMap := [instList getDeclarations ![@varClass field]];
      if [fieldMap count] != [varBaseTypeMap count] then
        error here: "The instruction ".lkey." has ".[varBaseTypeMap count]." binary fields".
                    " in the format part, but has ".[fieldMap count]." fields in the ".
                    "behavior path:".giveSequence[!path];
      else
        #ok, same number of fields. Then check for sign/size.
        @bool ok := true;
        foreach fieldMap(@lstring fieldName @varBaseType type) while ok do
          if not [varBaseTypeMap hasKey ![fieldName string]] then
            error fieldName: "the field ".fieldName." is not declared in the format part for ".
                        "instruction ".lkey.".Behavior path:".giveSequence[!path];
            ok := false;
          else
            @varBaseType formatType;
            [varBaseTypeMap searchKey !fieldName ?formatType];
            @varAbstractType behType := type;
            if not [formatType checkEqual !behType] then
              ok := false;
            end if;
          end if;
        end foreach;
        if ok then
          [!?resultDecodedBehaviorMap insertKey !lkey !refSet !instList !path];
        end if;
      end if;
    end if;
  end foreach;
  self := resultDecodedBehaviorMap;
end modifier;

routine updateTemplateForBehavior
  ?? @decodedBehaviorMap decodedBehaviorMap
  ?! @TfieldMap templateStruct
:
  @stringlist instNameList [emptyList];
  @TfieldMapList instCodeTpl [emptyList];
  #for each instruction
  foreach decodedBehaviorMap do
    @TfieldMap instCodeTplBody [emptyMap];
    addLStringValue !?instCodeTplBody !"name" !lkey;
    #get the path (debug)
    #@string instBody := "\t//".[path string]."\n";
    #We get the instruction implementation body
    @string instBody := generateCode[!instList !1 ![@codeCtx C]];
    addStringValue !?instCodeTplBody !lstringWith[!"code"] !instBody;
    instCodeTpl += !instCodeTplBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"instCodeList"] !instCodeTpl;
end routine;


end semantics ;
# vim:ft=ggs:ts=2:sw=2
