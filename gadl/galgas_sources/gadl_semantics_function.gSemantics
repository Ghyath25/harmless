semantics gadl_semantics_function :
  import "gadl_options.gOption" ;
  import "gadl_types.gSemantics" ;
  import "gadl_semantics_AST_implementation.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_getInst.gSemantics" ; #getInst
  import "gadl_semantics_implementation_code_generation.gSemantics" ;
  

#----------------------------------------------------------------------------
# function def and calls end return.
#----------------------------------------------------------------------------
# @parameterDefList definition of params in a function: 
#             (defined in gadl_varIdfStruct.gSemantics)
# -> reader @parameterDefList checkParams ?@expressionlist idfExpList 
#             (defined in gadl_semantics_GetExp.gSemantics)
# -> method @parameterDefList getInlinedInsts
# -> reader @parameterDefList getFunctionParam (implementation using templates.)

#
# @ASTFunctionMap AST related function
# -> method @ASTFunctionMap getFunctionMap -> get decorated structure.
# -> method @ASTFunctionMap getFunctionPrototypeMap -> get only the prototype.
#
# @functionMap : decorated structure (defined in gadl_varIdfStruct.gSemantics).
# ->reader @functionMap getFunctionTemplate

 
#used during parsing.
map @ASTFunctionMap {
  @parameterDefList param;
  @varAbstractType outType;
  @ASTInstructionList code;
  insert insertKey error message "the '%K' component method is already defined in %L" ; 
  search searchKey error message "the '%K' component method is not defined" ;
}

reader @ASTFunctionMap getFunctionMap
  ?? @expressionContext ctx
  ?? @varIdfStruct idfStruct
  -> @functionMap functionMap
:
  functionMap := [@functionMap emptyMap];
  foreach selfcopy (@lstring key @parameterDefList param @varAbstractType outType @ASTInstructionList code) do
    #first add params to varMap
    @varMap varMap [mapWithMapToOverride ![idfStruct varMap]];
    foreach param(@bool out @varAbstractType type @lstring name) do
      @instDeclaration instDec := [@instDeclaration new !here !type !name ![@varClass localVar] !""];
      [!?varMap insertKey !name !type !not out ![@varClass localVar] !instDec];
    end foreach;
    #update the IdfStruct accordingly (copy to modify).
    @varIdfStruct idfStructCopy := idfStruct;
    idfStructCopy->varMap := varMap;
    #then get instructions from their AST.
    @instructionList instList := getInst[!code !ctx ![@symbolValueMap emptyMap] !idfStructCopy];
    [!?functionMap insertKey !key !param !outType !instList];
  end foreach;
end reader;

#return only the prototype (i.e. instList is empty).
reader @ASTFunctionMap getFunctionPrototypeMap
  -> @functionMap functionMap
:
  functionMap := [@functionMap emptyMap];
  foreach selfcopy (@lstring key @parameterDefList param @varAbstractType outType *) do
    [!?functionMap insertKey !key !param !outType ![@instructionList emptyList]];    
  end foreach;
end reader;

#This reader returns the instructions to generate the function call.
#when used in an inlining approach (as in behaviors)
method @parameterDefList getInlinedInsts
  ?? @ASTExpressionlist ASTexpList #expression list from the caller.
  ?? @expressionContext ctx
  ?? @location callLoc
  ?? @location defLoc
  ?? @varIdfStruct fromIdfStruct
  ?! @varIdfStruct toIdfStruct
  !  @instructionList instList
:
  #here, we have to generate a special assignment, as
  #the idf is related to the new 'toIdfStruct' -> the varMap should be update
  #the expression should be computed using the old 'fromIdfStruct'
  #if there is no 'out', the value is constant, but assigned first (TODO)
  instList := [@instructionList emptyList];
  @expressionlist expList := [ASTexpList getExp !ctx ![@symbolValueMap emptyMap] !fromIdfStruct];
#  @expressionlist expList [emptyList];
  @symbolValueMap symbolValueMap [emptyMap];
#  foreach ASTexpList(@ASTExpression ASTexp) do
#    expList += ![ASTexp getExp !ctx !symbolValueMap !fromIdfStruct];
#  end foreach;
  #check parameters.
  [selfcopy checkParams !expList !callLoc !defLoc];
  #then generate the instructions.
  foreach expList(@expression exp), selfcopy(@bool out @varAbstractType type @lstring name) do
    #declaration
    @ASTInstDeclaration ASTinstDec := [@ASTInstDeclaration new ![name location] ![@varClass localVar] !type !name];
    @instruction instDec;
    [ASTinstDec getInst !ctx !?symbolValueMap !?toIdfStruct ?instDec];
    if out then
      const @instDeclaration instDecOk := (cast instDec : @instDeclaration);
      @lstring idf := [instDecOk name];
      #now get the idf in the expression call.
      @lstring idfCall := [exp getLocalVar !callLoc];
      #then replace it.
      [!?toIdfStruct->replaceMap insertKey !idf !idfCall];
      #We add the corresponding entry in the new varMap
      @varAbstractType idfItemType;
      @bool constant; #true if the variable should not be modified.
      @varClass varClass;
      [fromIdfStruct->varMap searchKey !idfCall ?idfItemType ?constant ?varClass ?@instDeclaration idec];
      [!?toIdfStruct->varMap insertKey !idfCall !idfItemType !constant !varClass !idec];
      if constant then
        error callLoc: "The variable is constant, but defined as in/out parameter";
      end if;
      #that's all, folks.
    else
      instList += !instDec;
      #get the expression related to the idf.
      @ASTIdf ASTidf := [name getASTExp];
      @expIdf expIdf := (cast [ASTidf getExp !ctx !symbolValueMap !toIdfStruct] : @expIdf);    
      #then assign
      instList += ![@instAssignment new ![name location] !expIdf ![@fieldList emptyList] !exp];
    end if;
  end foreach;
end method;

reader @functionMap getFunctionTemplate
  -> @TfieldMapList methodTplList
:
  methodTplList := [@TfieldMapList emptyList];
  foreach selfcopy do
    @TfieldMap methodTplBody [emptyMap];
    addLStringValue !?methodTplBody !"name" !lkey;
    #return type.
    @string returnTypeStr := [[outType getBaseType] getCType];
    addStringValue !?methodTplBody !lstringWith[!"returnTypeStr"] !returnTypeStr;
    #parameters
    @string paramStr := [param getFunctionParam];
    addStringValue !?methodTplBody !lstringWith[!"paramStr"] !paramStr;
    #then body implementation
    @string codeStr := "";
    codeStr .= generateCode[!instList !3 ![@codeCtx C]];
    addStringValue !?methodTplBody !lstringWith[!"codeStr"] !codeStr;
    #end
    methodTplList += !methodTplBody;
  end foreach;
end reader;

reader @parameterDefList getFunctionParam
  -> @string code
:
  code := "";
  foreach selfcopy do
    @string typeStr := [[type getBaseType] getCType]; #only base types supported for now.
    if out then
      code .= typeStr; 
      code .= " &";  # C++ only!
    else 
      code .= "const "; 
      code .= typeStr; 
      code .= " "; 
    end if;
    code .= [name string];
  between
    code .= ", ";
  end foreach;
end reader;

end semantics ;
# vim:ft=ggs:ts=2:sw=2

