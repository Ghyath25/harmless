syntax gadl_instruction_timing_parser ("gadl_lexique.gLexique") :

  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ; #variables: varMap
  import "gadl_semantics_timing.gSemantics" ;
  import "gadl_semantics_expression.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ; #@cAddCycleInst
  import "gadl_components.gSemantics"; #componentMap

#expression related rules
nonterminal  <expression> 
  ?? @varMap varMap
  !  @cExpression outExp 
  ?? @componentMap componentMap
  ?? @uint tmpId
  ?? @expressionContext expContext
;

nonterminal  <componentMethodCall> 
  !  @lstring methodName 
  !  @parameterCallList param 
  ?? @varMap varMap
  ?? @componentMap componentMap
  ?? @lstring componentName
  !  @bool isBitRegisterAccess
  ?? @bool checkParameters
  ?? @expressionContext expContext
;

#implementation part.
nonterminal  <declaration>  
  ?! @varMap varMap 
  ?! @instructionList instList 
  ?? @componentMap componentMap
  ?? @string prefix
  ?! @uint tmpId
  ?? @expressionContext expContext
;

nonterminal <errorHandling>
  ?? @varMap varMap 
  ?! @instructionList instList
  ?? @componentMap componentMap
;

rule  <timing>
  ?! @uint internalTimingId
  ?? @componentMap componentMap
  ?! @timingMap timingMap
:
  $timing$;
  @lstring timingName;
  $idf$ ?timingName;
  @timingChunkList chunkList [emptyList];
  <timingBody> !?chunkList !?internalTimingId !componentMap !?timingMap;
  @aggTiming agg := [@aggTiming new ! chunkList];
  [!?timingMap insertKey !timingName ! agg];
  $end$; $timing$;
end rule;

rule <timingBody>
  ?! @timingChunkList chunkList
  ?! @uint internalTimingId
  ?? @componentMap componentMap
  ?! @timingMap timingMap
:
  repeat
  while
    @lstring ref;
    $reference$ ?ref;
    @refTiming refT := [@refTiming new !ref];
    chunkList += !refT;
  while
    @varMap varMap [emptyMap];
    @instructionList instList;
    <timingDoSection> !varMap !componentMap ?instList;
    @timingImplementation impl := [@timingImplementation new ! instList];
    chunkList += !impl;
  while
    @timingMethodOrRegAccess timingMethodOrRegAccess;
    @instructionList instList [emptyList];
    <timingMethodAccess> ?timingMethodOrRegAccess !componentMap;
    chunkList += ! timingMethodOrRegAccess;
  while
    @idfTiming idfSelectTiming;
    <selectTiming> !?internalTimingId !componentMap !?timingMap ? idfSelectTiming;
    chunkList += ! idfSelectTiming;
  while
    @idfTiming idfTiming;
    <anotherTimingCall> ? idfTiming;
    chunkList += !idfTiming;
  end repeat;
end rule;

rule  <selectTiming>
  ?! @uint internalTimingId
  ?? @componentMap componentMap
  ?! @timingMap timingMap
  !  @idfTiming idfSelectTiming
:
  $select$;
  @lstring selectName := [@lstring new !"select_timing_".[internalTimingId string] !here];
  internalTimingId := internalTimingId + 1;
  @timingChunkList selectChunkList [emptyList];
  repeat
  while
    $case$;
      #inside a 'case' is a new aggregate.
      @lstring caseAggregateName := [@lstring new !"timing_case_".[internalTimingId string] !here];
      internalTimingId := internalTimingId + 1;
      @timingChunkList caseChunkList [emptyList];
      <timingBody> !?caseChunkList !?internalTimingId !componentMap !?timingMap;   
      #create the "aggregate"
      @aggTiming agg := [@aggTiming new !caseChunkList];
      [!?timingMap insertKey !caseAggregateName ! agg];
      #update the alternative to call the new alternative syntax.
      @lstring postRefName := [@lstring new !"" !here]; #no post ref name (@...).
      @idfTiming idfTiming := [@idfTiming new !caseAggregateName !postRefName];
      selectChunkList += !idfTiming;
  end repeat;
  @altTiming selectT := [@altTiming new !selectChunkList];
  [!?timingMap insertKey !selectName !selectT];
  $end$; $select$;
  @lstring postRefName := [@lstring new !"" !here]; #no post ref name (@...).
  idfSelectTiming := [@idfTiming new !selectName !postRefName];
end rule;

rule  <anotherTimingCall>
  !  @idfTiming idfTiming
:
  @lstring postRefName;
  @lstring idf;
  $idf$ ? idf;
  select
    #no post ref name.
    postRefName := [@lstring new !"" !here];
  or
    $postReference$ ? postRefName;
  end select;
  idfTiming := [@idfTiming new !idf !postRefName];
end rule;

#This rule is used to add cycles for one instruction.
rule  <addCycles>
  ?? @varMap varMap 
  ?! @instructionList instList 
  ?? @componentMap componentMap
:
  $add$;
  @cExpression exp;
  @varType outType;
  <expression>  !varMap ?exp !componentMap !0 ![@expressionContext timing];
  checkOneExpressionOutType !exp ?outType;
  @cAddCycleInst inst := [@cAddCycleInst new !here !exp];
  instList += !inst;
  $cycle$;
end rule;

rule <timingDoSection>
  ?? @varMap varMap
  ?? @componentMap componentMap
  !  @instructionList instList 
:
    $do$; 
    @varMap timingVarMap := [@varMap mapWithMapToOverride !varMap];
    instList := [@instructionList emptyList];
    select
      or
      <timingImplementation> !?timingVarMap !?instList !componentMap;
    end select;
    $end$;
    $do$; 
end rule;

rule <timingImplementation> 
  ?! @varMap varMap 
  ?! @instructionList instList
  ?? @componentMap componentMap
:
  @uint tmpId := 0; #used to get unique tmp variable.
  #declaration before implementation.
  repeat
  while
    @string prefix := ""; #local var. No prefix.
    <declaration> !?varMap !?instList !componentMap !prefix !?tmpId ![@expressionContext timing];
  end repeat;
  <timingImplementationWithoutDeclaration> !? varMap !? instList !componentMap;
end rule;

rule <timingImplementationWithoutDeclaration> 
  ?! @varMap varMap 
  ?! @instructionList instList
  ?? @componentMap componentMap
:
  #declaration before implementation.
  repeat
    select
      <timingIfBloc> !varMap !?instList !componentMap;
    or
      <addCycles> !varMap !?instList !componentMap;
    or
      <errorHandling> !varMap !?instList !componentMap;
    end select;
  while
  end repeat;  
end rule;

rule <timingMethodAccess>
  !  @timingMethodOrRegAccess timingMethodOrRegAccess
  ?? @componentMap componentMap
: #should be updated for registers (read and write accesses).
  $if$;
  @varMap timingMethodVarMap [emptyMap] ;
  select
    @lstring methodName;
    @lstring componentName;
    $use$;
    $idf$ ?componentName ; 
    $.$; 
    <componentMethodCall> ?methodName ?* !timingMethodVarMap !componentMap !componentName ?* !false ![@expressionContext timing];
    @instructionList WhenInstructionList := [@instructionList emptyList];
    $then$;
    <timingImplementation> !?timingMethodVarMap !?WhenInstructionList !componentMap;
    timingMethodOrRegAccess := [@timingMethodAccess new !WhenInstructionList !componentName !methodName];
  or
    @lstring regName;
    @bool read;
    select
      $read$;
      read := true;
    or
      $write$;
      read := false;
    end select;
    $idf$ ?regName ; 
    @instructionList WhenInstructionList := [@instructionList emptyList];
    $then$;
    <timingImplementation> !?timingMethodVarMap !?WhenInstructionList !componentMap;
    timingMethodOrRegAccess := [@timingRegAccess new !WhenInstructionList !read !regName];
  end select;
  $end$; 
  $if$;

end rule;

rule <timingIfExpression>
  ?? @varMap varMap 
  !  @cExpression exp
  !  @varType outType
  ?? @componentMap componentMap
:
  select
    <expression> !varMap ?exp !componentMap !0 ![@expressionContext timing];
    checkOneExpressionOutType !exp ?outType;
  or
    $jumpTaken$;
    outType := [@varType new ![@varKind unsigned] !1 !here]; #u1 <=> bool
    exp := [@cExpDummy new !getTypeListFrom[!outType] !"jumpTaken()"];
  end select;
end rule;

# if block, with elseif and else blocks.
rule <timingIfBloc>
  ?? @varMap varMap 
  ?! @instructionList instList
  ?? @componentMap componentMap
:
  $if$;
  @cExpression expIf;
  @varType outTypeIf;
  <timingIfExpression>  !varMap ?expIf ?outTypeIf !componentMap;
  checkBool !outTypeIf !here;
  $then$;
  @varMap ifVarMap := [@varMap mapWithMapToOverride !varMap] ;
  @instructionList IfInstructionList := [@instructionList emptyList];
  <timingImplementation> !?ifVarMap !?IfInstructionList !componentMap;
  #@cIfBlock instIfBlock := [@cIfBlock new !expIf !instIfBlockList !0];
  #instList += !instIfBlock;
  @instructionList elseInstructionList [emptyList];
  select
    #no else.
  or
    $else$;
    @varMap elseVarMap := [@varMap mapWithMapToOverride !varMap] ;
    <timingImplementation> !?elseVarMap !?elseInstructionList !componentMap;
#  or
#    $elseif$;
#    @cInstruction instElse;
#    <timingImplementation> !varMap !componentMap !currentComponent ?instElse;
#    elseInstructionList += !instElse;
  end select;
  @cInstruction inst := [@cIfBlock new !here !expIf !IfInstructionList !elseInstructionList];
  instList += !inst;
  $end$; $if$;
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
