syntax gadl_instruction_format_parser ("gadl_lexique.gLexique") :

  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_format.gSemantics" ;

#specific bit field for formats (not allowing expression). Using the standard one leads to a 
#LL1 conflict because any expression can be used in the field.
#type is the variable type in which the bitfield is accessed. It should be correctly defined, because
#     error are generated if the bit access is not in the variable range.
#     Then, type is updated using the correct number of bits.
rule <formatBitField> 
  !  @fieldList fieldList 
  ?! @varType type
:
  @uint nbBits := 0;
  fieldList := [@fieldList emptyList];
  ${$;
  select
    $-$; # empty field.
  or
    repeat
      @luint64 fromBit;
      $unumber$ ? fromBit;
      @uint sizeOfConst := nbBitsToCodeUnsigned[![fromBit uint64]];
      @cIntConst fromExp := [@cIntConst new !getTypeListFrom[![@varType new ![@varKind unsigned] !sizeOfConst !here]] ![fromBit uint64] !false];
      if [[fromBit uint64] uint] >= [type size] then
        error fromBit : "bit access impossible with the type considered\n".
          "size of data is ".[[type size] string]." bits";
      end if;
      select
   #only a bit -> bitfield size is 1.
        fieldList += !fromExp !fromExp !1 !true !here;
        nbBits := nbBits+1;
      or
        $..$;
        @luint64 toBit;
        $unumber$ ? toBit;
        @uint sizeOfConst2 := nbBitsToCodeUnsigned[![toBit uint64]];

        @cIntConst toExp := [@cIntConst new !getTypeListFrom[![@varType new ![@varKind unsigned] !sizeOfConst2 !here]] ![toBit uint64] !false];
        if([fromBit uint64] < [toBit uint64]) then 
          error toBit : "value is higher than the previous one in the range :".
                        [[toBit uint64] string]." > ".[[fromBit uint64] string];
        end if;
        @uint64 maxSize := [fromBit uint64]-[toBit uint64]+1L;
        fieldList += !fromExp !toExp ![maxSize uint] !true !here;
        nbBits := nbBits+[maxSize uint];
        end select;
    while 
    $,$;
    end repeat;
  end select;
  $}$;
  type := [@varType new ![@varKind unsigned] !nbBits !here];
end rule;

rule <callFormat>
  ?? @lstring idf
  !  @idfOrRefFormatIsIdf idfFormat
:
  @lstring postRefName;
  select
    #no post ref name.
    postRefName := [@lstring new !"" !here];
  or
    $postReference$ ? postRefName;
  end select;
  #no check at this time. It could be declarated after.... mmmh, really? TODO.
  idfFormat := [@idfOrRefFormatIsIdf new !idf !postRefName];
end rule;

# here are some examples of the slice format accepted:
# +{7..0}             -> need an extra byte.
# {7..0}+{7..0}       -> last byte, and a nex extra byte.
# {7..0}+{7..0}{7..0} -> last byte and 2 new extra bytes.
# it checks that there is at least 1 '+' char.
# If there is a '+' char, it means that an extra word must be fetched (in the previous 
# example, 1 byte is fetched at each time). So a '+' char must be followed by a bitfield.
# The slice list returned contains slice offset using the following convention:
#  {7..0}                   ->  0            (nbSlicesBeforeAPlus = 1)
# +{7..0}                   -> +1            (nbSlicesBeforeAPlus = 0)
# {7..0}+{7..0}             ->  0 +1         (nbSlicesBeforeAPlus = 1)
# {7..0}{7..0}+{7..0}{7..0} -> -1  0  +1  +2 (nbSlicesBeforeAPlus = 2)
#
# sliceSize is the size of the slice in bits.
rule <sliceDef>
  ?? @luint defaultInstructionSize
  !  @sliceList sliceList
  !  @uint nbSlicesBeforeAPlus
  !  @uint sliceSize
:
  nbSlicesBeforeAPlus := 0;
  sliceList :=  [@sliceList emptyList];
  sliceSize := 0;
  #get slice list, starting from 0. The final slice list adds an offset.
  @sliceList tempSliceList := [@sliceList emptyList];
  @uint nbSlices := 0;
  @bool foundAPlus := false;
  select
    #no slice. Using the current chunk.
    sliceSize := [defaultInstructionSize uint];
    #get a default field, using the whole
    @fieldList defaultField := [@fieldList emptyList];
    @uint tmp := sliceSize-1;
    @uint sizeOfConstFrom := nbBitsToCodeUnsigned[![tmp uint64]];    
    @cIntConst fromExp := [@cIntConst new !getTypeListFrom[![@varType new ![@varKind unsigned] !sizeOfConstFrom !here]] ![tmp uint64] !false];
    @cIntConst toExp   := [@cIntConst new !getTypeListFrom[![@varType new ![@varKind unsigned] !0 !here]] !0L !false];
    defaultField += !fromExp !toExp !1 !true !here;
    sliceList += !defaultField !0s;
    nbSlicesBeforeAPlus := 1;
  or
    $slice$;
    repeat
    while
      select
      or
        $+$; 
        if foundAPlus then
          error here: "Only one '+' is allowed in a slice definition";
        end if;
        foundAPlus := true;
      end select;
      @varType tempType := [@varType new ![@varKind unsigned] ![defaultInstructionSize uint] !here];
      @fieldList field;
      <formatBitField> ?field !?tempType;
      sliceSize := sliceSize + [tempType size];
      nbSlices := nbSlices + 1;
      if not foundAPlus then nbSlicesBeforeAPlus := nbSlicesBeforeAPlus + 1; end if;
      tempSliceList += !field ![nbSlices sint];
    end repeat;
    #update, using the correct offset.
    foreach tempSliceList (@fieldList f @sint p) do
      sliceList += !f !(p - [nbSlicesBeforeAPlus sint]);
    end foreach;
  end select;
end rule;

#format body: It can be:
# - an assignment
# - a call to another format
# - a reference
# - a select structure
rule <formatBody>
  ?? @luint defaultInstructionSize
  ?? @uint nbSlicesBeforeAPlus
  ?! @assignSliceList assignList
  ?! @idfOrRefFormatList otherformatList
  ?! @idfOrRefFormatList refFormatList
  ?! @uint internalFormatId
  ?! @formatMap formatMap
:
  select
    @lstring idf;
    $idf$ ?idf indexing formatCall;
    select
      <assignFormat> !defaultInstructionSize !nbSlicesBeforeAPlus !idf !?assignList;
    or
      @idfOrRefFormatIsIdf idfFormat;
      <callFormat> !idf ?idfFormat;
      otherformatList += !idfFormat;
    end select;
  or
    @lstring refName;
    $reference$ ?refName; 
    @idfOrRefFormatIsRef ref := [@idfOrRefFormatIsRef new !refName];
    refFormatList += !ref;
  or
    <selectFormat>  !defaultInstructionSize !?internalFormatId !?formatMap !?otherformatList;
  end select;
end rule;

rule <format>  
  ?? @luint defaultInstructionSize
  ?! @formatMap formatMap
  ?! @uint internalFormatId
:
  $format$;
  @lstring formatName;
  $idf$ ?formatName indexing formatDef;

  #prototype slice list.
  @sliceList slicePrototypeList;
  @uint nbSlicesBeforeAPlus;
  <sliceDef> !defaultInstructionSize ?slicePrototypeList ?nbSlicesBeforeAPlus ?*;

  @assignSliceList assignList [emptyList];
  @idfOrRefFormatList otherformatList [emptyList];
  @idfOrRefFormatList refFormatList [emptyList];
  repeat
  while
    <formatBody> !defaultInstructionSize !nbSlicesBeforeAPlus  
                 !?assignList !?otherformatList !?refFormatList !?internalFormatId !?formatMap;
  end repeat;
  $end$; $format$;
  @aggFormat format := [@aggFormat new !slicePrototypeList !assignList !refFormatList !otherformatList];
  [!?formatMap insertKey !formatName !format];
end rule;

#previously known as an "alternative format".
rule <selectFormat>
  ?? @luint defaultInstructionSize
  ?! @uint internalFormatId
  ?! @formatMap formatMap
  ?! @idfOrRefFormatList otherformatList
:
  $select$;
  @sliceList sliceList;
  @uint nbSlicesBeforeAPlus;
  @uint sliceSize;
  @alternativeIsList isList := [@alternativeIsList emptyList];

  @lstring alternativeFormatName := [@lstring new !"select_format_".[internalFormatId string] !here];
  internalFormatId := internalFormatId + 1;
  <sliceDef> !defaultInstructionSize ?sliceList ?nbSlicesBeforeAPlus ?sliceSize;
  #to check that there is a max of 1 'others' keyword.
  @bool othersKeyword := false;
  #binary set used to resolve 'others'.
  @binaryset maskCodingUsed := [@binaryset emptyBinarySet];
  repeat
  while
    @binaryset isFormat;
    <altFormatIs> !defaultInstructionSize !sliceSize !sliceList !nbSlicesBeforeAPlus ?isFormat !?othersKeyword !?maskCodingUsed;

    @assignSliceList caseAssignList := [@assignSliceList emptyList];  
    @idfOrRefFormatList caseFormatCallList [emptyList];
    @idfOrRefFormatList caseRefFormatList [emptyList];
    #each case in a format leads to generate another format (aggregate).
    @lstring caseFormatName := [@lstring new !"format_case_".[internalFormatId string] !here];
    internalFormatId := internalFormatId + 1;
    repeat
    while
      <formatBody> !defaultInstructionSize !nbSlicesBeforeAPlus  
                   !?caseAssignList !? caseFormatCallList !?caseRefFormatList 
                   !?internalFormatId !?formatMap;
    end repeat;
    @sliceList caseSliceList [emptyList]; #no slice associated to that internal format.
    @aggFormat caseFormat := [@aggFormat new !caseSliceList !caseAssignList !caseRefFormatList !caseFormatCallList];
    [!?formatMap insertKey !caseFormatName !caseFormat];
    @idfOrRefFormatIsIdf idf := [@idfOrRefFormatIsIdf new ! caseFormatName ![@lstring new !"" !here]];
    #TODO: temp.
    isList += !idf !isFormat;
  end repeat;
  $end$; $select$;
  #create the alternative format structure
  @assignSliceList altAssignList := [@assignSliceList emptyList];
  @idfOrRefFormatList refFormatList [emptyList];
  @altFormat selectFormat := [@altFormat new !sliceList !altAssignList !refFormatList !isList !nbSlicesBeforeAPlus];
  [!?formatMap insertKey !alternativeFormatName !selectFormat];  
  #update the aggregate to call the new alternative format.
  @idfOrRefFormatIsIdf alternativeFormat := [@idfOrRefFormatIsIdf new !alternativeFormatName ![@lstring new !"" !here]];
  otherformatList += !alternativeFormat;
end rule;


#this rule reads cases in a 'select' 'end select' structure.
#It reads:
# case 'mask' is
#Where mask can be:
# - an unsigned number
# - a mask (prefixed by \m)
# - a disjunction of unsigned numbers and masks: \m--1 or \b100
# - the 'others' keyword. It can be used only one time, at the end of the select structure.
# parameters are:
#   - defaultInstructionSize: basic size of instructions
#   - sliceSize: the slice size specfied in the select part: This is to check sizes.
#   - tempSliceList: the slice list, with the correct offset.

rule <altFormatIs>
  ?? @luint defaultInstructionSize
  ?? @uint sliceSize
  ?? @sliceList sliceList
  ?? @uint nbSlicesBeforeAPlus
  !  @binaryset isFormat
  ?! @bool othersKeyword
  ?! @binaryset maskCodingUsed #used to make the binaryset for 'others' keyword.
:
  isFormat := [@binaryset emptyBinarySet];
  select
      $others$;
      if othersKeyword then 
        error here : "Only one 'others' keyword allowed in a format!";
      end if;
      @binaryset tempSet := ~maskCodingUsed;
      @binaryset tempIsFormat;
      getRelativeBinarySet !tempSet !sliceSize !defaultInstructionSize !sliceList !nbSlicesBeforeAPlus ?tempIsFormat;
      isFormat := isFormat | tempIsFormat;
      othersKeyword := true;
  or
    $case$;
    repeat
      select
        @luint64 nb;
        $unumber$ ?nb;
#        @uint64 tempNb     := [[nb uint] uint64];
        @binaryset tempSet := [@binaryset binarySetWithEqualToConstant !0 !sliceSize ![nb uint64]];
        @binaryset tempIsFormat;
        getRelativeBinarySet !tempSet !sliceSize !defaultInstructionSize !sliceList !nbSlicesBeforeAPlus ?tempIsFormat;
        isFormat := isFormat | tempIsFormat;
        maskCodingUsed := maskCodingUsed | tempSet;
        if [[nb uint64] uint] > ((1 << sliceSize) - 1)  then
          error here: "number size does not fit in the slice".
                      " considered : size:".[sliceSize string];
        end if;
        if othersKeyword then
          error here : "It is not allowed to add a ref/alternative after a 'others' keyword.";
        end if;
      or
        @lstring mask;
        $binaryMask$ ?mask;
        @string tempMask   := [[mask string] stringByReplacingStringByString !"-" !"X"];
        @binaryset tempSet := [@binaryset binarySetWithPredicateString !tempMask];
        @binaryset tempIsFormat;
        getRelativeBinarySet !tempSet !sliceSize !defaultInstructionSize !sliceList !nbSlicesBeforeAPlus ?tempIsFormat;
        isFormat := isFormat | tempIsFormat;
        maskCodingUsed     := maskCodingUsed | tempSet;
        if sliceSize != [[mask string] length] then
          error here: "mask size (".[[[mask string] length] string].") has not the size of the slice".
                      " considered : ".[sliceSize string];
        end if;
        if othersKeyword then
          error here : "It is not allowed to add a ref/alternative after a 'others' keyword.";
        end if;
      end select;
    while 
      $or$;
    end repeat;
  end select;
  $is$;
end rule;

rule <assignFormat> 
  ?? @luint defaultInstructionSize
  ?? @uint sliceOffset 
  ?? @lstring idf
  ?! @assignSliceList assignList
:
  $:=$;
  @sliceList slice := [@sliceList emptyList];
  @uint typeLength := 0; #final length of the slice.
  @uint nbSlicesInAssign := 0;
  @varKind kind;    # signed assignmenent
  @uint shiftType; #value is shifted? type 0, 1 or 2
  @luint shift;    #shift value.
  select
    kind := [@varKind unsigned];
  or
    $signed$;
    kind := [@varKind signed];
  end select;
  $slice$;
  repeat
    @fieldList fieldList;
    @varType typeSlice := [@varType new ![@varKind unsigned] ![defaultInstructionSize uint] !here]; #TODO: update.
    <formatBitField> ?fieldList !?typeSlice; #type updated.(no size verification ....)
    typeLength := typeLength + [typeSlice size];
    nbSlicesInAssign := nbSlicesInAssign + 1;
    slice += !fieldList !([nbSlicesInAssign sint] - [sliceOffset sint]);
  while
  end repeat;
  select
    shift := [@luint new !0 !here];
    shiftType := 0;
  or
    @luint64 tmpShift;
    $<<$; $unumber$ ?tmpShift;
    shift := [@luint new ![[tmpShift uint64] uint] !here];
    typeLength := typeLength + [shift uint];
    shiftType := 1;
  or
    @luint64 tmpShift;
    $>>$; $unumber$ ?tmpShift;
    shift := [@luint new ![[tmpShift uint64] uint] !here];
    if(typeLength < [shift uint]) then
      error here: "fields returns always 0!";
    else
      typeLength := typeLength - [shift uint];
    end if;
    shiftType := 2;
  end select;
  @varType type := [@varType new !kind !typeLength !here]; #return type
  assignList += !idf !slice !type !shiftType !shift;
end rule;

end syntax ;

# vim:ft=ggs:ts=2:sw=2
