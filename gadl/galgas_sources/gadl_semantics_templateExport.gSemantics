semantics gadl_semantics_templateExport :
  import "gadl_options.gOption" ;
  import "gadl_semantics_implementation_code_generation.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;

## setter for instDeclaration (for getter function in generated code).
reader @instDeclaration setter
  -> @string str
:
  switch access
  when programCounter,GPR,SFR:
    str := "\t\t\tm_".[[selfcopy name] string]." = value;";
  when registerSlice:
    error here: "internal error: @instDeclaration setter with slice":str;
  when device:
    error here: "internal error: @instDeclaration setter with device":str;
  when localVar, field:
    str := [[selfcopy name] string];
  end switch;
end reader;


override reader @instDeclarationRegSlice setter
  -> @string str
:
  switch access
  when programCounter,GPR,SFR,localVar, field,device:
    error here: "internal error: @instDeclaration setter":str;
  when registerSlice:
    str := "\t\t\t".[[type getBaseType] getCType] ." __temp = ".[idf string]."();\n";
    str .= "\t\t\t__temp = ".[fieldList getAssignCode ![@codeCtx C] !"__temp" !"value"].";\n";
    str .= "\t\t\tset".[idf string]."(__temp);";
  end switch;
end reader;

## getter for instDeclaration (for getter function in generated code).
reader @instDeclaration getter
  ?? @bool unused useLocal #can use local variable (optimisation for components).
  -> @string str
:
  switch access
  when programCounter,GPR,SFR:
    str := "return m_".[[selfcopy name] string].";";
  when registerSlice:
    error here: "internal error: @instDeclaration getter with slice":str;
  when device:
    error here: "internal error: @instDeclaration getter with device":str;
  when localVar, field:
    str := [[selfcopy name] string];
  end switch;
end reader;

override reader @instDeclarationRegSlice getter
  ?? @bool useLocal #can use local variable (optimisation for components).
  -> @string str
:
  switch access
  when programCounter,GPR,SFR,localVar, field,device:
    error here: "internal error: @instDeclaration getter with slice":str;
  when registerSlice:
    @string name;
    if useLocal then
      name := "m_".[idf string]; #for components (direct access)
    else
      name := [idf string]."()"; #for peripherals (trigger action).
    end if;
    str := "return ".[fieldList getExpCode ![@codeCtx C] !name].";";
  end switch;
end reader;


method @varIdfStruct setProgramCounterInTemplate
  ?! @TfieldMap templateStruct
:
  #program counter specific
  [selfcopy->varMap checkProgramCounter ?@varBaseType typePC ?@lstring PCname];
  addStringValue !?templateStruct !lstringWith[!"PC_SIZE_IN_BITS"] ! [[typePC size] string];
  addStringValue !?templateStruct !lstringWith[!"PC_C_TYPE"] ![typePC getCType];
  addStringValue !?templateStruct !lstringWith[!"PC_NAME"] ![PCname string];
end method;

method @varIdfStruct setInTemplate
  ?! @TfieldMap templateStruct
:
  @TfieldMap idfStructBody [emptyMap];

  @TfieldMapList varListTpl [emptyList];
  #varMap -> registers : type and name
  foreach varMap do
    @TfieldMap varMapRegBody [emptyMap];
    addLStringValue !?varMapRegBody !"name" !lkey;
    @string typeStr := [[type getBaseType] getCType]; #only base types supported for now.
    addStringValue !?varMapRegBody !lstringWith[!"type"] !typeStr;
    addBoolValue !?varMapRegBody !lstringWith[!"constant"] !constant;
    addUnsignedValue !?varMapRegBody !lstringWith[!"varClassId"] ![varClass id];
    @lstring baseName := lkey;
    if varClass == [@varClass registerSlice] then
      @stringlist strList := [[lkey string] componentsSeparatedByString !"_"];
      [strList first ?@string baseNameStr];
      baseName := [@lstring new !baseNameStr ![lkey location]];
    end if;
    addLStringValue !?varMapRegBody !"baseName" !baseName;

    @uint size := 0;
    if (type is >= @varBaseType) then
      size := [[type getBaseType] size];
    end if;
    addUnsignedValue !?varMapRegBody !lstringWith[!"size"] ![size uint64]; #size in bits.

    #getter code.
    addStringValue !?varMapRegBody !lstringWith[!"getter"] ![inst getter !true];
    addStringValue !?varMapRegBody !lstringWith[!"getterNoLocal"] ![inst getter !false];
    
    #setter code.
    addStringValue !?varMapRegBody !lstringWith[!"setter"] ![inst setter];

    varListTpl += !varMapRegBody;
  end foreach;
  addListValue !?idfStructBody !lstringWith[!"varList"] !varListTpl;
  
  #do not export memSpaceMap to the idfStruct (which is embedded into a core).
  #because a memSpace is global. There is a copy in idfStruct for easy access.
  addStructValue !?templateStruct !lstringWith[!"idfStruct"] !idfStructBody;
end method;


end semantics ;
# vim:ft=ggs:ts=2:sw=2
