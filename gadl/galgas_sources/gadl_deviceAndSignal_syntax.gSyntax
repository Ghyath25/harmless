syntax gadl_deviceAndSignal_syntax ("gadl_lexique.gLexique") :
import "gadl_options.gOption" ;
import "gadl_varIdfStruct.gSemantics";
import "gadl_peripheral_grammar.gGrammar";

nonterminal <memoryMapping> !@memoryMapping memoryMapping;
nonterminal <idf> !@ASTExpression exp;

rule <deviceDeclaration>
  ?? @bool memoryAccessIsLocal #true if a device is declared inside a peripheral (same mem chunk).
  ?? @ASTperipheralMap ASTperipheralMap
  !  @ASTInstDeclarationDevice deviceDec
:
  @varAbstractType type;
  $device$; $idf$ ?@lstring deviceType;
  [ASTperipheralMap searchKey !deviceType ?* ?* ?* ?* ?* ?* ?* ?*]; #check that peripheral is defined.
  @varAbstractType typeBase := [@varDeviceType new ![@varKind custom] !deviceType];
  select #code extracted from rule <typeDeclaration>
    @luint64 tabLength;
    $[$; $unumber$ ?tabLength; $]$;
    type := [@varTabularType new ![@varKind tabular] !typeBase ![tabLength uint]];
  or
    type := typeBase;
  end select;
  $idf$ ?@lstring deviceName;
  $maps$; $to$; 
  @memoryMapping memoryMapping;
  select
    $unumber$ ?@luint64 address;
    memoryMapping := [@memoryMapping new ![@lstring new !"__local" !here] !address];
    if not memoryAccessIsLocal then
      error here: "The device declaration is not local. The memory space should be given: mem:\\x..";
    end if;
  or
    <memoryMapping> ?memoryMapping;
    if memoryAccessIsLocal then
      error here: "The device declaration is local. Only the memory address should be given (no memory space name).";
    end if;
  end select;
  deviceDec := [@ASTInstDeclarationDevice new !here ![@varClass device] !type !deviceName !memoryMapping];
end rule;

rule <signalConnect>
:
  $signal$; ${$;
  repeat
  while
    $shared$; $port$;
    <idf> ?@ASTExpression ASTExpPortName;
    $->$;
    select
      <idf> ?@ASTExpression ASTExpToSignal;
      $wait$;
      <idf> ?@ASTExpression ASTExpWaitSignal;  
    or
      $*$; #joker
    end select;
  while
    <idf> ?@ASTExpression ASTExpFromSignal;
    $->$;
    select
      <idf> ?@ASTExpression ASTExpToSignal;
    or
      $*$; #joker
    end select;
  while
    $export$;
    select
      $in$;
    or
      $out$;
    end select;
    repeat
      <idf> ?@ASTExpression ASTExpSignal;
    while $,$;
    end repeat;
  end repeat;
  $}$;
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
