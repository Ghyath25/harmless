semantics gadl_semantics_implementation:
  import "gadl_options.gOption" ;
  import "gadl_semantics_AST_implementation.gSemantics" ;
  import "gadl_semantics_expression.gSemantics";  
  import "gadl_semantics_instruction.gSemantics";  #define @instruction and instruction List

# basic instructions (extends @instruction):
# + @instIf
# + @instReturn
# + @instNop
# + @instLoop
# + @instError
# + @instPrint
# + @instMessage
# + @instFunctionCall
# + @instAssignment
# + @instDeclaration   -> declared in gadl_variable.gSemantics
#   -> @instDeclarationRegSlice 
# + @instTypeDefinition

#reader:
# @instructionList getDeclarations -> return the map of variable, fields, etc.

## get name for instDeclaration -> because there is a subclass for slice registers.

#abstract class @instruction {
#  @location loc;
#}
#
#list @instructionList {
#  @instruction inst;
#}

#mainly used for debug and trace.
reader @instructionList getDeclarations
  ?? @varClass varClass
  -> @varBaseTypeMap varBaseTypeMap
:
  varBaseTypeMap := [@varBaseTypeMap emptyMap];
  foreach selfcopy do
    if (inst is == @instDeclaration) then
      const @instDeclaration instCast := (cast inst: @instDeclaration) ;      
      if varClass == [instCast access] then
        if not [varBaseTypeMap hasKey ![[instCast name] string]] then
          [!?varBaseTypeMap insertKey ![instCast name] ![[instCast type] getBaseType]];
        end if;
      end if;
    end if;
  end foreach;
end reader;



class @instIf extends @instruction {
  @expression cond;
  @instructionList instIfList;
  @instructionList instElseList;
}

class @instReturn extends @instruction {
  @expression exp;
}

class @instNop extends @instruction {
  @expressionContext expContext;
  @expression cond;
}

class @instLoop extends @instruction {
  @expression guard;
  @expression expCondition;
  @instructionList loopInstList;
}

class @instError extends @instruction {
  @bool onlyWarn;
  @lstring msg;
}

class @instPrint extends @instruction {
  @expression exp;
}

class @instMessage extends @instruction {
  @lstring msg;
}

class @instFunctionCall extends @instruction {
  @expIdf exp;
}

class @instAssignment extends @instruction {
  @expIdf idf;
  @fieldList flist;
  @expression exp;
}

#  @instDeclaration declared in gadl_variable.gSemantics

#class @instDeclaration extends @instruction {
#  @varAbstractType type;
#  @lstring idf feature nogetter; #should not be used directly -> use the 'name' reader instead.
#  @varClass access;
#  @string prefixLocal; #used to get a unique local var name.
#}

class @instDeclarationRegSlice extends @instDeclaration {
  @lstring sliceName;
  @fieldList fieldList;
}

class @instTypeDefinition extends @instruction {
  @lstring idf;
  @typedefMemberMap memberList;
}

##########
## get name for instDeclaration
reader @instDeclaration name
  -> @lstring fullName
:
  fullName := idf;
end reader;

override reader @instDeclarationRegSlice name
  -> @lstring fullName
:
  fullName := [@lstring new ![idf string]."_".[sliceName string] ![sliceName location]];
end reader;


end semantics;
# vim:ft=ggs:ts=2:sw=2
