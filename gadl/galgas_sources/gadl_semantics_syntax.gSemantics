semantics gadl_semantics_syntax :
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_format.gSemantics" ;
  import "gadl_semantics_GetExp.gSemantics" ;
  import "gadl_semantics_expression_code_generation.gSemantics" ; #castCode routine;
  import "gadl_semantics_implementation_code_generation.gSemantics" ; #tabs



#----------------------------------------------------------------------------
#--- Syntax
#----------------------------------------------------------------------------

map @printNumberTypeMap {
  @lstring numberType;
  insert insertKey error message "the '%K' type number is already defined in %L" ; 
  search searchKey error message "the '%K' type number is not defined" ;
}

#############  Chunk definition ############## 
abstract class @syntaxChunk{
}
abstract method @syntaxChunk printImplementation ??@varMap fieldMapWithoutSuffix ??@uint indentation ??@string currentSuffixStr ?!@string code ??@printNumberTypeMap typeMap ??@bool switchGenerate;


list @syntaxChunkList {
  @syntaxChunk chunk;
}

list @syntaxArgsList {
  @ASTExpression exp;
}

class @printInst {
  @lstring str;
  @syntaxArgsList arg;
}

routine printTypeName
  ?? @printNumberTypeMap typeMap 
  ?? @char charNext
  ?! @string reg
  ?? @varBaseType expType
:
  @lstring prefixDec := [@lstring new ![charNext string] . "_p" !here];
  @lstring suffixDec := [@lstring new ![charNext string] . "_s" !here];
  @lstring prefix := [@lstring new !"" !here];
  @lstring suffix := [@lstring new !"" !here];
  #get the prefix, if defined.
  if [typeMap hasKey ![prefixDec string]] then
    [typeMap searchKey !prefixDec ? prefix];
  end if;
  #get the suffix, if defined.
  if [typeMap hasKey ![suffixDec string]] then
    [typeMap searchKey !suffixDec ? suffix];
  end if;
  # for > 32 bits, use long long approach.
  @string ll := "";
  if [expType size] > 32 then ll := "ll"; end if;
  if ([charNext string] == "d") & ([expType kind] == [@varKind unsigned]) then #decimal with unsigned exp.
    reg .= [prefix string] . "%".ll."u" . [suffix string];
  elsif [charNext string] == "b" then
    reg .= [prefix string] . "%".ll."d" . [suffix string];
#  elsif [charNext string] == "x" then
#    @uint sizeCInHex := [expType size] >> 2; #one hex => 4 bits.
#    if ([expType size] & 0x3) != 0 then sizeCInHex := sizeCInHex + 1; end if;
#    reg .= [prefix string] . "%0".[sizeCInHex string]."x" . [suffix string];
  else
    reg .= [prefix string] . "%".ll.[charNext string] . [suffix string];
  end if;
end routine;

# In case of generateSyntaxImplementationFiles, this routine returns file1 containing 
#for example: AND R%d, R%d , and file2 containing for example: ,rd1Index, rs1Index
#and in case of generating of Syntax.log, it returns file1 containing for example: AND Rrd1Index, Rrs1Index
#and file2 is empty (file2 := "";)
routine print
  ?? @varMap fieldMapWithoutSuffix
  ?? @printInst printInst
  ?? @printNumberTypeMap typeMap
  ?? @string currentSuffixStr
  ?? @bool switchGenerate 
  ?! @string file1
  ?! @string file2
:
  @string str := [[printInst str] string];
  @syntaxArgsList args := [printInst arg];
  @uint length := [str length];
  @uint i := 0;
  @string reg := "";
  loop length + 1 :
  while i < length do
    @bool ok := false;
    @char char := [str characterAtIndex !i];
    @char charNext ;
    if i == (length-1) then
      charNext := '@' ;
    else
      charNext := [str characterAtIndex !(i+1)];
    end if ;
    if [args length] != 0 then
      foreach args(@ASTExpression ASTargUnused) do
        if not ok then
          if (char == '\\') & ((charNext == 'd') | (charNext == 'x') | (charNext == 'b') | (charNext == 'o')) then
            [!?args popFirst ?@ASTExpression ASTarg];    
            @expression arg;
            @lstring emptyLString := [@lstring new !"" !here];
            @varIdfStruct idfStruct [default];
            idfStruct->varMap := fieldMapWithoutSuffix;
            idfStruct->idfSuffixName := currentSuffixStr;
            #message "arg -> ".[[ASTarg loc] locationString]."\n";
            arg := [ASTarg getExp ![@expressionContext syntaxView] ![@symbolValueMap emptyMap] !idfStruct];
          
            @varBaseType type := [[arg type] getBaseType];
            if switchGenerate then
              printTypeName !typeMap !charNext !?reg !type;
              file2 .= ",";
              if charNext == 'b' then
                file2 .= "dtobin(";
              end if;
              #cast for correct print.
              @location loc := [[printInst str] location];
              if [type size] <= 32 then
                file2 .= "(u32)(";

                castCode !arg ![@varBaseType new ![@varKind unsigned] !32 !loc] !?file2 ! false ![@codeCtx C];
                #castCode !exp ![@varType new ![@varKind unsigned] !32 !loc] !"" !currentSuffixStr !?file2 ! false ![@codeCtx C];
                file2 .=")";
              elsif [type size] <= 64 then
                file2 .= "(u64)(";
                castCode !arg ![@varBaseType new ![@varKind unsigned] !64 !loc] !?file2 ! false ![@codeCtx C];
                #castCode !exp ![@varType new ![@varKind unsigned] !63 !loc] !"" !currentSuffixStr !?file2 ! false ![@codeCtx C];
                file2 .=")";
              else
                error loc: "cannot print value > 64 bits in mnemo.";
              end if;
              if charNext == 'b' then
                file2 .= ")"; #.c_str()";
              end if;
            end if;
            file1 .= reg;
            if not switchGenerate then
              file1 .= [arg generateCode ![@codeCtx C]];
            end if;
            reg := "";
            i++;
            ok := true;
          else
            ok := true;
            reg .= [char string];
          end if;
        end if;
      end foreach;
    else         
      reg .= [[str characterAtIndex !(i)] string];
    end if;
    i ++;
  end loop;
  file1 .= reg;
  reg := "";
end routine;

class @printChunk extends @syntaxChunk {
  @printInst printInst;
}

override method @printChunk printImplementation 
  ?? @varMap fieldMapWithoutSuffix
  ?? @uint indentation
  ?? @string currentSuffixStr
  ?! @string code
  ?? @printNumberTypeMap typeMap
  ?? @bool switchGenerate
:
  code .= tabs[!indentation];
  @string file1 := "";
  @string file2 := "";
  print !fieldMapWithoutSuffix !printInst !typeMap !currentSuffixStr !switchGenerate !?file1 !?file2;
  code .= "index += sprintf (result + index,\"" . file1 . "\"" . file2 . ");\n"; 
end method ;

list @ifElsifList {
  @ASTExpression elsifCondition ;
  @syntaxChunkList elsifInstructions ;
}

class @ifChunk extends @syntaxChunk {
  @ifElsifList elsifList ;
  @syntaxChunkList elseInstructions ;
}

override method @ifChunk printImplementation 
  ?? @varMap fieldMapWithoutSuffix
  ??@uint indentation 
  ??@string currentSuffixStr 
  ?!@string code 
  ??@printNumberTypeMap typeMap 
  ??@bool switchGenerate
:
  # imprimer ifCondition
  @bool foundIf := false;
  foreach elsifList (@ASTExpression ASTElsifCondition @syntaxChunkList elsifInstructions) do
    @expression elsifCondition;
    @lstring emptyLString := [@lstring new !"" !here];
    @varIdfStruct idfStruct [default];
    idfStruct->varMap := fieldMapWithoutSuffix;
    idfStruct->idfSuffixName := currentSuffixStr;
    elsifCondition := [ASTElsifCondition getExp ![@expressionContext syntaxView] ![@symbolValueMap emptyMap] !idfStruct];
    @bool hasParenthesis := [elsifCondition hasParenthesis];
  
    code .= tabs[!indentation];
    if not foundIf then
      code .= "if";
      foundIf := true;
    else 
      code .= "}else if";
    end if;
    if not hasParenthesis then code .= "("; end if;  
    code .= [elsifCondition generateCode ![@codeCtx C]];
    if not hasParenthesis then code .= ")"; end if;      
    code .= "{\n";
    foreach elsifInstructions (@syntaxChunk chunk) do
      [chunk printImplementation !fieldMapWithoutSuffix !indentation+1 !currentSuffixStr !?code !typeMap !switchGenerate] ;
    end foreach ;
  end foreach ;
  if [elseInstructions length] > 0 then
    code .= tabs[!indentation]."}else{\n";
    foreach elseInstructions (@syntaxChunk chunk) do
      [chunk printImplementation !fieldMapWithoutSuffix !indentation+1 !currentSuffixStr !?code !typeMap !switchGenerate] ;
    end foreach ;
  end if ;
  code .= tabs[!indentation]."}\n";
end method ;

abstract class @idfOrRefSyntax extends @syntaxChunk {
  @lstring name;
}
override method @idfOrRefSyntax printImplementation 
  ?? @varMap unused fieldMapWithoutSuffix
  ?? @uint unused indentation 
  ?? @string unused currentSuffixStr 
  ?! @string unused code 
  ?? @printNumberTypeMap unused typeMap 
  ?? @bool unused switchGenerate:
end method ;

class @idfOrRefSyntaxIsIdf extends @idfOrRefSyntax{
  @lstring postRefName; #string to add in the called syntax. (suffix)
} 

class @idfOrRefSyntaxIsRefDeclaration extends @idfOrRefSyntax {
}

list @syntaxChunkListWithSuffix {
  @syntaxChunk chunk;
  @stringlist suffixList;  
}

list @syntaxChunkListWithSuffixList {
  @syntaxChunkListWithSuffix chunkList;
}

########### data storage ##############
#What is contained into a syntax (agg or alt).

abstract class @syntaxBody {
  @syntaxChunkList chunkList;
  @varMap fieldMap;
}

class @aggSyntax extends @syntaxBody {
}

class @altSyntax extends @syntaxBody {
}

map @syntaxMap {
  @syntaxBody syntaxBody;
  insert insertKey error message "the '%K' syntax is already defined in %L" ; 
  search searchKey error message "the '%K' syntax is not defined in map" ;
  remove removeKey error message "the '%K' syntax is not defined and cannot be removed." ;
}

list @syntaxStringSetList
{
  @stringset stringSet;
}
list @syntaxLStringListList
{
  @lstringlist stringList;
}

###########################################################################
#  Routines to check Syntax's arguments 
###########################################################################
routine giveSequenceSyntax
  ?? @syntaxChunkListWithSuffix chunkList 
:
  @stringlist strList := [@stringlist emptyList];
  foreach chunkList (@syntaxChunk chunk *) do
    cast chunk
    when == @idfOrRefSyntaxIsIdf chunkIsIdf :
      strList += ![[chunkIsIdf name] string];
    when >= @idfOrRefSyntax chunkIsSyntax : #ref or declarationRef
      @string temp := "#".[[chunkIsSyntax  name] string];
      strList += !temp;
    else
    end cast;
  end foreach;
  @bool first := true;
  foreach strList (@string str) do
    if not first then message " -> "; end if;
    first := false;
    message str;
  end foreach;
  message "\n";
end routine;

routine compareArgsAndAntiSlash
?? @printInst printInst
?! @bool isError
:
  @uint nbArgs := [[printInst arg] length];
#  if nbArgs !=0 then
  @uint slash := 0;
  @uint i := 0;
  @string str := [[printInst str] string];
  @uint length := [str length];
  loop length + 1 :
  while i < length do
    @char char := [str characterAtIndex !i];
    if char == '\\' then
      @char charNext ;
      if i == (length-1) then
        charNext := '@' ;
      else
        charNext := [str characterAtIndex !(i+1)];
      end if;
      if (charNext == 'd') | (charNext == 'x') | (charNext == 'b') | (charNext == 'o') then
        slash := slash + 1;
      end if;
    end if;
    i ++;
  end loop;
  if nbArgs != slash then     
    error [[printInst str] location]: "\nThe number of arguments is not compatible ".
                                      "with the number of '\\'.\n";                           
    isError := true;
  end if;
#  end if;
end routine;

routine checkSyntaxArgs
?? @syntaxMap syntaxMap
:
  if [option .verbose_output value] then
    message "Check Syntax Arguments...";
  end if;
  @bool isError := false;
  foreach syntaxMap (@lstring syntaxName @syntaxBody syntaxBody) do
    @syntaxChunkList chunkList := [syntaxBody chunkList];
    foreach chunkList (@syntaxChunk chunk) do
      cast chunk
      when == @printChunk chunkIsPrint :
        @printInst printInst := [chunkIsPrint printInst];
        compareArgsAndAntiSlash !printInst !?isError;
      else  
      end cast;
    end foreach;
  end foreach;
  if not isError then
    if [option .verbose_output value] then
      message "ok.\n";
    end if;
  end if;
end routine; 

routine checkSyntaxInstructionWithFormatCompatibility
  ?? @syntaxMap syntaxMap
  ?? @syntaxChunkListWithSuffixList instructionList
  ?? @instructionImplementationMap impMap
  ?? @syntaxLStringListList instructionSeqList #-> for logs and eror messages
  ?? @syntaxStringSetList  referenceSeqList   #-> for internal use
  ?? @lstring modelName
  !  @bool noError
:
  #log instructionList;
  noError := true;
  #for each instruction
  foreach instructionList (@syntaxChunkListWithSuffix chunkList),
          referenceSeqList (@stringset referenceSeq),
          instructionSeqList (@lstringlist instList) do
    @string instName := getInstructionName[!referenceSeq ![modelName string]];
    #first that the instruction extracted from syntax was declared in the format part.
    if not [impMap hasKey !instName] then
       error here : "internal error: The syntax signature of the instruction does not match any format instruction :-/";
    else
      #ok matching
      #then checks that each field is correctly set (name and type).
      @varBaseTypeMap instructionFieldMap;
      @lstring instNameLoc := [@lstring new !instName !here];
      [impMap searchKey !instNameLoc ?* ?* ?* ?* ?* ?* ?instructionFieldMap];
      #now get all the fields in the behavior.
      @uint nbFields := 0;
      foreach chunkList (@syntaxChunk chunk @stringlist suffixList) do
        @string suffixName;
        getSuffixString !suffixList ?* ?suffixName;
        #get the fieldMap
        @varMap fieldMap;
        cast chunk
        when == @idfOrRefSyntaxIsIdf chunkIsIdf :
          @syntaxBody syntaxBody;
          [syntaxMap searchKey ![chunkIsIdf name] ?syntaxBody];
          fieldMap := [syntaxBody fieldMap];
        else fieldMap := [@varMap emptyMap];
        end cast;
        #check that each entry in the field Map is declared in the format.
        foreach fieldMap (@lstring name @varAbstractType abstractType ...) do
          @lstring nameWithSuffix := [@lstring new ![name string].suffixName ![name location]];
          @varBaseType type := [abstractType getBaseType];
          nbFields := nbFields + 1;
          @varBaseType formatType;
          @bool errorFound := false;
          if [instructionFieldMap hasKey ![nameWithSuffix string]] then
            [instructionFieldMap searchKey !nameWithSuffix ?formatType];
          else
            @string errorStr := "cannot find the field ".[nameWithSuffix string].
                                " in the format description of instruction ";
            printInstructionId ! referenceSeq !? errorStr;
            error [name location]: errorStr :formatType;
          end if;
          #size?
          if [type size] < [formatType size] then
            error [name location]: "the type size (".[[type size] string]." bits) for the data field". 
                                   "in instruction is not compatible with the one declared ".
                                   "in the format description (".[[formatType size] string]." bits)".
                                   "\nThe syntax sequence found is:\n";
            errorFound := true;
          end if;
          #sign?
          if [type kind] != [formatType kind] then
            error [name location]: "the kind (unsigned, signed or float) for the data field in instruction is ".
                                   "not compatible with the one declared in the format ".
                                   "description\nThe syntax sequence found is:\n";
            errorFound := true;
          end if;
          if errorFound then 
            giveSequenceSyntax !chunkList ;
          end if;
        end foreach;
      end foreach;
    end if;
  end foreach;
end routine;

routine setInstructionSequencesSyntaxForOneInstruction
  ?? @syntaxChunkListWithSuffix chunkList
  !  @lstringlist instructionSeq
  !  @stringset referenceSeq
:
  instructionSeq := [@lstringlist emptyList];
  referenceSeq := [@stringset emptySet];
  foreach chunkList (@syntaxChunk chunk @stringlist suffixList) do
    @string suffixInternal;
    @string suffixLog;
    getSuffixString !suffixList ?suffixLog ?suffixInternal;
    cast chunk
    when == @idfOrRefSyntaxIsIdf chunkIsIdf :
      @string temp := [[chunkIsIdf name] string]. suffixLog;
      @lstring ltemp := [@lstring new !temp ![[chunkIsIdf name] location]];
      instructionSeq += !ltemp; 
    when == @idfOrRefSyntaxIsRefDeclaration chunkIsDecRef :
      @string name := "#" . [[chunkIsDecRef name] string] . suffixLog;
      @lstring lname := [@lstring new ! name ![[chunkIsDecRef name] location]];
      @string refName := [[chunkIsDecRef name] string] . suffixInternal;

      instructionSeq += !lname;
      referenceSeq += !refName;
    else #error here : "internal error: neither ref nor syntax idf ?!";
    end cast;
  end foreach;
end routine;
#
## instructionSeqList -> for logs
## referenceSeqList -> internal use
routine setInstructionSequencesSyntax
  ?? @syntaxChunkListWithSuffixList instructionList  
  !  @syntaxLStringListList instructionSeqList
  !  @syntaxStringSetList  referenceSeqList
  #!  @syntaxInstructionMap InstMap 
:
  instructionSeqList := [@syntaxLStringListList emptyList];
  referenceSeqList   := [@syntaxStringSetList  emptyList];
  #InstMap := [@syntaxInstructionMap  emptyMap];
  foreach instructionList (@syntaxChunkListWithSuffix chunkList) do
    #one instruction
    @lstringlist instructionSeq;
    @stringset referenceSeq;

    setInstructionSequencesSyntaxForOneInstruction !chunkList ?instructionSeq ?referenceSeq;
    
    instructionSeqList += !instructionSeq;
    referenceSeqList += !referenceSeq;
  end foreach;
end routine;
#
#used only in the syntax log.
routine printFieldName 
  ?? @syntaxMap syntaxMap
  ?? @syntaxChunkListWithSuffix chunkList 
  ?! @string file
:
  @bool print := true; 
  foreach chunkList (@syntaxChunk chunk *) do
    #get the fieldMap
   @varMap fieldMap;
    cast chunk
    when == @idfOrRefSyntaxIsIdf chunkIsIdf :
      @syntaxBody syntaxBody;
      [syntaxMap searchKey ![chunkIsIdf name] ?syntaxBody];
      fieldMap := [syntaxBody fieldMap];
    else fieldMap := [@varMap emptyMap];
    end cast;
    if [fieldMap count] != 0 then 
      if print then
        file .= "\tdata field(s): ";
        print := false;
      else file .= "\t               ";
      end if;
      @bool start := true;
      foreach fieldMap (@lstring name @varAbstractType VATtype ...) do
        if not start then file .= "\t               "; end if;
        start := false;
        @varBaseType type := [VATtype getBaseType];
        file .= [name string]." (".[[type size] string]." bits)\n";
      end foreach;
    end if;
  end foreach;
end routine;

#generate the whole fieldmap 
#(without any suffix (@). This is useful for code generation).
function getSyntaxFieldMap
  ?? @syntaxMap syntaxMap
  ?? @syntaxChunkListWithSuffix chunkList
  -> @varMap fieldMapWithoutSuffix
:
  fieldMapWithoutSuffix := [@varMap emptyMap];
  foreach chunkList (@syntaxChunk chunk @stringlist suffixList) do
    cast chunk
    when == @idfOrRefSyntaxIsIdf chunkIsIdf :
      @syntaxBody syntaxBody;
      [syntaxMap searchKey ![chunkIsIdf name] ?syntaxBody];
      @varMap fieldMap := [syntaxBody fieldMap];
      #merge.
      foreach fieldMap do
        if not [fieldMapWithoutSuffix hasKey ![lkey string]] then
          @instDeclaration instDec := [@instDeclaration new ![lkey location] !type !lkey ![@varClass field] !""];  
          [!?fieldMapWithoutSuffix insertKey !lkey !type !constant !varClass !instDec];
        end if;
      end foreach;
    end cast;
  end foreach;
end function;

routine instructionSyntax
  ?? @syntaxMap syntaxMap
  ?? @syntaxChunkListWithSuffix chunkList
  ?? @printNumberTypeMap typeMap
  ?? @bool switchGenerate 
  ?! @string file1
  ?! @string file2
  ?! @string codeC
:
  @uint nbTabulation := 1;
  @varMap fieldMapWithoutSuffix := getSyntaxFieldMap[!syntaxMap !chunkList];
  foreach chunkList (@syntaxChunk chunk @stringlist suffixList) do
    @string currentSuffixStr;
    getSuffixString !suffixList ?* ?currentSuffixStr;
    if switchGenerate then
      file1 := "";
      file2 := "";
    end if;
    cast chunk
    when == @printChunk printChunk :
      @printInst printInst := [printChunk printInst];
      print !fieldMapWithoutSuffix !printInst !typeMap !currentSuffixStr !switchGenerate !?file1 !?file2;
      if switchGenerate then
        codeC .= "\tindex += sprintf (result + index,\"" . file1 . "\"" . file2 . ");\n";
      end if;
    when == @ifChunk ifChunk :
      [ifChunk printImplementation !fieldMapWithoutSuffix !nbTabulation !currentSuffixStr !?codeC !typeMap !switchGenerate]; 
    else 
    end cast; 
  end foreach;
  if not switchGenerate then
    file1 .= "\n"; 
  end if;
end routine;
           
###################################################################################################
### Tree generation related routines.
###################################################################################################

# there may have multiple roots in the syntax trees. The may root is implicitely declared as being an alternative of
# the roots of the sub-trees.
routine detectRootSyntaxs
  ?? @syntaxMap syntaxMap
  !  @syntaxMap rootSyntaxMap
:
  #a root syntax is a syntax that is never called by another one.
  rootSyntaxMap := syntaxMap;

  foreach syntaxMap (@lstring syntaxName @syntaxBody syntaxBody) do
    @syntaxChunkList chunkList := [syntaxBody chunkList];
    foreach chunkList (@syntaxChunk chunk) do
      cast chunk
      when == @idfOrRefSyntaxIsIdf chunkIsIdf :
        #ok. This syntax call another syntax (syntaxCallName). Consequently, syntaxCallName 
        #is not a root. Remove it from rootSyntaxMap (if it has not been removed before.)
        if [rootSyntaxMap hasKey ![[chunkIsIdf name] string]] then
          [!?rootSyntaxMap removeKey ![chunkIsIdf name] ?*];
        end if;
      else
      end cast;
    end foreach;
  end foreach;
end routine;


routine isThereACorrespondingFormat
  ?? @syntaxChunkListWithSuffix instructionSyntaxList #current syntax list
  ?? @lstring modelName
  ?? @instructionImplementationMap impMap
  !  @bool ok
:
  #get the reference sequence.
  @stringset referenceSeq;
  setInstructionSequencesSyntaxForOneInstruction !instructionSyntaxList ?* ?referenceSeq;
  #get the name of the instruction
  @string instName := getInstructionName[!referenceSeq ![modelName string]];
  ok := [impMap hasKey !instName];
end routine;

#recursive routine.
routine constructSyntaxInstructionTreeRec
  ?? @syntaxMap                     syntaxMap             #syntax map -> constant
  ?? @syntaxChunkListWithSuffix     syntaxListToCompute   #syntaxes not yet taken into account
  ?? @syntaxChunkListWithSuffix     instructionSyntaxList #current syntax list
  ?? @lstring modelName #used to check that there is a corresponding format
  ?? @instructionImplementationMap impMap #used to check that there is a corresponding format
  ?! @syntaxChunkListWithSuffixList instructionList       #output list of syntax list.
  ?! @uint nbInstEvaluated
:

  if [syntaxListToCompute length] > 0 then
    #something to do..
    @syntaxChunkListWithSuffix newSyntaxListToCompute := syntaxListToCompute;
    @syntaxChunk currentSyntax;
    @stringlist currentSuffixList;
    [!?newSyntaxListToCompute popFirst ?currentSyntax ?currentSuffixList];
    @syntaxChunkListWithSuffix newInstructionSyntaxList := instructionSyntaxList;

    #update suffix.
    cast currentSyntax
    when == @idfOrRefSyntaxIsIdf currentSyntaxIsIdf :
      #get suffix.
      @string suffixStr := [[currentSyntaxIsIdf postRefName] string];
      if [suffixStr length] > 0 then
        currentSuffixList += !suffixStr;
      end if;
    else
    end cast;

    newInstructionSyntaxList += !currentSyntax !currentSuffixList;

    cast currentSyntax
    when == @idfOrRefSyntaxIsIdf currentSyntaxIsIdf :
      #idf -> other syntax (alternative or aggregate)
      @syntaxBody syntaxBody;
      #check that the syntax is declared for agg and alt.
      [syntaxMap searchKey ![currentSyntaxIsIdf name] ?syntaxBody];
      cast syntaxBody
      when == @aggSyntax :
        #########    aggregate syntax    ########## 
        @syntaxChunkList chunkInBodyList := [syntaxBody chunkList];
        @syntaxChunkListWithSuffix syntaxListToComputeUpdated [emptyList];
        foreach chunkInBodyList (@syntaxChunk chunk) do
          syntaxListToComputeUpdated += !chunk !currentSuffixList;
        end foreach;
        syntaxListToComputeUpdated := syntaxListToComputeUpdated . newSyntaxListToCompute;
        #newSyntaxListToCompute := [syntaxBody chunkList] . newSyntaxListToCompute;
        constructSyntaxInstructionTreeRec !syntaxMap !syntaxListToComputeUpdated !newInstructionSyntaxList !modelName !impMap !?instructionList !?nbInstEvaluated;
      when == @altSyntax :
        ##########    alternative syntax    ##########
        @syntaxChunkList chunkList := [syntaxBody chunkList];
        @uint currentCallToFind := 0;
        loop [chunkList length]:
        while currentCallToFind < [chunkList length] do
          @bool callFound := false;
          @syntaxChunkListWithSuffix tempList [emptyList];
          @uint currentChunkId := 0;
          foreach chunkList (@syntaxChunk chunk) do
            cast chunk
            when == @idfOrRefSyntaxIsRefDeclaration :
              #if currentChunkId == currentCallToFind then break; end if;
              tempList += !chunk !currentSuffixList;
            when == @printChunk :
              #if currentChunkId == currentCallToFind then break; end if;
              tempList += !chunk !currentSuffixList;
            else #this is either a ref, or a call to an agg or an alt.
              if currentChunkId == currentCallToFind then
                tempList += !chunk !currentSuffixList;
                callFound := true;
              end if;
            end cast;
            currentChunkId := currentChunkId + 1;
          end foreach;
          if callFound then
            @syntaxChunkListWithSuffix newSyntaxListToComputeCopy := tempList . newSyntaxListToCompute ;
            constructSyntaxInstructionTreeRec !syntaxMap !newSyntaxListToComputeCopy !newInstructionSyntaxList !modelName !impMap !?instructionList !?nbInstEvaluated;
          end if;
          currentCallToFind := currentCallToFind + 1;
        end loop;
      else error here : "internal error: neither aggregate nor alternative syntax ?!";
      end cast;
    else 
      ##########    reference or declaration ref or print chunk ##########    
      constructSyntaxInstructionTreeRec !syntaxMap !newSyntaxListToCompute !newInstructionSyntaxList !modelName !impMap !?instructionList !?nbInstEvaluated;
    end cast;
  else #no more chunks in the list. This is a leaf.
    #We have the '@syntaxChunkListWithSuffix' of the new instruction. We have to check 
    #that there is a corresponding format.
    @bool ok;
    isThereACorrespondingFormat !instructionSyntaxList !modelName !impMap ?ok;
    if ok then
      instructionList += !instructionSyntaxList;
    end if;
    nbInstEvaluated := nbInstEvaluated + 1;
  end if;
end routine;

routine constructSyntaxInstructionTree
  ?? @syntaxMap syntaxMap
  ?? @lstring modelName #used to check that there is a corresponding format
  ?? @instructionImplementationMap impMap #used to check that there is a corresponding format
  !  @syntaxChunkListWithSuffixList decodedInstructionList 
:
  if [option .verbose_output value] then
    message "contructing syntax tree...";
  end if;

  decodedInstructionList := [@syntaxChunkListWithSuffixList emptyList];
  @syntaxChunkListWithSuffix syntaxList [emptyList];
  @uint nbInstructionAccumulated := 0;

  #get root syntaxs. (may have many sub-trees).
  @syntaxMap rootSyntaxMap;
  detectRootSyntaxs !syntaxMap ?rootSyntaxMap;

  foreach rootSyntaxMap (@lstring rootSyntaxName *) do
    if [option .verbose_output value] then
      message "\n\tfrom root ".[rootSyntaxName string]."...";
    end if;
    @lstring emptyLString := [@lstring new !"" !here];
    @idfOrRefSyntaxIsIdf startSyntax := [@idfOrRefSyntaxIsIdf new !rootSyntaxName !emptyLString];
    @syntaxChunkListWithSuffix syntaxListToCompute [emptyList];
    @stringlist emptyStringList [emptyList];
    syntaxListToCompute += !startSyntax !emptyStringList;
    @uint nbInstEvaluated := 0;
    constructSyntaxInstructionTreeRec !syntaxMap !syntaxListToCompute !syntaxList !modelName !impMap !?decodedInstructionList !?nbInstEvaluated;
    if [option .verbose_output value] then
      @uint temp := [decodedInstructionList length] - nbInstructionAccumulated;
      message [temp string]." instruction";
      if temp > 1 then message "s"; end if;
      nbInstructionAccumulated := [decodedInstructionList length];
      message " from ".[nbInstEvaluated string]." branch";
      if nbInstEvaluated > 1 then message "es."; else message "."; end if;
    end if;
  end foreach;
  if [option .verbose_output value] then
    message "\nFound a total of ".[[decodedInstructionList length] string]." instructions syntaxes.\n";
  end if;
end routine;

routine generateSyntaxImplementationFiles
  ?? @syntaxMap syntaxMap
  ?? @string modelName
  ?? @syntaxChunkListWithSuffixList instructionList
  ?! @TfieldMap templateStruct
  ?? @printNumberTypeMap typeMap
  ?? @instructionImplementationMap impMap
:
  @TfieldMapList instMnemoTpl [emptyList];
  @string noMnemoCode := ""; #for instructions that have a format
  @boolMap instNameMap [emptyMap]; #store instruction names of instruction that have a memo.
  @syntaxLStringListList instructionSeqList;
  @syntaxStringSetList  referenceSeqList;
  @string mnemoFileStr := ""; #get mnemo files (for Makefile).
  setInstructionSequencesSyntax !instructionList ?instructionSeqList ?referenceSeqList;
  @uint i := 0; #loop var
  @uint nbFiles := 0;
  foreach instructionList (@syntaxChunkListWithSuffix chunkList), referenceSeqList (@stringset refSet) do
    @TfieldMap instMnemoTplBody [emptyMap];
    @string functionName := modelName;
    @string instName := getInstructionName[!refSet !modelName];

    #first check that the instruction extracted from syntax was declared in the format part.
    if [impMap hasKey !instName] then
      foreach refSet (@string ref) do
        functionName .= "_" . ref;
      end foreach;
      addStringValue !?instMnemoTplBody !lstringWith[!"name"] !instName;
      [!?instNameMap insertKey ![@lstring new !functionName !here]];
      @string codeC := "\tchar *result = new char[128];\n";
      codeC .= "\tint index = 0;\n";
      @string file1 := "";
      @string file2 := "";
      instructionSyntax !syntaxMap !chunkList !typeMap !true !?file1 !?file2 !?codeC;
      codeC .= "\t#ifdef DEBUG_MNEMO\n";
      codeC .= "\t\tindex += sprintf (result + index, \" (".functionName.")\");\n";
      codeC .= "\t#endif\n";
      codeC .= "\treturn result;\n";
      addStringValue !?instMnemoTplBody !lstringWith[!"mnemo"] !codeC;
    end if;
    instMnemoTpl += !instMnemoTplBody;
  end foreach;
  addListValue   !?templateStruct !lstringWith[!"instMnemoList"] !instMnemoTpl;
end routine;

routine instructionSyntaxPart 
  ?? @lstring modelName
  ?? @syntaxMap syntaxMap 
  ?? @instructionImplementationMap impMap
  ?! @TfieldMap templateStruct
  ?? @printNumberTypeMap typeMap
:
  if not [option gadl_options.noDesassemble value] then
    checkSyntaxArgs !syntaxMap;
    @syntaxChunkListWithSuffixList decodedSyntaxInstructionList;
    @syntaxStringSetList  referenceSeqList; #-> for internal use
    constructSyntaxInstructionTree !syntaxMap !modelName !impMap ?decodedSyntaxInstructionList;
    @syntaxLStringListList instructionSeqList; #-> for logs and eror messages
    setInstructionSequencesSyntax !decodedSyntaxInstructionList ?instructionSeqList ?referenceSeqList;
    @bool noError;
    checkSyntaxInstructionWithFormatCompatibility !syntaxMap !decodedSyntaxInstructionList !impMap !instructionSeqList !referenceSeqList !modelName ?noError;
    if noError then
      generateSyntaxImplementationFiles !syntaxMap ![modelName string] !decodedSyntaxInstructionList !?templateStruct !typeMap !impMap;
    end if;
  end if;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
