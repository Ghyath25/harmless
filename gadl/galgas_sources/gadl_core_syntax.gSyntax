syntax gadl_core_syntax ("gadl_lexique.gLexique") :
import "gadl_options.gOption" ;
import "gadl_core.gSemantics";
import "gadl_memory.gSemantics";
import "gadl_isa.gSemantics";
import "gadl_isa_grammar.gGrammar";
import "gadl_varIdfStruct.gSemantics"; #lstringMap
import "gadl_peripheral_grammar.gGrammar";

nonterminal <memoryChunk>
  ?! @ASTmemoryParamMap ASTmemChunk 
  ?! @stringlist memChunkOrder
;
nonterminal <memorySpace> ?! @ASTmemSpaceMap ASTmemSpaceMap;
nonterminal  <architecture> ?! @architectureMap archMap;
#for constructor.
nonterminal <typeDeclaration> ! @varAbstractType type;
#from gadl_function_parser
#not the outType and functionName in the rule due to grammar LL1 restrictions.
nonterminal <functionDef> 
  ?? @varAbstractType outType
  ?? @lstring functionName
  ?! @ASTFunctionMap ASTFunctionMap
;

#pipeline
nonterminal  <pipeline> 
  ?? @architectureMap architectureMap
  ?! @pipelineMap pipelineMap
;

#assembly of global pipeline
nonterminal <machine>
  ?! @machineMap machineMap
  ?? @pipelineMap pipelineMap
;

nonterminal <import>
  ?? @bool fromCPU
  ?! @lstringMap importCoreMap
  ?! @lstringMap importIsaMap
  ?! @ASTperipheralMap ASTperipheralMap
;

nonterminal <deviceDeclaration>
  ?? @bool memoryAccessIsLocal #true if a device is declared inside a peripheral (same mem chunk).
  ?? @ASTperipheralMap ASTperipheralMap
  !  @ASTInstDeclarationDevice deviceDec
;

#called from a cpu part.
rule <core> 
  ?! @ASTCoreMap ASTcoreMap
  ?! @ASTmemSpaceMap ASTmemSpaceMap
:
  #memory stuff
  @ASTmemoryParamMap ASTmemChunk [emptyMap];
  @stringlist memChunkOrder [emptyList];
  #importing isa
  @lstringMap importIsaMap [emptyMap];
  #peripherals
  @ASTperipheralMap ASTperipheralMap [emptyMap];
 
  repeat
  while
    #local mem space definition.
    <memorySpace> !?ASTmemSpaceMap;
  while
    #ISA or periph importation
    @lstringMap importCoreMap [emptyMap]; #unused.
    <import> !false !?importCoreMap !?importIsaMap !?ASTperipheralMap;
  end repeat;

  $core$; $idf$ ?@lstring coreName;
  $:$; $isa$; $idf$ ?@lstring isaNameInCore;
  [importIsaMap searchKey !isaNameInCore ?@lstring isaFileName];
  grammar gadl_isa_grammar in isaFileName ??@ASTIsa ASTIsa;
  ${$;
    <coreBody> !?ASTmemChunk !?memChunkOrder ?@architectureMap archMap ?@pipelineMap pipelineMap ?@machineMap machineMap ?@ASTFunctionMap ASTCoreConstructorMap ?@ASTInstructionList ASTDeviceDecList !coreName !ASTperipheralMap;
  $}$;
  [!?ASTcoreMap insertKey !coreName !ASTIsa !ASTmemChunk !memChunkOrder !archMap !pipelineMap !machineMap !ASTCoreConstructorMap !ASTDeviceDecList];
end rule ;

rule <coreBody>
  ?! @ASTmemoryParamMap ASTmemChunk
  ?! @stringlist memChunkOrder
  !  @architectureMap archMap
  !  @pipelineMap pipelineMap
  !  @machineMap machineMap
  !  @ASTFunctionMap ASTCoreConstructorMap
  !  @ASTInstructionList ASTDeviceDecList
  ?? @lstring coreName
  ?? @ASTperipheralMap ASTperipheralMap
:
  archMap := [@architectureMap emptyMap];
  pipelineMap := [@pipelineMap emptyMap];
  machineMap := [@machineMap emptyMap];
  ASTCoreConstructorMap := [@ASTFunctionMap emptyMap];
  #core internal devices.
  ASTDeviceDecList := [@ASTInstructionList emptyList];
  repeat
  while
    <memoryChunk> !?ASTmemChunk !?memChunkOrder;
  while
    <architecture> !?archMap;
  while
    <pipeline> !archMap !?pipelineMap;
  while
    <machine> !?machineMap !pipelineMap;
  while #constructor.
    <typeDeclaration> ?@varAbstractType type;
    if not [type isVoid] then #should return void
      error here: "The core constructor should return void";
    end if;
    $idf$ ?@lstring idf;
    if [idf string] != [coreName string] then
      error idf: "the constructor should have the same name than the core :".[coreName string];
    end if;
    <functionDef> !type !idf !?ASTCoreConstructorMap;
  while
    <deviceDeclaration> !false !ASTperipheralMap ?@ASTInstDeclarationDevice deviceDec;
    ASTDeviceDecList += !deviceDec;
  end repeat;
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
