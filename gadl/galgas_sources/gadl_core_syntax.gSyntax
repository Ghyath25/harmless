syntax gadl_core_syntax ("gadl_lexique.gLexique") :
import "gadl_options.gOption" ;
import "gadl_memory.gSemantics";
import "gadl_isa.gSemantics";
import "gadl_isa_grammar.gGrammar";
import "gadl_varIdfStruct.gSemantics"; #lstringMap
import "gadl_core.gSemantics";

nonterminal <memoryChunk>
  ?! @ASTmemoryParamMap ASTmemChunk 
  ?! @stringlist memChunkOrder
;
nonterminal <memorySpace> ?! @ASTmemSpaceMap ASTmemSpaceMap;
nonterminal  <architecture> ?! @architectureMap archMap;
#for constructor.
nonterminal <typeDeclaration> ! @varAbstractType type;
#from gadl_function_parser
#not the outType and functionName in the rule due to grammar LL1 restrictions.
nonterminal <functionDef> 
  ?? @varAbstractType outType
  ?? @lstring functionName
  ?! @ASTFunctionMap ASTFunctionMap
;

#pipeline
nonterminal  <pipeline> 
  ?? @architectureMap architectureMap
  ?! @pipelineMap pipelineMap
;

#assembly of global pipeline
nonterminal <machine>
  ?! @machineMap machineMap
  ?? @pipelineMap pipelineMap
;

rule <importIsa>
  ?!@lstringMap importIsaMap
:
  $import$; $isa$;
  $idf$ ?@lstring isaName;
  $from$;
  $caracterStr$ ?@lstring srcFile;  
  [!?importIsaMap insertKey !isaName !srcFile];
end rule;

rule <core> :
  @ASTCoreMap ASTcoreMap [emptyMap];
  #memory stuff
  @ASTmemoryParamMap ASTmemChunk [emptyMap];
  @stringlist memChunkOrder [emptyList];
  #importing isa
  @lstringMap importIsaMap [emptyMap];
  @ASTmemSpaceMap ASTmemSpaceMap [emptyMap];
 
  repeat
  while
    #mem space definition.
    <memorySpace> !?ASTmemSpaceMap;
  while
    #ISA importation
    <importIsa> !?importIsaMap;
  end repeat;

  $core$; $idf$ ?@lstring coreName;
  $:$; $isa$; $idf$ ?@lstring isaNameInCore;
  [importIsaMap searchKey !isaNameInCore ?@lstring isaFileName];
  grammar gadl_isa_grammar in isaFileName ??@ASTIsa ASTIsa;
  ${$;
    <coreBody> !?ASTmemChunk !?memChunkOrder ?@architectureMap archMap ?@pipelineMap pipelineMap ?@machineMap machineMap ?@ASTFunctionMap ASTCoreConstructorMap !coreName;
  $}$;
  #Ok. Parsing done. Now apply semantic.

  [!?ASTcoreMap insertKey !coreName !ASTIsa !ASTmemChunk !memChunkOrder !archMap !pipelineMap !machineMap !ASTCoreConstructorMap];

  #do the job.
  @memSpaceMap memSpaceMap := [ASTmemSpaceMap getMemSpaceMap];
  [ASTcoreMap coreSemantic !coreName !coreName !memSpaceMap];
  #[memSpaceMap setInTemplate !?templateStruct];

  #coreSemantic !coreName !ASTIsa !ASTmemChunk !memChunkOrder !ASTmemSpaceMap !archMap !pipelineMap !machineMap !ASTCoreConstructorMap;
end rule ;

rule <coreBody>
  ?! @ASTmemoryParamMap ASTmemChunk
  ?! @stringlist memChunkOrder
  !  @architectureMap archMap
  !  @pipelineMap pipelineMap
  !  @machineMap machineMap
  !  @ASTFunctionMap ASTCoreConstructorMap
  ?? @lstring coreName
:
  archMap := [@architectureMap emptyMap];
  pipelineMap := [@pipelineMap emptyMap];
  machineMap := [@machineMap emptyMap];
  ASTCoreConstructorMap := [@ASTFunctionMap emptyMap];
  repeat
  while
    <memoryChunk> !?ASTmemChunk !?memChunkOrder;
  while
    <architecture> !?archMap;
  while
    <pipeline> !archMap !?pipelineMap;
  while
    <machine> !?machineMap !pipelineMap;
  while #constructor.
    <typeDeclaration> ?@varAbstractType type;
    if not [type isVoid] then #should return void
      error here: "The core constructor should return void";
    end if;
    $idf$ ?@lstring idf;
    if [idf string] != [coreName string] then
      error idf: "the constructor should have the same name than the core :".[coreName string];
    end if;
    <functionDef> !type !idf !?ASTCoreConstructorMap;
  end repeat;
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
