syntax gadl_peripheral_parser ("gadl_lexique.gLexique") :
  import "gadl_peripheral_AST.gSemantics" ;
  import "gadl_variable.gSemantics" ; #varClass.
  import "gadl_semantics_AST_implementation.gSemantics" ; #varClass.
  import "gadl_semantics_function.gSemantics";
  import "gadl_semantics_AST_implementation.gSemantics"; #memoryMapping

#from gadl_implementation_parser.gSyntax
nonterminal <typeDefinition> ?! @ASTInstructionList instList;
nonterminal <typeDeclaration> ! @varAbstractType type;
nonterminal <registerBitAccessDef>
  ?? @lstring regName
  ?? @varAbstractType type
  ?! @ASTInstructionList ASTregDefList
;
nonterminal <memoryMapping>
  ! @memoryMapping memoryMapping
;

#from gadl_function_parser
#not the outType and functionName in the rule due to grammar LL1 restrictions.
nonterminal <functionDef> 
  ?? @varAbstractType outType
  ?? @lstring functionName
  ?! @ASTFunctionMap ASTFunctionMap
;

#registers as defined in peripherals.
rule <registerPeriphDef>
  ?! @ASTregisterPeriphDefMap ASTregDefMap
:
  @ASTInstructionList ASTregDecList [emptyList];
  $register$;
  <typeDeclaration> ?@varAbstractType type;
  $idf$ ?@lstring idf;
  $maps$; $to$; $unumber$ ?@luint64 address;
  ASTregDecList += ![@ASTInstDeclaration new !here ![@varClass SFR] !type !idf];
  select
  or
    <registerBitAccessDef> !idf !type !?ASTregDecList;
  end select;
  #is there a callBack?
  @bool hasReadFuncCall := false;
  @bool hasWriteFuncCall := false;
  @lstring readFuncCall := [@lstring new !"" !here];
  @lstring writeFuncCall := [@lstring new !"" !here];
  repeat
  while
    if hasReadFuncCall then
      error here: "A function has already been declared for the read access";
    end if;
    $read$; $is$; $idf$? readFuncCall;
    hasReadFuncCall := true;
  while
    if hasWriteFuncCall then
      error here: "A function has already been declared for the write access";
    end if;
    $write$; $is$; $idf$? writeFuncCall;
    hasWriteFuncCall := true;
  end repeat;
  [!?ASTregDefMap insertKey !idf !ASTregDecList !address !readFuncCall !writeFuncCall !type];
end rule;

rule <deviceDeclaration>
  ?? @bool memoryAccessIsLocal #true if a device is declared inside a peripheral (same mem chunk).
  ?? @ASTperipheralMap ASTperipheralMap
  !  @ASTInstDeclarationDevice deviceDec
:
  @varAbstractType type;
  $device$; $idf$ ?@lstring deviceType;
  [ASTperipheralMap searchKey !deviceType ?* ?* ?* ?* ?* ?* ?*]; #check that peripheral is defined.
  @varAbstractType typeBase := [@varDeviceType new ![@varKind custom] !deviceType];
  select #code extracted from rule <typeDeclaration>
    @luint64 tabLength;
    $[$; $unumber$ ?tabLength; $]$;
    type := [@varTabularType new ![@varKind tabular] !typeBase ![tabLength uint]];
  or
    type := typeBase;
  end select;
  $idf$ ?@lstring deviceName;
  $maps$; $to$; 
  @memoryMapping memoryMapping;
  select
    $unumber$ ?@luint64 address;
    memoryMapping := [@memoryMapping new ![@lstring new !"__local" !here] !address];
    if not memoryAccessIsLocal then
      error here: "The device declaration is not local. The memory space should be given: mem:\\x..";
    end if;
  or
    <memoryMapping> ?memoryMapping;
    if memoryAccessIsLocal then
      error here: "The device declaration is local. Only the memory address should be given (no memory space name).";
    end if;
  end select;
  deviceDec := [@ASTInstDeclarationDevice new !here ![@varClass device] !type !deviceName !memoryMapping];
end rule;

rule <peripheral>
  ?! @ASTperipheralMap ASTperipheralMap
:
  @ASTregisterPeriphDefMap ASTregDefMap [emptyMap];
  @ASTFunctionMap ASTFunctionMap [emptyMap];
  @ASTInstructionList ASTDeviceDecList [emptyList];
  @ASTInstructionList ASTTypeDefList [emptyList];
  @ASTInstructionList ASTLocalVarList [emptyList];
  $peripheral$;
  $idf$ ?@lstring peripheralName;
  $memory$; $size$; $unumber$ ?@luint64 lsize;
  ${$;
    repeat
    while
      #register def
      <registerPeriphDef> !?ASTregDefMap;
    while
      <typeDeclaration> ?@varAbstractType type;
      $idf$ ?@lstring idf;
      select
        #this is a local var.
        ASTLocalVarList += ![@ASTInstDeclaration new !here ![@varClass localVar] !type !idf];  
      or
        #this is a local method.
        <functionDef> !type !idf !?ASTFunctionMap;
      end select;
    while
      <deviceDeclaration> !true !ASTperipheralMap ?@ASTInstDeclarationDevice deviceDec;
      ASTDeviceDecList += !deviceDec;
    while
      <typeDefinition> !? ASTTypeDefList;
    end repeat;
  $}$;
  #problem:
  #We need a varMap for register slices access (in other peripherals)
  #and ASTperipheralMap (embedded in the idfStruct) does not have it.
  #-> we extract it here from the registers definitions.  
  @expressionContext ctx := [@expressionContext peripheral];
  @symbolValueMap symbolMap [emptyMap];
  @varIdfStruct idfStruct [default];
  foreach ASTregDefMap do
    getInst !ASTregDecList !ctx !symbolMap !?idfStruct ?*;
  end foreach;
  [!?ASTperipheralMap insertKey !peripheralName !lsize !ASTregDefMap !ASTFunctionMap !ASTDeviceDecList !ASTTypeDefList !ASTLocalVarList !idfStruct->varMap];

end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
