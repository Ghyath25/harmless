syntax gadl_peripheral_parser ("gadl_lexique.gLexique") :
  import "gadl_peripheral_AST.gSemantics" ;
  import "gadl_variable.gSemantics" ; #varClass.
  import "gadl_semantics_AST_implementation.gSemantics" ; #varClass.
  import "gadl_semantics_function.gSemantics" ;  

nonterminal <typeDeclaration> ! @varAbstractType type;
nonterminal <registerBitAccessDef>
  ?? @lstring regName
  ?? @varAbstractType type
  ?! @ASTInstructionList ASTregDefList
;

#from gadl_function_parser
#not the outType and functionName in the rule due to grammar LL1 restrictions.
nonterminal <functionDef> 
  ?? @varAbstractType outType
  ?? @lstring functionName
  ?! @ASTFunctionMap ASTFunctionMap
;

#registers as defined in peripherals.
rule <registerPeriphDef>
  ?! @ASTregisterPeriphDefMap ASTregDefMap
:
  @ASTInstructionList ASTregDecList [emptyList];
  $register$;
  <typeDeclaration> ?@varAbstractType type;
  $idf$ ?@lstring idf;
  $maps$; $to$; $unumber$ ?@luint64 address;
  ASTregDecList += ![@ASTInstDeclaration new !here ![@varClass SFR] !type !idf];
  select
  or
    <registerBitAccessDef> !idf !type !?ASTregDecList;
  end select;
  #is there a callBack?
  @bool hasReadFuncCall := false;
  @bool hasWriteFuncCall := false;
  @lstring readFuncCall := [@lstring new !"" !here];
  @lstring writeFuncCall := [@lstring new !"" !here];
  repeat
  while
    if hasReadFuncCall then
      error here: "A function has already been declared for the read access";
    end if;
    $read$; $is$; $idf$? readFuncCall;
    hasReadFuncCall := true;
  while
    if hasWriteFuncCall then
      error here: "A function has already been declared for the read access";
    end if;
    $write$; $is$; $idf$? writeFuncCall;
    hasWriteFuncCall := true;
  end repeat;
  [!?ASTregDefMap insertKey !idf !ASTregDecList !address !readFuncCall !writeFuncCall !type];
end rule;

rule <deviceDeclaration>
  ! @varAbstractType type
:
  $device$; $idf$ ?@lstring deviceType;
  @varAbstractType typeBase := [@varDeviceType new ![@varKind custom] !deviceType];
  select #code extracted from rule <typeDeclaration>
    @luint64 tabLength;
    $[$; $unumber$ ?tabLength; $]$;
    type := [@varTabularType new ![@varKind tabular] !typeBase ![tabLength uint]];
  or
    type := typeBase;
  end select;
end rule;

rule <peripheral>
  ?! @ASTperipheralMap ASTperipheralMap
:
  @ASTregisterPeriphDefMap ASTregDefMap [emptyMap];
  @ASTFunctionMap ASTFunctionMap [emptyMap];
  @ASTInstructionList ASTDeviceDecList [emptyList];

  $peripheral$;
  $idf$ ?@lstring peripheralName;
  $memory$; $size$; $unumber$ ?@luint64 lsize;
  ${$;
    repeat
    while
      #register def
      <registerPeriphDef> !?ASTregDefMap;
    while
      <typeDeclaration> ?@varAbstractType type;
      $idf$ ?@lstring idf;
      <functionDef> !type !idf !?ASTFunctionMap;
    while
      <deviceDeclaration> ? @varAbstractType deviceType;
      $idf$ ?@lstring deviceName;
      $maps$; $to$;  $unumber$ ?@luint64 address;
      ASTDeviceDecList += ![@ASTInstDeclarationDevice new !here ![@varClass device] !deviceType !deviceName !address];
    end repeat;
  $}$;
  [!?ASTperipheralMap insertKey !peripheralName !lsize !ASTregDefMap !ASTFunctionMap !ASTDeviceDecList];
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
