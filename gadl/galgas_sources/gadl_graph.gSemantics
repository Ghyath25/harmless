semantics gadl_graph:

list @graphNodeList {
  @graphNode node;
}
struct @graphNode
{
  @lstringlist data;
  @graphNodeList nextNodeList;
  @string uid; #unique id.
}

#this function is used to generate the Unique Id:
#this is the concatenation of the current node id
#and the ids of sub nodes.
function getGraphNodeUniqueId
  ?? @string currentNodeId
  ?? @graphNodeList nextNodeList
  -> @string uid
:
  uid := currentNodeId;
  foreach nextNodeList (@graphNode item) do 
    uid .= "_".[item uid];
  end foreach;
end function;

#merge graph node lists, but first
#verify that a node with the same uid 
#is not present.
routine MergeGraphNodeList
  !  @graphNodeList mergeList
  ?? @graphNodeList list1
  ?? @graphNodeList list2
:
  mergeList := list1;
  foreach list2 (@graphNode item2) do
    @bool found := false;
    foreach list1 (@graphNode item1) while not found do
      found := [item2 uid] == [item1 uid];
    end foreach;
    if not found then
      mergeList += !item2;
    end if;
  end foreach;
end routine;

#data structure to store the one graph for each instruction.
map @graphNodeMap {
  @graphNode nodeRoot;
  insert insertKey error message "the '%K' instruction has already its graph defined in %L" ; 
  search searchKey error message "the '%K' instruction has no graph defined" ;
}

#get the string from the lstringlist data member, fields are '.' separated.
function getGraphDataString
 ?? @lstringlist data
 -> @string out
:
  out := "";
  foreach data (@lstring str) do
    out .= [str string];
  between
    out .= ".";
  end foreach;
end function;

#recursive part of the output of the graph (graphViz format).
#This routine is called only by 'graphNodeOutput' function.
routine graphNodeOutputRec
  ?? @graphNode node
  ?! @string out
  ?! @stringset duplicateSet
:
  @graphNodeList nextNodeList := [node nextNodeList];
  foreach nextNodeList (@graphNode next) do
#    message "data str : ".getGraphDataString[![next data]]."\n";
    #declare next node.
    @string nodeDeclaration := "\"".[next uid]."\" [ label = \"".getGraphDataString[![next data]]."\" ];";
    if not [duplicateSet hasKey !nodeDeclaration] then
      out .= nodeDeclaration."\n";
      duplicateSet += !nodeDeclaration;
    end if;
    #make the link;
    @string link := "\"".[node uid]."\" -> \"".[next uid]."\"";
    if not [duplicateSet hasKey !link] then
      out .= link."\n";
      duplicateSet += !link;
    end if;
    #explore subnodes;
    graphNodeOutputRec !next !?out !?duplicateSet;
  end foreach;
end routine;

#output the graph starting from root 'node' in the graphViz format.
#Ok. Tested.
function graphNodeOutput
  ?? @graphNode node
  ?? @string graphName
  ->  @string out
:
  #2 nodes may have the same name, so we have to distinguish them.
  out := "digraph ".graphName." {\n";
  out .= "size = \"3,4\";\n"; #x, y in inches
  out .= "node [shape=box];\n";
  #declare first node
  out .= "\"".[node uid]."\" [ label = \"".getGraphDataString[![node data]]."\" ] ;\n";
  #recursive call to generate the graph (depth)
  @stringset duplicateSet [emptySet]; #used to remove duplicates.
  graphNodeOutputRec !node !?out !?duplicateSet;
  #epilog
  out .= "}\n";
end function;

#test routine (for graphViz export). It create a graph with A, B, C, D, E and F.
# A gets B and C sub-nodes
# B gets D, E
# D, E and C -> F.
routine testGraph
:
  @graphNode nA := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList]  !"0"];
  @graphNode nB := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList]  !"1"];
  @graphNode nC := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList]  !"2"];
  @graphNode nD := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList]  !"1"];
  @graphNode nE := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList]  !"1"];
  @graphNode nF := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList]  !"1"];

  nA->data += ![@lstring new !"A" !here];
  nB->data += ![@lstring new !"B" !here];
  nC->data += ![@lstring new !"C" !here];
  nD->data += ![@lstring new !"D" !here];
  nE->data += ![@lstring new !"E" !here];
  nF->data += ![@lstring new !"F" !here];

  nD->nextNodeList += !nF;
  nE->nextNodeList += !nF;
  nC->nextNodeList += !nF;
  nB->nextNodeList += !nD;
  nB->nextNodeList += !nE;
  nA->nextNodeList += !nC;
  nA->nextNodeList += !nB;

  @string str := graphNodeOutput[!nA !"testGraph"];
  [str writeToFile !"testGraph.dot"];
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
