semantics gadl_semantics_detect_branch:
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_function.gSemantics" ;  #cReturn 
  import "gadl_components.gSemantics" ;#cCompMethodCall
  import "gadl_semantics_behavior.gSemantics";
##################################################################
## This method:
## * detect if PC can be modified (i.e. is it a branch instruction?)
## * generate the code (instructionList) to calculate the branch Target.
## It should go inside components'method code
## if there is a condition ('if'), then there are different cases:
##   * the evaluation of the condition is const -> unconditional branch -> no pb.
##   * only one branch can modifiy the PC -> conditional branch. 
##     We only take the branch that updates PC.
##   * 2 branch modify PC. With is an unknown behavior 
##     -> impossible to detect statically.
##################################################################

routine logBranchInstMap
  ?? @branchInstMap branchInstMap
:
  foreach branchInstMap(@lstring instName @instructionList targetEvalInstList @bool noCond @bool unknownStaticTarget) do
    message "####################################################################\n";
    message "Instruction ".[instName string]." : ";
    if noCond then message "unconditionnal, "; else message "conditionnal, "; end if;
    if unknownStaticTarget then message "unkown target"; else message "target OK"; end if;
    if not unknownStaticTarget then
      message "##########################\n";
      message generateImplementation[!targetEvalInstList !1 !"" !"" ![@codeCtx C]];
    end if;
    message "####################################################################\n";
  end foreach;
end routine;

# this routine returns true, if the program counter can be 
# assigned by an instruction in instList. It also search in components
# that are either called directly, or into an expression.
# (check recursively of course).

function getBranchInstructions
  ?? @componentMap componentMap
  ?? @instructionListMap instListMap
  -> @branchInstMap branchInstMap
:
  branchInstMap := [@branchInstMap emptyMap];
  #for each instruction
  @uint nb := 0;
  foreach instListMap(@lstring instName @instructionList instList) do
    @instructionList targetEvalInstList [emptyList];
    @bool isABranch := false; #becomes true if PC may be written
    @bool noCond := true ; #is true if PC is always written (unconditional branch)
    @bool unknownStaticTarget := false; #become true if it can't be resolved statically (indirect branch for instance).
    @symbolValueMap symbolValueMap [emptyMap]; #stores value of symbol if they are constants.

    foreach instList (@cInstruction inst) while not isABranch do
      targetEvalInstList += !inst;
      [inst processBranchTarget !componentMap !?targetEvalInstList !?isABranch !?noCond !?unknownStaticTarget !?symbolValueMap];
    end foreach;

    if isABranch then
      [!?branchInstMap insertKey !instName !targetEvalInstList !noCond !unknownStaticTarget];
    end if;
  end foreach;
  #logBranchInstMap !branchInstMap;
end function;

abstract method @cInstruction processBranchTarget 
  ?? @componentMap componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool isABranch
  ?! @bool noCond
  ?! @bool unknownStaticTarget
  ?! @symbolValueMap symbolValueMap
;

override method @cDummy processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cInterruptInst processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cErrorInst processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cMessageInst processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cPrintInst processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cNopInst processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cInsertStall processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cAddCycleInst processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cTimingMethodAccessBlock processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cIfBlock processBranchTarget 
  ?? @componentMap componentMap 
  ?! @instructionList targetEvalInstList
  ?! @bool isABranch
  ?! @bool noCond
  ?! @bool unknownStaticTarget
  ?! @symbolValueMap symbolValueMap
:
  #first evaluate condition expression.
  @cExpression expEval := [condition eval !symbolValueMap];
  @bool expConst := false; #true if the expression is constant -> can be evaluated statically
  @bool expState := false; #result of the condition (usable only if expConst is true).
  cast expEval
    when == @cIntConst constVal :
      expConst := true;
      expState := ([constVal value] != 0L);
    else
  end cast;

  @bool isABranchIf := isABranch; #isABranch in 'if' instruction flow
  @bool isABranchElse := isABranch; #isABranch in 'else' instruction flow
  @instructionList targetEvalInstListIf [emptyList];
  @instructionList targetEvalInstListElse [emptyList];

  if not expConst | expState then #evaluated if condition is not const or if condition is true
    #TODO: variable allocation not taken into account in instruction if block.
    @symbolValueMap symbolValueMapIf := symbolValueMap;
    foreach ifInstList (@cInstruction inst) while not isABranchIf do
        targetEvalInstListIf += !inst;
        [inst processBranchTarget !componentMap !?targetEvalInstListIf !?isABranchIf !?noCond !?unknownStaticTarget !?symbolValueMapIf];
    end foreach ;
  end if;
  if not expConst | not expState then #evaluated if condition is not const or if condition is false
    @symbolValueMap symbolValueMapElse := symbolValueMap;
    foreach elseInstList (@cInstruction inst) while not isABranchElse do
        targetEvalInstListElse += !inst;
        [inst processBranchTarget !componentMap !?targetEvalInstListElse !?isABranchElse !?noCond !?unknownStaticTarget !?symbolValueMapElse];
    end foreach ;
  end if;

  #detect unconditional branches.
  if (not expConst) & (isABranchIf != isABranchElse) then
    #only one instruction list updated the PC. This is a conditional branch.
    noCond := false;
    isABranch := true; #as at least one instruction flow changed PC.
  else
    if expConst then
      if expState then isABranch := isABranchIf;
      else isABranch := isABranchElse;
      end if;
    else
      isABranch := isABranchIf; #as they are identical.
    end if;
  end if;
  #If the 2 branches change PC, the target can't be detected statically.
  if (not expConst) & isABranchIf==true & isABranchElse==true then
    unknownStaticTarget := true;
  end if;
  #update the targetEvalInstList to generate the code to detect the branch.
  if isABranch then
    if isABranchIf then
      targetEvalInstList := targetEvalInstList.targetEvalInstListIf;
    else
      targetEvalInstList := targetEvalInstList.targetEvalInstListElse;
    end if;
  end if;
end method;

override method @cDeclareVar processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cLoopBlock processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
  #TODO: does not explore inside a loop.
  ##search in instruction list.
  #foreach code (@cInstruction inst) while not isABranch do
  #    [inst processBranchTarget !componentMap !?targetEvalInstList !?isABranch !?noCond !?unknownStaticTarget !?symbolValueMapInComponent];
  #end foreach ;
end method;

#import "gadl_semantics_implementation_code_generation.gSemantics";

override method  @cAssign processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap symbolValueMap
:
  @uint id := 0;
  foreach leftPart (@cExpression expL ...) do
    cast expL
      when == @cIdf idf :
        cast [idf var]
          when == @registerVar reg :
            if [reg regType] == [@regType componentProgramCounter] |
              [reg regType] == [@regType memoryProgramCounter]    then #Program counter assigned.
              isABranch := true;
            end if;
          else
        end cast;
        if id == 0 then #only the first expression...
          #evaluate right exp.
          updateSymbolMap !?symbolValueMap ![idf idf] !exp;
        end if;
      else
    end cast;
    id := id + 1;
  end foreach;
end method;

override method @cReturn processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
end method;

override method @cAssignFunc processBranchTarget 
  ?? @componentMap unused componentMap 
  ?! @instructionList unused targetEvalInstList
  ?! @bool unused isABranch
  ?! @bool unused noCond
  ?! @bool unused unknownStaticTarget
  ?! @symbolValueMap unused symbolValueMap
:
  #TODO: renommage de variables?
end method;

override method @cCompMethodCall processBranchTarget 
  ?? @componentMap componentMap 
  ?! @instructionList targetEvalInstList
  ?! @bool isABranch
  ?! @bool noCond
  ?! @bool unknownStaticTarget
  ?! @symbolValueMap symbolValueMap
:
  #get the insruction list related to that component method.
  @functionMap methodMap;
  @instructionList code;
  @parameterDefList paramDef;
  [componentMap searchKey !componentName ?* ?* ?methodMap ?* ?* ?* ?* ?* ?*];
  [methodMap searchKey !methodName ?paramDef ?* ?code]; 
  #
  #update the symbol map with values in parameter.
  #
  @symbolValueMap symbolValueMapInComponent := symbolValueMap;
  foreach paramDef(* @lstring name *) do
    if [symbolValueMapInComponent hasKey ![name string]] then
      #same name used in component. the symbol is now associated to the one in the component.
      [!?symbolValueMapInComponent removeKey !name ?* ?*];
    end if;
  end foreach;
  foreach paramList (@cExpression exp @location loc), paramDef(@bool out @lstring name *) do
    updateSymbolMap !?symbolValueMapInComponent !name !exp;
  end foreach;

  #then search in instruction list.
  foreach code (@cInstruction inst) while not isABranch do
    targetEvalInstList += !inst;
    [inst processBranchTarget !componentMap !?targetEvalInstList !?isABranch !?noCond !?unknownStaticTarget !?symbolValueMapInComponent];
  end foreach ;

  #update with parameters that are defined as out.
  foreach paramList (@cExpression exp @location loc), paramDef(@bool out @lstring name *) do
    if out then
      cast exp
      when == @cIdf idf :
        @lstring varName := [idf idf];
        #this is an out expression. Get back the value.
        if [symbolValueMapInComponent hasKey ![varName string]] then
          @uint64 value;
          @bool negative;
          [symbolValueMapInComponent searchKey !varName ?value ?negative];
          [!?symbolValueMap insertKey !varName !value !negative];
        end if;
      else #should not happen, already checked in 'checkCallDefParameters' routine.
      end cast; 
    end if;
  end foreach;
end method;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
