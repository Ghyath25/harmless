semantics gadl_semantics_expression_eval:
  import "gadl_semantics_expression.gSemantics";
  import "gadl_variable.gSemantics"; #varKind

#This map is used to associate a value to an identifier (key).
map @symbolValueMap
{
  @uint64 value;  #cannot handle value > 64 bits at this date. This is the absolute val.
  @bool negative; #This is the sign.
  insert insertKey error message "the '%K' key is already defined in symbol map %L.";
  search searchKey error message "the '%K' key is not defined in symbol map.";
  remove removeKey error message "the '%K' key is not defined in symbol map.";
}

########################################################################
#this reader is used to eval an expression
# 2+3<<1   should return 8
# 3+4*toto should return 3+4*toto (if toto is not in symbol map).
########################################################################
abstract reader @cExpression eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
;

########################################################################
#this function tries to update the symbol map. It checks
#if the expression is an int value. If this is the case
#it either update the entry or add a new one.
routine updateSymbolMap
  ?! @symbolValueMap symbolValueMap
  ?? @lstring varName
  ?? @cExpression exp
:
  @cExpression expEval := [exp eval !symbolValueMap];
  cast expEval
    when == @cIntConst constVal :
      #value is statically defined. Update symbolValueMap
      if [symbolValueMap hasKey ![varName string]] then #already defined. Update
        [!?symbolValueMap setValueForKey ![constVal value] ![varName string]];
        [!?symbolValueMap setNegativeForKey ![constVal negative] ![varName string]];
        #message "symbol ".[varName string]." update value ".[[constVal value] string]."\n";
      else
        [!?symbolValueMap insertKey !varName ![constVal value] ![constVal negative]];
        #message "symbol ".[varName string]." get value ".[[constVal value] string]."\n";
      end if;
    else
  end cast;
end routine;


########################################################################

function getExpressionFromSymbol
  ?? @uint64 value #cannot handle value > 64 bits at this date.
  ?? @bool negative
  -> @cExpression exp
:
  @varKind kind := [@varKind unsigned];
  if negative then kind := [@varKind signed]; end if;
  @uint nbBits := 0;
  if negative then
    nbBits := nbBitsToCodeSigned[!value];
  else
    nbBits := nbBitsToCodeUnsigned[!value];
  end if;
  #nb bits must be >0, when used in the expression (s8)(0) or (u8)(0)
  if nbBits == 0 then nbBits := nbBits + 1; end if;
  @varType outType := [@varType new !kind !nbBits !here];
  exp := [@cIntConst new !getTypeListFrom[!outType] !value !negative];
end function;

override reader @cExpDummy eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #We can't do anything with that..
end reader;

override reader @cExpInstructionSize eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #we do not have this information here.can't eval.
end reader;

override reader @cExpInstructionAddress eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #we do not have this information here.can't eval.
end reader;

override reader @cIdf eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  if [symbolMap hasKey ![idf string]] then
    #found.
    @uint64 value;
    @bool negative;
    [symbolMap searchKey !idf ?value ?negative];
    result := getExpressionFromSymbol[!value !negative];
  else
    result := selfcopy;
  end if;
end reader;

override reader @cTabIndice eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #Can't eval a tabular access.
end reader;
override reader @cTypeTabMember eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #Can't eval a tabular access.
end reader;

override reader @cTypeMember eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #Can't eval
end reader;

override reader @cTypeTag eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #Can't eval
end reader;

override reader @cTypeExtend eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #Can't eval
end reader;


override reader @cCast eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expEval := [expression eval !symbolMap];

  @bool found;
  @uint64 value := 0L;
  @bool negative := false;

  getConstValue !expEval ?value ?negative ?found;

  if found then
    result := [@cIntConst new !typeList !value !negative]; #save the cast type.
  else #no merge..
    #we may update the out type if there is eval simplify the expression...
    result := [@cCast new !typeList !expEval] ;
  end if;
end reader;

override reader @cBitFieldOp eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expEval := [expField eval !symbolMap];;

  @bool ok := true;
  @uint64 valueBase := 0L; #Base value, on which fields are applied.
  @uint64 value := 0L;     #result value
  @bool negativeBase := false;

  getConstValue !expEval ?valueBase ?negativeBase ?ok;
  ok := ok & (negativeBase == false); #value should not be negative.
  if ok then #expression can be evaluated.
    foreach fList (@cExpression expFrom @cExpression expTo * * @location loc) while ok do
      @cExpression expFromEval := [expFrom eval !symbolMap];
      @cExpression expToEval := [expTo eval !symbolMap];
      @uint64 valueFrom := 0L;
      @uint64 valueTo := 0L;
      @bool negFrom := false;
      @bool negTo := false;
      getConstValue !expFromEval ?valueFrom ?negFrom ?ok;
      if ok then
        getConstValue !expToEval ?valueTo ?negTo ?ok;
      end if;
      if ok then
        #ok, field expressions from and to can be evaluated.
        if (negFrom == true) | (negTo == true) then
          error loc: "Evaluation of expression leads to a negative range";
        end if;
        @uint range := [valueFrom uint]-[valueTo uint]+1;
        @uint64 val := (valueBase >> [valueTo uint]) & ((1<<range)-1);
        value := (value << range) | val;
      end if;
    end foreach;
  end if;
  if ok then 
    result := getExpressionFromSymbol[!value !false];
  else #no merge..
    #we may update the out type if there is eval simplify the expression...
    result := [@cBitFieldOp new !typeList !expEval !fList] ;
  end if;
end reader;

override reader @cSliceFieldOp eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #used only in decoder.
end reader;

override reader @cIntConst eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #nothing to do. Already simplified.
end reader;

override reader @cUnaryOp eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expEval := [exp eval !symbolMap];

  @bool ok;
  @uint64 value := 0L;
  @bool negative := false;

  getConstValue !expEval ?value ?negative ?ok;

  if ok then
    if id == 0 then #logic not;
      if value == 0L then value := 1L;
      else value := 0L;
      end if;
      negative := false;
    elsif id == 1 then #boolean not
      if [typeList length] != 1 then
        ok := false;
      else
        if negative & value > 0L then
          value := (value ^ [@uint64 max]) + 1; #2's complement.
        end if;
        @varType type;
        [typeList first ?type];
        @uint64 mask := (1L<<[type size])-1;
        value := (value ^ mask) & mask;
        negative := false;
      end if;
    elsif id == 2 then #unary -
      negative := not negative;
    else 
      error here: "internal error in unary expression. Wrong id.";
      ok := false;
    end if;
  end if;
  if ok then
    result := getExpressionFromSymbol[!value !negative];
  else #no merge..
    #we may update the out type if there is eval simplify the expression...
    result := [@cUnaryOp new !typeList !expEval !id];
  end if;
end reader;

#Be careful: This function is NOT recursive.
#It only return the value for a const signed/unsigned val.
routine getConstValue
  ?? @cExpression exp
  !  @uint64 value
  !  @bool negative
  !  @bool found 
:
  value := 0L;
  negative := false;
  cast exp
  when == @cIntConst val : #both signed and unsigned.
    value  := [val value];
    negative := [val negative];
    found := true;
  else
    found := false;
  end cast;  
end routine;

#calulate the sum of values..
routine getSum
  ?? @uint64 valLeft
  ?? @bool negLeft
  ?? @uint64 valRight
  ?? @bool negRight
  !  @uint64 value
  !  @bool negative
:
  if((negLeft == false) & (negRight == false)) then
    value := valLeft+valRight;
    negative := false;
  elsif((negLeft == false) & (negRight == true)) then
    if valLeft > valRight then
      value := valLeft-valRight;
      negative := false;
    else
      value := valRight-valLeft;
      negative := true;
    end if;
  elsif((negLeft == true) & (negRight == false)) then
    if valRight > valLeft then
      value := valRight-valLeft;
      negative := false;
    else
      value := valLeft-valRight;
      negative := true;
    end if;
  else #if((negLeft == true) & (negRight == true)) then
    value := valLeft+valRight;
    negative := true;
  end if;
end routine;

function isEqual
  ?? @uint64 valLeft
  ?? @bool negLeft
  ?? @uint64 valRight
  ?? @bool negRight
  -> @bool result
:
  if (valLeft == valRight) & (negLeft == negRight) then result := true;
  elsif((valLeft == 0L) & (valRight == 0L)) then result := true; #sign may differ..
  else result := false;
  end if;
end function;

routine isLess #compare left < right
  ?? @uint64 valLeft
  ?? @bool negLeft
  ?? @uint64 valRight
  ?? @bool negRight
  !  @uint64 value
:
  if((negLeft == false) & (negRight == false)) then
    if valLeft < valRight then value := 1L; else value := 0L; end if;
  elsif((negLeft == false) & (negRight == true)) then
    value := 0L;
  elsif((negLeft == true) & (negRight == false)) then
    value := 1L;
  else #if((negLeft == true) & (negRight == true)) then
    if valLeft > valRight then value := 1L; else value := 0L; end if;
  end if;
end routine;

override reader @cBinaryBasicOp eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expLeftEval := [expLeft eval !symbolMap];;
  @cExpression expRightEval := [expRight eval !symbolMap];;
  #can we concatenate them..?
  #First get the value at left.
  @bool found;
  @uint64 valLeft := 0L;
  @bool negLeft := false;
  @uint64 valRight := 0L;
  @bool negRight := false;

  getConstValue !expLeftEval ?valLeft ?negLeft ?found;
  if found then
    getConstValue !expRightEval ?valRight ?negRight ?found;
  end if;
  if found then #both are found -> we can merge.
    @uint64 value := 0L;
    @bool negative := false;
    @bool ok := true;
    if(id == 0) then #id = 0  -> *
      value := valLeft*valRight;
      if(negLeft == negRight) then negative := false;
      else negative := true;
      end if;
    elsif(id == 1) then #id = 1  -> /
      value := valLeft/valRight;
      if(negLeft == negRight) then negative := false;
      else negative := true;
      end if;
    elsif(id == 2) then #id = 2  -> %
      value := valLeft mod valRight;
      negative := negLeft;
    elsif(id == 3) then #id = 3  -> +
      getSum !valLeft !negLeft !valRight !negRight ?value ?negative;
    elsif(id == 4) then #id = 4  -> -
      getSum !valLeft !negLeft !valRight !(not negRight) ?value ?negative;
    elsif(id == 5) then #id = 5  -> >>
      value := valLeft >> [valRight uint];
      negative := negLeft;
    elsif(id == 6) then #id = 6  -> <<
      value := valLeft << [valRight uint];
      negative := negLeft;
    elsif(id == 7) then #id = 7  -> <
      isLess !valLeft !negLeft !valRight !negRight ?value;
      negative := false;
    elsif(id == 8) then #id = 8  -> >
      isLess !valLeft !negLeft !valRight !negRight ?value;
      value := 1L-value;
      negative := false;
    elsif(id == 9) then #id = 9  -> <=
      isLess !valLeft !negLeft !valRight !negRight ?value;
      if isEqual[!valLeft !negLeft !valRight !negRight] then value := 1L; end if;
      negative := false;
    elsif(id == 10) then #id = 10 -> >=
      isLess !valLeft !negLeft !valRight !negRight ?value;
      value := 1L-value;
      if isEqual[!valLeft !negLeft !valRight !negRight] then value := 1L; end if;
      negative := false;
    elsif(id == 11) then #id = 11 -> ==
      negative := false;
      if isEqual[!valLeft !negLeft !valRight !negRight] then 
        value := 1L;
      else
        value := 0L;
      end if;
    elsif(id == 12) then #id = 12 -> !=
      negative := false;
      if isEqual[!valLeft !negLeft !valRight !negRight] then 
        value := 0L;
      else
        value := 1L;
      end if;
    elsif(id == 13) then #id = 13 -> &
      if (negLeft==false) & (negRight==false) then
        value := valLeft & valRight;
        negative := false;
      else
        ok := false; #not usable for negative values.
      end if;
    elsif(id == 14) then #id = 14 -> ^
      if (negLeft==false) & (negRight==false) then
        value := valLeft ^ valRight;
        negative := false;
      else
        ok := false; #not usable for negative values.
      end if;
    elsif(id == 15) then #id = 15 -> |
      if (negLeft==false) & (negRight==false) then
        value := valLeft | valRight;
        negative := false;
      else
        ok := false; #not usable for negative values.
      end if;
    elsif(id == 16) then #id = 16 -> &&
      if valLeft != 0L & valRight != 0L then value := 1L;
      else value := 0L;
      end if;
      negative := false;
    elsif(id == 17) then #id = 17 -> ||
      if (valLeft != 0L) | (valRight != 0L) then value := 1L;
      else value := 0L;
      end if;
      negative := false;
    else error here: "internal error: unknown id for binary operation";
    end if;
    if ok then
      result := getExpressionFromSymbol[!value !negative];
    else
      result := selfcopy;
    end if;
  else #no merge..
    #we may update the out type if there is eval simplify an expression...
    result := [@cBinaryBasicOp new !typeList !expLeftEval !expRightEval !id] ;
  end if;
end reader;

override reader @cRotationOp eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expLeftEval := [expLeft eval !symbolMap];;
  @cExpression expRightEval := [expRight eval !symbolMap];;

  @bool found;
  @uint64 valLeft := 0L;
  @bool negLeft := false;
  @uint64 valRight := 0L;
  @bool negRight := false;

  getConstValue !expLeftEval ?valLeft ?negLeft ?found;
  if found then
    getConstValue !expRightEval ?valRight ?negRight ?found;
  end if;
  if found & (negLeft == false) & (negRight == false) then #both are found -> we can merge.
    @uint64 value := 0L;
    @bool negative := false;
    if id == 0 then #ror
      @uint64 rot := valLeft & ((1<<[valRight uint])-1);
      value := (valLeft >> [valRight uint]) | (rot << (sizeL - valRight));
    elsif id == 1 then #rol
      @uint64 rot := valLeft >> (sizeL - valRight); 
      value := (valLeft << [valRight uint]) | rot;
      value := value & ((1 << sizeL)-1); #mask
    else
      error here: "internal error with id of rotation.";
    end if;
    result := getExpressionFromSymbol[!value !negative];
  else #no merge..
    #we may update the out type if there is eval simplify an expression...
    result := [@cRotationOp new !typeList !expLeftEval !expRightEval !sizeL !id] ;
  end if;
end reader;

override reader @cXorOp eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expLeftEval := [expLeft eval !symbolMap];;
  @cExpression expRightEval := [expRight eval !symbolMap];;

  @bool found;
  @uint64 valLeft := 0L;
  @bool negLeft := false;
  @uint64 valRight := 0L;
  @bool negRight := false;

  getConstValue !expLeftEval ?valLeft ?negLeft ?found;
  if found then
    getConstValue !expRightEval ?valRight ?negRight ?found;
  end if;
  if found then #both are found -> we can merge.
    @uint64 value := 0L;
    @bool negative := false;
    if ((valLeft != 0L) & (valRight == 0L)) | ((valLeft == 0L) & (valRight != 0L)) then
      value := 1L;
    end if;
    result := getExpressionFromSymbol[!value !negative];
  else #no merge..
    #we may update the out type if there is eval simplify an expression...
    result := [@cXorOp new !typeList !expLeftEval !expRightEval] ;
  end if;
end reader;

override reader @cCatOp eval
  ?? @symbolValueMap symbolMap
  -> @cExpression result
:
  @cExpression expLeftEval := [expLeft eval !symbolMap];;
  @cExpression expRightEval := [expRight eval !symbolMap];;

  @bool found;
  @uint64 valLeft := 0L;
  @bool negLeft := false;
  @uint64 valRight := 0L;
  @bool negRight := false;

  getConstValue !expLeftEval ?valLeft ?negLeft ?found;
  if found then
    getConstValue !expRightEval ?valRight ?negRight ?found;
  end if;
  if found then #both are found -> we can merge.
    @uint64 value := 0L;
    @bool negative := false;
    value := (valLeft << sizeR) | valRight;
    result := getExpressionFromSymbol[!value !negative];
  else #no merge..
    #we may update the out type if there is eval simplify an expression...
    result := [@cCatOp new !typeList !expLeftEval !expRightEval !sizeR] ;
  end if;
end reader;

import "gadl_components.gSemantics";
override reader @cComponentMethod eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #TODO.
end reader;

import "gadl_semantics_function.gSemantics";
override reader @cfunctionCall eval
  ?? @symbolValueMap unused symbolMap
  -> @cExpression result
:
  result := selfcopy; #TODO.
end reader;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
