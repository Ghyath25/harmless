syntax gadl_timing_parser ("gadl_lexique.gLexique") :
  import "gadl_timing_AST.gSemantics";
  import "gadl_semantics_AST_expression.gSemantics" ;

nonterminal <expression> !@ASTExpression ASTexp;
nonterminal <assignmentOrFunctionCall> ?! @ASTInstructionList instList;
nonterminal <declaration> ?! @ASTInstructionList instList;

#main timing instruction rule.
rule  <timing>
  ?! @ASTTimingMap ASTTimingMap
:
  $timing$;
  @lstring timingName;
  $idf$ ?timingName;
  @bool externalActivation; #deprecated?
  select
    externalActivation := false;
  or
    $on$;
    $activation$;
    externalActivation := true;
  end select;
  @boolMap signalIn [emptyMap];
  @boolMap signalOut [emptyMap];
  <signal> !?signalIn !?signalOut;
  ${$; 
  @bool loopForever;
  @ASTTimingInstructionList ASTTinstList;
  <tInstructions> ?ASTTinstList !true ?loopForever;
  if loopForever & not externalActivation then
    error here: "This timing will generate code that loops forever.".
    "It should wait either for a number of cycles or for a synchronisation (wait for signal/emit signal)";
  end if;
  $}$;
  [!?ASTTimingMap insertKey !timingName !externalActivation !signalIn !signalOut !ASTTinstList];
end rule;

#Signal Rule for in and out signal
rule <signal> 
  ?! @boolMap signalIn
  ?! @boolMap signalOut
:
  repeat
    @bool isIn;
    $signal$; 
    select 
      $in$ ; isIn:=true; 
    or 
      $out$; isIn:=false;
    end select;
    $:$; 
    repeat
      @lstring signalName;
      $idf$ ?signalName;
      if isIn then
        [!?signalIn insertKey !signalName];
      else
        [!?signalOut insertKey !signalName];
      end if;
    while
      $,$;
    end repeat;
  while
  end repeat;
end rule;

rule  <tInstructions>  
  !  @ASTTimingInstructionList ASTTinstList
  ?? @bool mainChunk # no local vars? (really necessary?)
  !  @bool loopForever
:
  #This bool is used to check that simulation will not go into an infinite loop:
  #timing should have at least a block instruction (wait for cycles or signals).
  loopForever := true;
  ASTTinstList := [@ASTTimingInstructionList emptyList];
  repeat
    @ASTTimingInstruction ASTTinst; 
    select
      <tDeclare> ?ASTTinst;
      if not mainChunk then
        error here: "Declaration of local variables is not supported in 'timing' sections. Please use only globals.";
      end if;
    or
      <tAssign> ?ASTTinst;
    or 
      <temit> ?ASTTinst;
      loopForever := false;
    or
      <wait> ?ASTTinst;
      loopForever := false;
    or
      <ifStatement> ?ASTTinst ?@bool loopForeverIf;
      loopForever := loopForever & loopForeverIf; #if loopForever is still false, it stays false;
    or 
      <loop> ?ASTTinst;
    end select;
    ASTTinstList += !ASTTinst;
  while
  end repeat;
end rule;

rule  <tDeclare>
  ! @ASTTimingInstruction tinst
:
  @ASTInstructionList instList [emptyList];
  <declaration> !?instList;
  tinst := [@ASTTDeclaration new !here !instList];
end rule;

rule  <tAssign>
  ! @ASTTimingInstruction tinst
:
  @ASTInstructionList instList [emptyList];
  <assignmentOrFunctionCall> !?instList;
  tinst := [@ASTTAssignOrCall new !here !instList];
end rule;

rule  <wait>
  ! @ASTTimingInstruction tinst
:
  $wait$ ; 
  select 
    <expression> ?@ASTExpression ASTexp;
    $cycle$;
    tinst := [@ASTTWaitCycle new  !here !ASTexp];
  or 
    $for$; $signal$; $idf$ ?@lstring name;
    tinst := [@ASTTWaitSignal new  !here  !name] ;
  end select;
end rule; 

rule  <temit>  
  ! @ASTTimingInstruction tinst
:
  @lstring name;
  $emit$ ; 
  @bool broadcast;
  select
    $broadcast$; broadcast := true;
  or
    broadcast := false;
  end select;
  select #signal keyword not mandatory.
    $signal$;
  or
  end select;
  $idf$ ?name;
  tinst := [@ASTTEmit new !here !name !broadcast] ;
end rule;

rule <loop> 
  ! @ASTTimingInstruction tinst
:
  @bool forever;
  @ASTExpression ASTexpLoopValue;
  $loop$;
  select
    <expression> ?ASTexpLoopValue;
    forever := false;
  or
    $forever$;
    #dummy ASTExp
    ASTexpLoopValue := [@ASTIntConst new !here !0L !false ![@varKind unsigned]];
    forever := true;
  end select;
  $while$;
  <expression> ?@ASTExpression ASTexpCondValue;  
  $do$;
  <tInstructions> ?@ASTTimingInstructionList ASTTinstLoopList !false ?*;
  $end$;$loop$;
  #create loop instruction.
  tinst := [@ASTTLoop new !here !forever !ASTexpLoopValue !ASTexpCondValue !ASTTinstLoopList];
end rule;

rule <ifStatement> 
  !  @ASTTimingInstruction tinst
  !  @bool loopForever
:
  @ASTTimingInstructionList ASTTinstListThen [emptyList];
  @ASTTimingInstructionList ASTTinstListElse [emptyList];
  $if$;
  <expression> ?@ASTExpression ASTexpIf;
  $then$;
  @bool loopForeverIf;
  <tInstructions> ?ASTTinstListThen !false ?loopForeverIf;
  @bool loopForeverElse;
  select 
    $else$;
    <tInstructions> ?ASTTinstListElse !false ?loopForeverElse;
  or
    loopForeverElse := true; #no else
  end select;
  loopForever := loopForeverIf | loopForeverElse; #should be false together
  $end$; $if$;
  tinst := [@ASTTIf new !here !ASTexpIf !ASTTinstListThen !ASTTinstListElse] ; 
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
