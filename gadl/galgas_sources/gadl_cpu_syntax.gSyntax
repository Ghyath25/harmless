syntax gadl_cpu_syntax ("gadl_lexique.gLexique") :
import "gadl_options.gOption" ;
import "gadl_memory.gSemantics";
import "gadl_core.gSemantics";
import "gadl_core_grammar.gGrammar";
import "gadl_varIdfStruct.gSemantics"; #lstringMap
import "gadl_cpu.gSemantics";
import "gadl_peripheral_AST.gSemantics";

#test
import "gadl_peripheral.gSemantics";
import "gadl_peripheral_templateExport.gSemantics";

nonterminal <memorySpace> ?! @ASTmemSpaceMap ASTmemSpaceMap;
nonterminal <peripheral>  ?! @ASTperipheralMap ASTperipheralMap;
nonterminal <memoryChunk>
  ?! @ASTmemoryParamMap ASTmemChunk 
  ?! @stringlist memChunkOrder
;
nonterminal <deviceDeclaration>
  ?? @bool memoryAccessIsLocal #true if a device is declared inside a peripheral (same mem chunk).
  !  @ASTInstDeclarationDevice deviceDec
;


rule <importCore>
  ?!@lstringMap importCoreMap
:
  $import$; $core$;
  $idf$ ?@lstring coreName;
  $from$;
  $caracterStr$ ?@lstring srcFile;  
  [!?importCoreMap insertKey !coreName !srcFile];
end rule;

rule <coreInstantiation>
  ?! @lstringMap coreTypeMap
  ?! @ASTCoreMap ASTcoreMap
  ?! @stringset coreSet
  ?! @ASTmemSpaceMap ASTmemSpaceMap
  ?? @lstringMap importCoreMap
:
  $core$; $idf$ ?@lstring coreType;
  $idf$ ?@lstring coreName;
  [!?coreTypeMap insertKey !coreName !coreType];
  if not [coreSet hasKey ![coreType string]] then
    #core type not parsed yet.
    [importCoreMap searchKey !coreType ?@lstring coreFileName];
    grammar gadl_core_grammar in coreFileName !?ASTcoreMap !?ASTmemSpaceMap;
    coreSet += ![coreType string];
  end if;
end rule;

rule <cpu>
:
  @ASTmemSpaceMap ASTmemSpaceMap [emptyMap];
  @ASTperipheralMap ASTperipheralMap [emptyMap];
  #importing core
  @lstringMap importCoreMap [emptyMap];
  #memory stuff
  @ASTmemoryParamMap ASTmemChunk [emptyMap];
  @stringlist memChunkOrder [emptyList];
  
  repeat
  while
    #global mem space definition.
    <memorySpace> !?ASTmemSpaceMap;
  while
    #peripheral def
    <peripheral> !?ASTperipheralMap;
  while
    #Core importation
    <importCore> !?importCoreMap;
  end repeat;

  $cpu$; $idf$ ?@lstring cpuName;
  ${$;
  #associate core type and a name (TODO and constructor param).
  @lstringMap coreTypeMap [emptyMap];
  #map of cores, key is the type.
  @ASTCoreMap ASTcoreMap [emptyMap];
  #set of core types, to parse only one time each core type.
  @stringset coreSet [emptySet];
  #cpu devices.
  @ASTInstructionList ASTDeviceDecList [emptyList];
  #map of cpu.
  @ASTCpuMap ASTCpuMap [emptyMap];

  repeat
  while
    <memoryChunk> !?ASTmemChunk !?memChunkOrder;
    message "mem chunk in CPU not implemented!!\n";
  while
    <coreInstantiation> !?coreTypeMap !?ASTcoreMap !?coreSet !?ASTmemSpaceMap !importCoreMap;
  while
    <deviceDeclaration> !false ?@ASTInstDeclarationDevice deviceDec;
    ASTDeviceDecList += !deviceDec;
  end repeat;
  [!?ASTCpuMap insertKey !cpuName !coreTypeMap !ASTcoreMap !ASTDeviceDecList];
  $}$;
  
  @lstring exportDir := cpuName;
  #Ok. Parsing done. Now apply semantic.
  ###########################################################################
  # init templates.
  ###########################################################################
  @TfieldMap templateStruct := [@TfieldMap emptyMap];
  [!?templateStruct initTemplate !cpuName !exportDir];

  ###########################################################################
  # memory space.
  ###########################################################################
  @memSpaceMap memSpaceMap := [ASTmemSpaceMap getMemSpaceMap];
  [memSpaceMap setInTemplate !?templateStruct];

  ###########################################################################
  # peripherals
  ###########################################################################
  @peripheralMap peripheralMap := [ASTperipheralMap getPeriphMap];
  [peripheralMap setInTemplate !?templateStruct];

  ###########################################################################
  # cpu generation.
  ###########################################################################
  [ASTCpuMap cpuSemantic !memSpaceMap !?templateStruct];

  ###########################################################################
  # template generation
  ###########################################################################
  @string gadlLog := computeTemplate[!"" !templateStruct !"root"];
  if [option gadl_options.templateLogFile value] then
    extractTemplateStructure !templateStruct !"templateLog.xml";
  end if;
  ###########################################################################
  # filewrappers: add binary files inside the gadl compiler.
  ###########################################################################
  addFileWrappers !exportDir;



end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
