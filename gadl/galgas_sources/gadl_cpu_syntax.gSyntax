syntax gadl_cpu_syntax ("gadl_lexique.gLexique") :
import "gadl_options.gOption" ;
import "gadl_memory.gSemantics";
import "gadl_core.gSemantics";
import "gadl_core_grammar.gGrammar";
import "gadl_varIdfStruct.gSemantics"; #lstringMap
import "gadl_cpu.gSemantics";
import "gadl_peripheral_AST.gSemantics";

#test
import "gadl_peripheral.gSemantics";
import "gadl_peripheral_templateExport.gSemantics";

nonterminal <memorySpace> ?! @ASTmemSpaceMap ASTmemSpaceMap;
nonterminal <peripheral>  ?! @ASTperipheralMap ASTperipheralMap;
nonterminal <memoryChunk>
  ?! @ASTmemoryParamMap ASTmemChunk 
  ?! @stringlist memChunkOrder
;
nonterminal <paramCall> ! @ASTExpressionlist idfExpList; #gadl_expression_parser.gSyntax
nonterminal <deviceDeclaration>
  ?? @bool memoryAccessIsLocal #true if a device is declared inside a peripheral (same mem chunk).
  ?? @ASTperipheralMap ASTperipheralMap
  !  @ASTInstDeclarationDevice deviceDec
;
nonterminal <signalConnect>;

nonterminal <import>
  ?? @bool fromCPU
  ?! @lstringMap importCoreMap
  ?! @lstringMap importIsaMap
  ?! @ASTperipheralMap ASTperipheralMap
;

rule <coreInstantiation>
  ?! @ASTcoreInstanceMap ASTcoreInstanceMap
  ?! @ASTCoreMap ASTcoreMap
  ?! @stringset coreSet
  ?! @ASTmemSpaceMap ASTmemSpaceMap
  ?! @uint coreId
  ?? @lstringMap importCoreMap
:
  $core$; $idf$ ?@lstring coreType;
  $idf$ ?@lstring coreName;
  <paramCall> ?@ASTExpressionlist coreParamExpList;
  [!?ASTcoreInstanceMap insertKey !coreName !coreType !coreId !coreParamExpList]; 
  if not [coreSet hasKey ![coreType string]] then
    #core type not parsed yet.
    [importCoreMap searchKey !coreType ?@lstring coreFileName];
    grammar gadl_core_grammar in coreFileName !?ASTcoreMap !?ASTmemSpaceMap;
    coreSet += ![coreType string];
  end if;
  coreId := coreId+1;
end rule;

rule <cpu>
:
  @ASTmemSpaceMap ASTmemSpaceMap [emptyMap];
  @ASTperipheralMap ASTperipheralMap [emptyMap];
  #import (cores and peripherals)
  @lstringMap importCoreMap [emptyMap];
  #memory stuff
  @ASTmemoryParamMap ASTmemChunk [emptyMap];
  @stringlist memChunkOrder [emptyList];
  
  repeat
  while
    #global mem space definition.
    <memorySpace> !?ASTmemSpaceMap;
  while
    #peripheral def
    <peripheral> !?ASTperipheralMap;
  while
    #Core or peripheral importation
    @lstringMap importIsaMap [emptyMap]; #unused here.
    <import> !true !?importCoreMap !?importIsaMap !?ASTperipheralMap;
  end repeat;

  $cpu$; $idf$ ?@lstring cpuName;
  ${$;
  #associate core type and a name 
  @ASTcoreInstanceMap ASTcoreInstanceMap [emptyMap];
  #map of cores, key is the type.
  @ASTCoreMap ASTcoreMap [emptyMap];
  #core id.
  @uint coreId := 0;
  #set of core types, to parse only one time each core type.
  @stringset coreSet [emptySet];
  #cpu devices.
  @ASTInstructionList ASTDeviceDecList [emptyList];
  #map of cpu.
  @ASTCpuMap ASTCpuMap [emptyMap];

  repeat
  while
    <memoryChunk> !?ASTmemChunk !?memChunkOrder;
  while
    <coreInstantiation> !?ASTcoreInstanceMap !?ASTcoreMap !?coreSet !?ASTmemSpaceMap !?coreId !importCoreMap;
  while
    <deviceDeclaration> !false !ASTperipheralMap ?@ASTInstDeclarationDevice deviceDec;
    ASTDeviceDecList += !deviceDec;
  while
    <signalConnect>;
  end repeat;
  [!?ASTCpuMap insertKey !cpuName !ASTcoreInstanceMap !ASTcoreMap !ASTDeviceDecList !ASTmemChunk !memChunkOrder];
  $}$;
  
  @lstring exportDir := cpuName;
  #Ok. Parsing done. Now apply semantic.
  ###########################################################################
  # init templates.
  ###########################################################################
  @TfieldMap templateStruct := [@TfieldMap emptyMap];
  [!?templateStruct initTemplate !cpuName !exportDir];
  #compile the tools templates (-> generate tools required during compilation)
  @string templateLog := computeTemplate[!"" !templateStruct !"tools"];

  ###########################################################################
  # memory space.
  ###########################################################################
  @memSpaceMap memSpaceMap := [ASTmemSpaceMap getMemSpaceMap];
  [memSpaceMap setInTemplate !?templateStruct];

  ###########################################################################
  # peripherals
  ###########################################################################
  @peripheralMap peripheralMap := [ASTperipheralMap getPeriphMap];
  [peripheralMap setInTemplate ![cpuName string] !?templateStruct];

  ###########################################################################
  # cpu generation.
  ###########################################################################
  [ASTCpuMap cpuSemantic !memSpaceMap !?templateStruct];

  ###########################################################################
  # template generation
  ###########################################################################
  @string gadlLog := computeTemplate[!"" !templateStruct !"root"];
  if [option gadl_options.templateLogFile value] then
    extractTemplateStructure !templateStruct !"templateLog.xml";
  end if;
  ###########################################################################
  # filewrappers: add binary files inside the gadl compiler.
  ###########################################################################
  addFileWrappers !exportDir;



end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
