semantics gadl_semantics_AST_implementation:
  import "gadl_options.gOption" ;
  import "gadl_semantics_AST_expression.gSemantics" ;
  import "gadl_variable.gSemantics" ; #varClass

class @memoryMapping
{
  @lstring memSpaceName;
  @luint64 baseAddress;
}

abstract class @ASTInstruction {
  @location loc;
}

list @ASTInstructionList {
  @ASTInstruction inst;
}

class @ASTInstIf extends @ASTInstruction {
  @ASTExpression cond;
  @ASTInstructionList ASTifList;
  @ASTInstructionList ASTelseList;
}

class @ASTInstReturn extends @ASTInstruction {
  @ASTExpression exp;
}

class @ASTInstNop extends @ASTInstruction {
  @ASTExpression exp;
}

class @ASTInstLoop extends @ASTInstruction {
  @ASTExpression guard;
  @ASTExpression expCondition;
  @ASTInstructionList loopInstList;
}

class @ASTInstError extends @ASTInstruction {
  @bool onlyWarn;
  @lstring msg;
}

class @ASTInstPrint extends @ASTInstruction {
  @ASTExpression exp;
}

class @ASTInstMessage extends @ASTInstruction {
  @lstring msg;
}

class @ASTInstFunctionCall extends @ASTInstruction {
  @ASTExpression idf;
}

class @ASTInstAssignment extends @ASTInstruction {
  @ASTExpression idf;
  @ASTfieldList astFList;
  @ASTExpression exp;
}

class @ASTInstDeclaration extends @ASTInstruction {
  @varClass access;
  @varAbstractType type;
  @lstring idf;
}

class @ASTInstDeclarationRegSlice extends @ASTInstDeclaration {
  #idf in the super class is the full register name (only)
  #type in the super class is the type of the full register
  @lstring sliceName;
  @ASTfieldList ASTfieldList;
}

class @ASTInstDeclarationDevice extends @ASTInstDeclaration {
  @memoryMapping address;
}

class @ASTInstTypeDefinition extends @ASTInstruction {
  @lstring idf;
  @typedefMemberMap memberList;
}

end semantics;
# vim:ft=ggs:ts=2:sw=2
