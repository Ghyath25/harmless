semantics gadl_types :
  import "gadl_options.gOption" ;
# Basic definition of variables.
# The variable kind can be:
#  * unsigned, signed or float;
#  * custom (for structures, and other objects (peripherals));

# data structure is based on the 'varAbstractType' abstract type with:
#  * varBaseType    for classical scalar types.
#  * varStructType  for custom types
#  * varTabularType for tabulars of scalar or custom types.
#  * varDeviceType  for device types (instances of peripherals).

#  * map @varBaseTypeMap -> map of varBaseType.

# useful readers for varAbstractType:
#  * getDeclaration -> return the declaration (for implementation).
#  * string         -> return the debug/information string.
#  * checkBool      -> generate an error if type is not u1.
#  * checkKind      -> generate an error if type is not the one expected (scalar, ..)
#  * getBaseType    -> return the base type, and generate an error otherwise.
#  * loc            -> return the location (for error generation).
#  * sizeInBits     -> return the size in bits for a scalar, the size of one elt for a tab, an error for struct.
#  * isVoid         -> return true for u0/s0/f0 (void) and false otherwise.
#  * checkEqual     -> check if types are equals
#  * getFinalType   -> used for tabulars. Return the type of an element (recursively in case of tab of tabsâ€¦).

# readers for varBaseType:
#  * getCSize       -> return the size of the corresponding C var.
#  * getCType       -> return the string of the C type
#  * getUppaalType  -> return the size for Uppaal TODO: define a more realistic 'max'.

# other useful functions/methods:
# function getCSize ?uint size -> return the size of the corresponding C var (unsigned)

enum @varKind {
  unsigned, signed, float, custom, tabular
}

reader @varKind msg -> @string outResult :
  switch selfcopy
    when unsigned : outResult := "an unsigned integer" ;
    when signed   : outResult := "a signed integer" ;
    when float    : outResult := "a float" ;
    when custom   : outResult := "a custom type" ;
    when tabular  : outResult := "a tabular type" ;
  end switch ;
end reader ;

###############################################################################
# TODO: should it be set here?
###############################################################################

#generation context
#for a specific target.
enum @codeCtx{
  C,
  Uppaal
}
reader @codeCtx msg -> @string out :
  switch selfcopy
    when C      : out := "generate a C code";
    when Uppaal : out := "generate code for Uppaal";
  end switch;
end reader;

###############################################################################
# variable related classes
###############################################################################

#base for any variable.
abstract class @varAbstractType {
  @varKind kind;
}

#basic type: unsigned, signed or float.
class @varBaseType extends @varAbstractType {
  @uint size ; #size in bits.
  @location location;
}

#a variable that matches a structure (like in C).
#a structure should be defined using a 'typedef'
class @varStructType extends @varAbstractType {
  @lstring typeName;
}

class @varTabularType extends @varAbstractType {
  @varAbstractType type;
  @uint length; #nb items.
}

#a variable that refers to a device (same as a truct in fact...)
class @varDeviceType extends @varAbstractType {
  @lstring typeName;
}

# This map should contains field names with the suffix (@SRC...)
map @varBaseTypeMap {
  @varBaseType type;
  insert insertKey error message "the '%K' data field is declared twice in the instruction" ; 
  search searchKey error message "the '%K' data field is not defined in the instruction" ;
}

###############################################################################
## get final type -> for a tabular, give the type of elements.
## result should not be a tabular.
###############################################################################
reader @varAbstractType getFinalType
  -> @varAbstractType finalType
:
  finalType := selfcopy;
end reader;

override reader @varTabularType getFinalType
  -> @varAbstractType finalType
:
  finalType := [[selfcopy type] getFinalType]; #recursive way.
end reader;

###############################################################################
## get location of type
###############################################################################
abstract reader @varAbstractType loc -> @location l;

override reader @varBaseType loc -> @location l:
  l := location;
end reader;

override reader @varStructType loc -> @location l:
  l := [typeName location];
end reader;

override reader @varDeviceType loc -> @location l:
  l := [typeName location];
end reader;

override reader @varTabularType loc -> @location l:
  l := [type loc];
end reader;
###############################################################################
## update location for type.
###############################################################################
abstract reader @varAbstractType changeLoc ?? @location l -> @varAbstractType newType;

override reader @varBaseType changeLoc ?? @location l -> @varAbstractType newType:
  newType := [@varBaseType new !kind !size !l];
end reader;

override reader @varStructType changeLoc ?? @location l -> @varAbstractType newType:
  newType := [@varStructType new !kind ![@lstring new ![typeName string] !l]];
end reader;

override reader @varDeviceType changeLoc ?? @location l -> @varAbstractType newType:
  newType := [@varDeviceType new !kind ![@lstring new ![typeName string] !l]];
end reader;

override reader @varTabularType changeLoc ?? @location l -> @varAbstractType newType:
  newType := [@varTabularType new !kind ![type changeLoc !l] !length];
end reader;


###############################################################################
## return the C type of a variable.
###############################################################################
reader @varBaseType getCSize -> @uint Csize :
  if kind == [@varKind unsigned] | kind == [@varKind signed] then
    if size <= 8 then Csize := 8;
    elsif size <= 16 then Csize := 16;
    elsif size <= 32 then Csize := 32;
    elsif size <= 64 then Csize := 64;
    elsif size <= 128 then Csize := 128;
    else Csize := 0; error location : "cannot handle variable size considered (> 128 bits)";
    end if;
  elsif kind == [@varKind float] then
    if size <= 32 then Csize := 32;
    elsif size <= 64 then Csize := 64;
    else Csize := 0; error location : "cannot handle float size considered (> 64 bits)";
    end if;
  else
    error location: "internal error: unable to determine the kind of variable":Csize;
  end if; 
end reader;

reader @varBaseType getCType
  -> @string str
:
  if kind == [@varKind unsigned] & (size == 0) then str := "void";
  else
    #kind
    if kind == [@varKind unsigned] then 
      str := "u"; 
    elsif kind == [@varKind signed] then 
      str := "s";
    elsif kind == [@varKind float] then 
      str := "f";
    else
      error location: "internal error: unable to determine the kind of variable" :str;
    end if;
    #size.
    str .= [[selfcopy getCSize] string];
  end if; 
end reader;

reader @varStructType getCType
  -> @string str
:
  str := "gadl_struct_TODO_".[typeName string]; #TODO: not a unique name!!!
end reader;

reader @varDeviceType getCType
  -> @string str
:
  str := "periph_".[typeName string];
end reader;

###############################################################################
## return the Uppaal type of a variable.
## TODO: to update with the 'max' field of the variable.
###############################################################################
reader @varBaseType getUppaalType
  -> @string str
:
  if kind != [@varKind unsigned] then
    warning location : "error here: only unsigned ints are supported for Uppaal export.";
  end if;
  str := "int[0,";
  @uint max := (1 << size) - 1;
  if size > 8 then
    warning location: "The variable size may be difficult to handle by the ".
              "Uppaal model checker. Consider using variables of smaller size";
  end if;
  str .= [max string]."]";
end reader;

###############################################################################
## check for equality.
###############################################################################

abstract reader @varAbstractType checkEqual
  ?? @varAbstractType otherType
  -> @bool ok
;

override reader @varStructType checkEqual
  ?? @varAbstractType otherType
  -> @bool ok
:
  const @varStructType typeCast := (cast otherType: @varStructType);
  ok := [[selfcopy typeName] string] == [[typeCast typeName] string];
end reader;

override reader @varTabularType checkEqual
  ?? @varAbstractType otherType
  -> @bool ok
:
  const @varTabularType typeCast := (cast otherType: @varTabularType);
  ok := [selfcopy length] == [typeCast length];
  ok := ok & [[selfcopy type] checkEqual ![typeCast type]];
end reader;

override reader @varDeviceType checkEqual
  ?? @varAbstractType otherType
  -> @bool ok
:
  const @varDeviceType typeCast := (cast otherType: @varDeviceType);
  ok := [[selfcopy typeName] string] == [[typeCast typeName] string];
end reader;

override reader @varBaseType checkEqual
  ?? @varAbstractType otherType
  -> @bool ok
:
  #first, a base type.
  const @varBaseType typeCast := (cast otherType: @varBaseType);
  ok := [selfcopy kind] == [typeCast kind] & [selfcopy size] == [typeCast size];
  if not ok then
    error [selfcopy location]:" the variable has not the same type than the one defined in ".[[typeCast location] locationString];
    error [typeCast location]:" the variable has not the same type than the one defined in ".[[selfcopy location] locationString];
  end if;
end reader;
###############################################################################
## getDeclaration => implementation part??
## return the code associated to a declaration of a type.
###############################################################################

abstract reader @varAbstractType getDeclaration 
  ?? @string idf
  ?? @codeCtx cgc  
  -> @string code
;

override reader @varBaseType getDeclaration 
  ?? @string idf
  ?? @codeCtx cgc
  -> @string code
:
  if cgc == [@codeCtx C] then
    code:= [selfcopy  getCType]." ".idf;
  elsif cgc == [@codeCtx Uppaal] then
    code:= [selfcopy  getUppaalType]." ".idf;
  else
    error location: "internal error: unknown code context": code;
  end if;
end reader;

override reader @varStructType getDeclaration 
  ?? @string  idf
  ?? @codeCtx cgc
  -> @string code
:
  code:= [selfcopy  getCType]." ".idf;
  if cgc == [@codeCtx Uppaal] then
    warning typeName: "no structure code generation for Uppaal export at this date";
  end if;
end reader;

override reader @varDeviceType getDeclaration 
  ?? @string  idf
  ?? @codeCtx cgc
  -> @string code
:
  code:= [selfcopy  getCType]." ".idf;
  if cgc == [@codeCtx Uppaal] then
    warning typeName: "no device code generation for Uppaal export at this date";
  end if;
end reader;

override reader @varTabularType getDeclaration 
  ?? @string  idf
  ?? @codeCtx cgc  
  -> @string code
:
  code := [type getDeclaration !idf !cgc]."[".length."]";
end reader;

###############################################################################
## string -> debug or information purpose.
###############################################################################
abstract reader @varAbstractType string -> @string str;
override reader @varBaseType string -> @string str
:
  if kind == [@varKind unsigned] then 
    str := "u"; 
  elsif kind == [@varKind signed] then 
    str := "s";
  elsif kind == [@varKind float] then 
    str := "f";
  else
      error location: "internal error: unable to determine the kind of variable" :str;
  end if;
  str .= [size string];
end reader;

override reader @varStructType string -> @string str
:
  str := [selfcopy  getCType]; #return internal name directly.
end reader;

override reader @varDeviceType string -> @string str
:
  str := "device ".[selfcopy  getCType]; #return internal name directly.
end reader;

override reader @varTabularType string -> @string str
:
  str := [type string]."[".length."]";
end reader;
###############################################################################
# getBaseType: return the scalar type, otherwise generate an error
###############################################################################

reader @varAbstractType getBaseType -> @varBaseType type
:
  error [selfcopy loc]: "The type considered is not scalar" : type;
end reader;

override reader @varBaseType getBaseType -> @varBaseType type
:
  type := selfcopy;
end reader;
###############################################################################
# checkBool
###############################################################################
method @varAbstractType checkBool:
  error [selfcopy loc]: "The type considered is not a boolean:".[selfcopy string];
end method;

#check that the type is a boolean.
override method @varBaseType checkBool 
:
  if ((size != 1) | (kind != [@varKind unsigned])) then
    error location: "the type must be a boolean (u1) and is ".[selfcopy string];
  end if;
end method;

###############################################################################
# checkKind
###############################################################################

method @varAbstractType checkKind
 ?? @varKind typeToCheck
:
  error [selfcopy loc]: "The type awaited is ".[typeToCheck msg].", but we have: ".[selfcopy string];
end method;

override method @varBaseType checkKind
 ?? @varKind typeToCheck
:
  if (kind != typeToCheck) then
    error [selfcopy loc]: "The type awaited is ".[typeToCheck msg].", but we have: ".[selfcopy string];
  end if;
end method;

###############################################################################
## useful functions.
###############################################################################
function getCSize
  ?? @uint size
  ->  @uint CSize
:
  @varBaseType varType := [@varBaseType new ![@varKind unsigned] !size !here];
  CSize := [varType getCSize];
end function;

#This function cast the input:
# *if this is a varBaseType, it is returned
# *otherwise : it generates an error.
function shouldBeVarBaseType
  ?? @varAbstractType type
  ?? @string errorMsg
  -> @varBaseType out
:
  cast type
  when == @varBaseType vbt :
    out := vbt;
  else
    @string msg := "a basic types is mandatory ";
    if errorMsg != "" then
      msg .= "(".errorMsg.")";
    end if;
    error [type loc]: errorMsg:out;
  end cast;
end function;

###############################################################################
# size in bits (not for structs!). Useful for masks.
##############################################################################
reader @varAbstractType sizeInBits -> @uint bits
:
  error [selfcopy loc]: "Cannot get the size in bits for a struct." : bits;
end reader;

override reader @varBaseType sizeInBits -> @uint bits
:
  bits := size;
end reader;

#TODO: tabular of tabular not taken into account.
#should be a simple tabular.
override reader @varTabularType sizeInBits -> @uint bits
:
  if (type is >= @varTabularType) then
    error [type loc] : "internal error: cannot yet handle tabs of tabs";
  end if;
  bits := [type sizeInBits];
end reader;


reader @varAbstractType isVoid -> @bool result
:
  cast selfcopy
  when == @varBaseType vbt :
    result := ([vbt size] == 0);
  else
    result := false;
  end cast;
  
end reader;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
