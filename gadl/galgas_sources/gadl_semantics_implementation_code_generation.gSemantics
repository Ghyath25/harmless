semantics gadl_semantics_implementation_code_generation:
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_expression.gSemantics" ; #generateCode
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_components.gSemantics" ;
  import "gadl_semantics_function.gSemantics" ;  
##################################################################
## Here is generateImplementation implementation for each
## instruction. This method do generate the C code for instructions.
##################################################################

# main routine to get back the C code of an implementation section.
function generateImplementation 
  ?? @instructionList instList ## input list of instructions
  ?? @uint nbTabulation        ## input init tabulation (only to get candy ouput C code)
  ?? @string componentPrefix   ## prefix used for object call.
  ?? @string idfSuffix         ## suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc              ## generation code context (C, Uppaal, ..)
  -> @string code              ## output code
:
  code := "";
  foreach instList (@cInstruction inst) do
    code .= commentCurrentDescriptionLine[!nbTabulation ![inst loc]];
    code .= [inst generateImplementation !nbTabulation !componentPrefix !idfSuffix !cgc];
  between
    code .= "\n";
  end foreach;
end function;

abstract reader @cInstruction generateImplementation 
  ?? @uint unused nbTabulation 
  ?? @string unused componentPrefix #prefix used for object call.
  ?? @string unused idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx unused cgc
  -> @string code
;

override reader @cDummy generateImplementation 
  ?? @uint nbTabulation 
  ?? @string unused componentPrefix #prefix used for object call.
  ?? @string unused idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx unused cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= codeStr;
end reader;

override reader @cInterruptInst generateImplementation 
  ?? @uint nbTabulation
  ?? @string componentPrefix #prefix used for object call.
  ?? @string unused idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx unused cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  if expContext == [@expressionContext behavior] then
    code .= "_arch->";
  end if;
  code .=componentPrefix."interruptHandling(";
  code .= [[trapId uint] string];
  code .=");\n";
end reader;

override reader @cErrorInst generateImplementation 
  ?? @uint nbTabulation
  ?? @string unused componentPrefix #prefix used for object call.
  ?? @string unused idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx unused cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "std::cerr << \"RUNTIME ";
  if onlyAWarn then
    code .= "WARNING";
  else
    code .= "ERROR";
  end if;
  code .= " at ".[[msg location] locationString].". Message is \\\"".[msg string]."\\\"\" << std::endl;\n";
end reader;

override reader @cMessageInst generateImplementation 
  ?? @uint nbTabulation
  ?? @string unused componentPrefix #prefix used for object call.
  ?? @string unused idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx unused cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "std::cerr << \"".[msg string]."\";";
end reader;

override reader @cPrintInst generateImplementation 
  ?? @uint nbTabulation
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "std::cerr << std::hex << ";
  code .= [exp generateCode !componentPrefix !idfSuffix !cgc].";";
end reader;

override reader @cNopInst generateImplementation 
  ?? @uint nbTabulation
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  if expContext == [@expressionContext behavior] then
    code .= "_arch->";
  end if;
  code .="doNotExececuteNextInstructions(";
  code .= [condition generateCode !componentPrefix !idfSuffix !cgc].");";
end reader;

override reader @cInsertStall generateImplementation 
  ?? @uint nbTabulation
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .="insertStall(";
  code .= [condition generateCode !componentPrefix !idfSuffix !cgc].");";
end reader;

override reader @cAddCycleInst generateImplementation 
  ?? @uint nbTabulation
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix       #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .="_arch->addCycle(";
  code .= [condition generateCode !componentPrefix !idfSuffix !cgc].");";
end reader;

override reader @cTimingMethodAccessBlock generateImplementation 
  ?? @uint    nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= generateImplementation[!instList !nbTabulation !componentPrefix !idfSuffix !cgc];
end reader;

override reader @cIfBlock generateImplementation 
  ?? @uint    nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "if(".[condition generateCode !componentPrefix !idfSuffix !cgc]."){\n";
  code .= generateImplementation[!ifInstList !nbTabulation+1 !componentPrefix !idfSuffix !cgc];
  code .= "\n";
  code .= tabs[!nbTabulation]."}";
  if [elseInstList length] > 0 then
    code .= " else {\n";
    code .= generateImplementation[!elseInstList !nbTabulation+1 !componentPrefix !idfSuffix !cgc];
    code .= "\n";
    code .= tabs[!nbTabulation] . "}";
  end if;
end reader;

override reader @cDeclareVar generateImplementation 
  ?? @uint nbTabulation 
  ?? @string unused componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation]; 
  #type string.
  @varType type := [variable type];
  if    cgc == [@codeCtx C] then code .= [type getCType]. " ";
  elsif cgc == [@codeCtx Uppaal] then code .= [type getUppaalType]. " ";
  else  error here : "internal error. Cannot generate code for this language";
  end if;
  #idf name.
  code .= [variable prefix] . [idf string]. [variable suffix]. idfSuffix;
  cast type
    when ==  @varTabType varIsTab :
      code .=  "[" .[[varIsTab tabSize] string]. "]";
  end cast;
  code .= "; //";
  @string typeStr;
  [type getStringType ?typeStr];
  code .= typeStr;
end reader;

override reader @cLoopBlock generateImplementation 
  ?? @uint    nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := "";
  #tmp var declaration.
  @uint tmpIdCopy := tmpId; #local copy.
  @classicVar varTmp;
  @lstring varTmpName;
  @varType type := [@varType new ![@varKind unsigned] !32 !here];
  getTempVar !?tmpIdCopy !type ?varTmpName ?varTmp;
  @cDeclareVar tmpVarDec := [@cDeclareVar new !here !varTmpName ! varTmp];
  code .= [tmpVarDec generateImplementation !nbTabulation !componentPrefix !idfSuffix !cgc];
  #init tmp var.
  code .= "\n";
  code .= tabs[!nbTabulation].[varTmpName string]." = 0;\n";
  code .= "\n";
  #loop
  code .= tabs[!nbTabulation];
  code .= "while((".[varTmpName string]." < ".[[guard uint64] hexString].") && (";
  code .= [condition generateCode !componentPrefix !idfSuffix !cgc];
  code .=")) {\n";
  code .= generateImplementation[!loopInstructionList !nbTabulation+1 !componentPrefix !idfSuffix !cgc];
  code .= "\n"; 
  code .= tabs[!nbTabulation+1]. [varTmpName string]."++;\n";
  code .="\n";
  code .= tabs[!nbTabulation]."}";

#    tabs !nbTabulation !?code;
#    code .= "if(";
#    [condition generateCode !?code !componentPrefix !idfSuffix];
#    code .= "){\n";
#    nbTabulation++;
#    generateImplementation !ifInstList !?code !nbTabulation !componentPrefix !idfSuffix;
#    code .= "\n";
#    nbTabulation--;
#    tabs !nbTabulation !?code; code .= "}";
#    if [elseInstList length] > 0 then
#      code .= " else {\n";
#      nbTabulation++;
#      generateImplementation !elseInstList !?code !nbTabulation !componentPrefix !idfSuffix;
#      code .= "\n";
#      nbTabulation--;
#      tabs !nbTabulation !?code; code .= "}";
#    end if;
end reader;

import "gadl_semantics_expression_eval.gSemantics";

override reader @cAssign generateImplementation 
  ?? @uint nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  #TODO: temporary: won't work if list != 1
  #generate right part expression
  @bool first := true;
  @uint tmpIdCopy := tmpId; #local copy.
  @string preCode := "";  #code that should appear first (tmp var declaration).
  @string postCode := ""; #code that should appear after (assignment.
  foreach leftPart (@cExpression expLeft @fieldList fieldLeft) do
    @string rightAssignPart := "";
    if first then
      rightAssignPart .= [exp generateCode !componentPrefix !idfSuffix !cgc];
      #**************************************************************
      #debug part.
      #**************************************************************
      #@symbolValueMap testMap := [@symbolValueMap emptyMap];
      #[!?testMap insertKey ![@lstring new !"toto" !here] !10L !true];
      #[!?testMap insertKey ![@lstring new !"totoP" !here] !10L !false];
      #@string expBaseStr := [exp generateCode !componentPrefix !idfSuffix !cgc];
      #@cExpression expEval := [exp eval !testMap];
      #@string expEvalStr := [expEval generateCode !componentPrefix !idfSuffix !cgc];
      ##if expBaseStr != expEvalStr then
      #  message "************************************************\n";
      #  #log exp;
      #  message expBaseStr." -> ".expEvalStr."\n";
      #  message "************************************************\n";
      ##end if;
      
      #**************************************************************
      #end debug part
      #**************************************************************
    else
      #tmp var declaration.
      @classicVar varTmp;
      @lstring varTmpName;
      @varType type;
      checkOneExpressionOutType !expLeft ?type;
      getTempVar !?tmpIdCopy !type ?varTmpName ?varTmp;
      @cDeclareVar tmpVarDec := [@cDeclareVar new !here !varTmpName ! varTmp];
      preCode .= [tmpVarDec generateImplementation !nbTabulation !componentPrefix !idfSuffix !cgc];
      preCode .= "\n";
      #assign expression.
      rightAssignPart := [varTmpName string];
    end if;
    postCode .= tabs[!nbTabulation]; 
    generateOneAssigment !expLeft !fieldLeft !rightAssignPart !?postCode !componentPrefix !idfSuffix !cgc;
    first := false;
  end foreach;
  code := preCode.postCode;
end reader;

override reader @cReturn generateImplementation 
  ?? @uint nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := "";
  if [expressionList length] > 0 then

    @returnTypeList returnListTemp := returnList; #working copy.
    @cExpressionList expressionListTemp := expressionList; #working copy.
    #the first expresion uses the classical 'return mechanism'.
    @cExpression expFirst;
    [!?expressionListTemp popFirst ?expFirst];
    [!?returnListTemp popFirst ?*];
    #then, for the others (the rest of the list),
    #use a classical 'assign' approach.
    @uint idx := 0;
    foreach expressionListTemp (@cExpression exp), 
            returnListTemp (@functionOutType functionOutType) do
      @string varName := "__return__".[idx string];
      #get the return type.
      @varType type;
      cast functionOutType
      when == @functionOutTypeClassic classicOut :
        type := [classicOut outType];
      else #custom type. No check at this time.
        type := [@varType new ![@varKind unsigned] !32 !here];
      end cast;
      @abstractVar variable := [@classicVar new !type !true!"" !""];
      @cIdf idf :=[@cIdf new !getTypeListFrom[!type] ![@lstring new !varName !here] !variable];
      @fieldList emptyField [emptyList];
      @leftAssignPart leftPart [emptyList];
      leftPart += !idf !emptyField;
      @cAssign assign := [@cAssign new !here !leftPart !exp !0];
      code .= [assign generateImplementation !nbTabulation !componentPrefix !idfSuffix !cgc];
      idx := idx + 1;
    end foreach;
    #the first return expression
    code .= tabs[!nbTabulation]."return ";
    code .= [expFirst generateCode !componentPrefix !idfSuffix !cgc].";";
  end if; #return list not empty.
end reader;

override reader @cAssignFunc generateImplementation 
  ?? @uint nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  #declaration
  code := tabs[!nbTabulation]; 
  #type string.
  @varType type := [variable type];
  code .= [type getCType]. " ";
  if out then code .= "&"; end if;
  #idf name.
  code .= [variable prefix] . [idf string]. [variable suffix];
  #assignment
  code .= " = ";
  if out then #this is an output : should check that output param is an identifier.
    cast expression
    when == @cIdf expIsIdf :
      code .= [expIsIdf generateCode !componentPrefix !idfSuffix !cgc];
    else
        error [idf location]: "The output parameter must be an identifier";
    end cast;
  else
    code .= [expression generateCode !componentPrefix !idfSuffix !cgc];
  end if;
  @string typeStr;
  [type getStringType ?typeStr];
  code .= "; // ".typeStr;
end reader;

override reader @cCompMethodCall generateImplementation 
  ?? @uint nbTabulation 
  ?? @string componentPrefix #prefix used for object call.
  ?? @string idfSuffix        #suffix used for fields (syntax and behaviors)
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  @string implementationName;
  getComponentMethodImplementationName ![componentName string] ![methodName string] !componentPrefix ?implementationName;
  code .= implementationName . "(";
  @bool first := true;
  foreach paramList (@cExpression exp @location loc) do
    if not first then code .= ", "; end if;
    code .= [exp generateCode !componentPrefix !idfSuffix !cgc];
    first := false;
  end foreach;
  code .= ");";
end reader;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
