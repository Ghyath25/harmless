semantics gadl_semantics_implementation_code_generation:
  import "gadl_options.gOption" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_GetExp.gSemantics" ;
  import "gadl_semantics_expression_code_generation.gSemantics" ;

# functions:
# - generateCode -> for an instruction list (and add description line as comment).
# - commentCurrentDescriptionLine -> print the description line (.hadl), for debugging.
# - tabs -> add tabluations to get a candy output (C code).
#
# readers:
# - generateCode for each instruction.
# reader @fieldList getAssignCode

abstract reader @instruction generateCode
  ?? @uint unused nbTabulation        ## input init tabulation (only to get candy ouput C code)
  ?? @codeCtx unused cgc              ## generation code context (C, Uppaal, ..)
  -> @string code
;

function tabs 
  ?? @uint nbTabulation
  -> @string code
:
  code := "";
  @uint val := nbTabulation;
  loop nbTabulation + 1:
  while val > 0 do
    code .= "\t";
    val--;
  end loop;
end function;

function commentCurrentDescriptionLine
  ?? @uint nbTabulation
  ?? @location loc
  -> @string comment
:
  comment := tabs[!nbTabulation];
  @stringlist l1 := [[loc locationString] componentsSeparatedByString !"'"];
  @string longPath := [l1 mValueAtIndex !1];
  @string shortPath := [longPath lastPathComponent];
  comment .= "// '".shortPath."', l.".[[loc line] string]."\n";
end function;

function generateCode 
  ?? @instructionList instList
  ?? @uint nbTabulation
  ?? @codeCtx cgc              ## generation code context (C, Uppaal, ..)
  -> @string code              ## output code
:
  code := "";
  @bool emptyInst := false; #used for instruction that do not generate code.
  foreach instList (@instruction inst) do
    @string instCode := [inst generateCode !nbTabulation !cgc];
    emptyInst := instCode == "";
    if not emptyInst then
      code .= commentCurrentDescriptionLine[!nbTabulation ![inst loc]];
      code .= instCode;
    end if;
  between
    if not emptyInst then
      code .= "\n";
    end if;
  end foreach;
end function;


override reader @instIf generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  #check for needed '()': conditions like 
   # idf or int do not have any '()', -> they should be added
   # others (binary ops for instance have '()'. One should not add extra '()'.
  @bool hasParenthesis := [cond hasParenthesis];
  
  code := tabs[!nbTabulation];
  code .= "if";
  if not hasParenthesis then code .= "("; end if;
  code .= [cond generateCode !cgc];
  if not hasParenthesis then code .= ")"; end if;
  code .= "{\n";
  code .= generateCode[!instIfList !nbTabulation+1 !cgc];
  code .= "\n";
  code .= tabs[!nbTabulation]."}";
  if [instElseList length] > 0 then
    code .= " else {\n";
    code .= generateCode[!instElseList !nbTabulation+1 !cgc];
    code .= "\n";
    code .= tabs[!nbTabulation] . "}";
  end if;
end reader;

override reader @instReturn generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation]."return ";
  code .= [exp generateCode !cgc].";";
end reader;

override reader @instNop generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  if expContext == [@expressionContext behavior] then
    code .= "_arch->";
  end if;
  code .="doNotExececuteNextInstructions(";
  code .= [cond generateCode !cgc].");";
end reader;

override reader @instLoop generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  #generates code inside a dedicated block.
  #This allows to use the internal guard variable only inside this block.
  code := tabs[!nbTabulation]."{\n";
  code .= tabs[!nbTabulation+1]."u32 __loopGuard = 0;\n";
  code .= tabs[!nbTabulation+1];
  code .= "while((__loopGuard < ".[guard generateCode !cgc].") && (";
  code .= [expCondition generateCode !cgc].")) {\n";
  code .= generateCode[!loopInstList !nbTabulation+2 !cgc];
  code .= "\n"; 
  code .= tabs[!nbTabulation+2]."__loopGuard++;\n";
  code .= tabs[!nbTabulation+1]."}\n";  
  code .= tabs[!nbTabulation]."}";
end reader;

override reader @instError generateCode
  ?? @uint nbTabulation
  ?? @codeCtx unused cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "std::cerr << \"RUNTIME ";
  if onlyWarn then
    code .= "WARNING";
  else
    code .= "ERROR";
  end if;
  code .= " at ".[[msg location] locationString].". Message is \\\"".[msg string]."\\\"\" << std::endl;\n";
end reader;

override reader @instPrint generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "std::cerr << std::hex << ";
  code .= [exp generateCode !cgc].";";  
end reader;

override reader @instMessage generateCode
  ?? @uint nbTabulation
  ?? @codeCtx unused cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  code .= "std::cerr << \"".[msg string]."\";";
end reader;

override reader @instFunctionCall generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation].[exp generateCode !cgc].";";  
end reader;

reader @fieldList getAssignCode
  ?? @codeCtx cgc
  ?? @string idfReadAccess
  ?? @string rightExp #right code.
  -> @string rightPart
:
  rightPart := "";
  @uint offset := 0;
  #when this flag becomes true, the offset cannot be determined
  #and the field should be the last (no more offset).
  @bool unknown := false; 
  foreach > selfcopy(@expression expFrom @expression expTo @location loc @bool only1Exp)
  do
    if unknown then
      error  loc: "error, the field size cannot be computed statically, gadl cannot ".
                  "concatenate field parts for code generation (assign).";
    end if;
    @uint offsetInc := 0;
    @string fromExpCode := [expFrom generateCode !cgc];
    @string rightExpShift := "(".rightExp.")";
    if offset != 0 then rightExpShift .= " >> " . [offset string]; end if;
    if only1Exp then
      rightPart .= "FIELD_ASSIGN_ONE_BIT(".idfReadAccess.",".fromExpCode.",".rightExpShift.")";
      offsetInc := 1;
    else #general case.
      @string toExpCode := [expTo generateCode !cgc];
      rightPart .= "FIELD_ASSIGN(".idfReadAccess.",".fromExpCode.",".toExpCode.",".rightExpShift.")";
      #should get the size of the increment:
      @uint64 rangeFrom;
      @bool ok := true;
      @symbolValueMap symbolMap [emptyMap]; #no symbols here.TODO.
      [[expFrom eval !symbolMap] getUVal ?rangeFrom ?ok];
      if ok then #can evaluate 'from'
        @uint64 rangeTo;
        [[expTo eval !symbolMap] getUVal ?rangeTo ?ok];
        if ok then #can evaluate 'to'
          offsetInc := [rangeFrom uint]-[rangeTo uint]+1;
        end if;
      end if;
      unknown := not ok; #can't add an offset just after.
    end if;
    offset := offset+offsetInc;
  between rightPart .= " | ";
  end foreach;
end reader;


# The instAssignment reader generates the following code:
# * 'std' assignment : left = (right) & mask, 
#                      where mask limits the result size to fit in 'left'
# * 'register' assignement : setReg(right)
#                      when left is a register.
# * 'type' assignment : memcpy(left, right, sizeof(left));
#                      when left is a structured type.
#  @expIdf idf;
#  @expression exp;

override reader @instAssignment generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  code := tabs[!nbTabulation];
  @varKind kind := [[idf type] kind]; #unsigned, signed, float, custom, tabular
  if kind ==  [@varKind custom] then #specific case (memcopy)
    code := "TODO Struct";
  else
    #this is a scalar (local or reg or tab value).
    @string postInstruction := "";
    @string maskStr := "";
    @string rightPart;
    @string rightExp := [exp generateCode !cgc];
    @string leftPart;
    @string idfReadAccess  := ""; #used for field access.
    maskStr := getMaskFor[![[idf type] sizeInBits] ![[idf type] loc] !cgc];

    #left part.
    idfReadAccess := [idf generateCode !cgc];
    switch [idf detectedType]
    when unknown:
      error loc: "The identifier is unknown":leftPart;
    when structMember,localVar,tabularAccess: #variable access.
      leftPart := idfReadAccess." = ";  
    when registerAccess,registerBitField: #register
      leftPart := [idf generateSetterCode !cgc]."(";
      postInstruction := ")";
    when componentCall,memoryAccess,periphCall:
      error loc: "Cannot assign a function call or memory access.":leftPart;
    end switch;

    #right part (in case of fields)
    if [flist length] == 0 then
      rightPart := rightExp;
    else
      rightPart := [flist getAssignCode !cgc !idfReadAccess !rightExp];
    end if;

    code .= leftPart;
    if cgc == [@codeCtx C] then code .= "("; end if;
    code .= rightPart;
    if cgc == [@codeCtx C] then code .= ") & " . maskStr.postInstruction.";"; end if;
  end if;
end reader;

override reader @instDeclaration generateCode
  ?? @uint nbTabulation
  ?? @codeCtx cgc
  -> @string code
:
  switch access
  when localVar:
    code := tabs[!nbTabulation];
    @string name := prefixLocal.[idf string];
    code .= [type getDeclaration !name !cgc];
    code .= "; // ".[type string];
  when field,programCounter,GPR,SFR,registerSlice:
    #nothing.
    code := "";
  when device:
    message "TODO: override reader @instDeclaration generateCode -> device";
    code := "";
  end switch;
end reader;

override reader @instDeclarationRegSlice generateCode
  ?? @uint unused nbTabulation
  ?? @codeCtx unused cgc
  -> @string code
:
  code := "";
end reader;


override reader @instTypeDefinition generateCode
  ?? @uint unused nbTabulation
  ?? @codeCtx unused cgc
  -> @string code
:
  #no code associated. Type definition is done elsewhere.
  code := "";
end reader;

end semantics;
# vim:ft=ggs:ts=2:sw=2
