semantics gadl_semantics_instruction_classes :
#  import "gadl_semantics.gSemantics" ;  #@methodList
#  import "gadl_semantics_behavior_data_structures.gSemantics"; #@decodedInstBehaviorMap
#  import "gadl_components.gSemantics"; #getComponentMethodImplementationName
#  import "gadl_semantics_behavior.gSemantics" ; #getInstructionList
#  import "gadl_graph.gSemantics"; #@graphNode
  import "gadl_semantics_architecture.gSemantics"; #@instructionPipelinePath
  import "gadl_semantics_hard_pipeline.gSemantics"; #stageBodyList, pipelineMap
  import "gadl_graph.gSemantics"; #graphNodeMap
  import "gadl_templates.gSemantics"; #templates

#list of pipeline stages (+port/devices) for one pipeline sequence.
list @flatPipelineStageList {
  @lstring pipelineName;     #pipeline that owns the stage
  @lstring architectureName; #architecture on which the pipeline is mapped.
  @lstring stageName;
  @stageBodyList body; #devide mapping.
}

#list of @flatPipelineStageList. One for each pipeline sequence.
list @flatPipelineStageListList {
  @flatPipelineStageList fpsList;
  @string logString;
}

#this routine uses a '@instructionPipelinePath' structure to determine a list
#of pipeline stages, with an easier to process data structure.
routine getListOfPipelineStages
  ?? @pipelineMap pipelineMap
  ?? @instructionPipelinePath ipp
  !  @flatPipelineStageList fps
:
  fps := [@flatPipelineStageList emptyList];
  foreach ipp (@simplePipeline pipeline) do
    @lstring pipelineName := [pipeline mPipelineName];
    @lstring architectureName;
    @stageList stageList;
    [pipelineMap searchKey !pipelineName ?architectureName ?stageList];
    foreach stageList (@lstring stageName @stageBodyList stageBodyList) do
      fps += !pipelineName !architectureName !stageName !stageBodyList;
    end foreach;
  end foreach;
end routine;

routine logFlatPipelineStageList
  ?? @flatPipelineStageList fps
  ?!  @string logStr
:
  foreach fps (@lstring pipelineName 
               @lstring archName 
               @lstring stageName 
               @stageBodyList body) do
    logStr .="<p>".pipelineName."(arch:".archName.") -> stage ".stageName.":<br/>\n";
    foreach body (@stageBody stageBody) do
      @lstring deviceName := [stageBody device];
      logStr .= "device ".deviceName.":";
      @lstringlist portList := [stageBody portList];
      foreach portList (@lstring port) do
        logStr .= [port string];
      between
        logStr .= ", ";
      end foreach;
      logStr .= "<br/>\n";
    end foreach;
    logStr .= "</p>\n";
  end foreach;
end routine;

#This routine is applied on 1 device, where components are matching.
#returns all the matching ports for a method.
routine getMatchingPortsOnDevice
  ?? @portMap portMap
  ?? @aliasMap readAliasMap  #aliases for the 'read' access
  ?? @aliasMap writeAliasMap #aliases for the 'write' access
  ?? @lstring methodName
  !  @stringset matchingPortsInDevice

:
  matchingPortsInDevice := [@stringset emptySet];
  foreach portMap (@lstring name * @functionAllowedToAPort functionAllowedToAPort) do
    @bool hasRead := false;
    @bool hasWrite := false;
    cast functionAllowedToAPort
    when == @isOr functionAllowedToAPortIsOr :
      @lstringlist methodList := [functionAllowedToAPortIsOr functionAllowedList];
      foreach methodList (@lstring methodLStr) do
        if [methodLStr string] == [methodName string] then
          matchingPortsInDevice += ![name string];
        elsif [methodLStr string] == "read" then
          hasRead := true;
        elsif [methodLStr string] == "write" then
          hasWrite := true;
        end if;
      end foreach;
    when == @isWithNumber functionAllowedToAPortIsWithNumber :
      @string methodStr := [[functionAllowedToAPortIsWithNumber functionAllowedName] string];
      if methodStr == [methodName string] then
        matchingPortsInDevice += ![name string];
      elsif methodStr == "read" then
        hasRead := true;
      elsif methodStr == "write" then
        hasWrite := true;
      end if;
    when == @isAll : #Ok.
      matchingPortsInDevice += ![name string];
    when == @isExcept functionExcludedToAPort :
      @lstringlist methodExcludedList := [functionExcludedToAPort functionExcludedList];
      @bool found := false;
      foreach methodExcludedList (@lstring methodLStr) do
        if [methodLStr string] == [methodName string] then
          found := true;
        elsif [methodLStr string] == "read" then
          foreach readAliasMap (@lstring methodStr) do
            if [methodStr string] == [methodName string] then
              found := true;
            end if;
          end foreach;
        elsif [methodLStr string] == "write" then
          foreach writeAliasMap (@lstring methodStr) do
            if [methodStr string] == [methodName string] then
              found := true;
            end if;
          end foreach;
        end if;
      end foreach;
      if not found then #not excluded
        matchingPortsInDevice += ![name string];
      end if;
    else
      error here: "internal error in routine 'getMatchingPortsOnDevice'";
    end cast;
    if hasRead then #check in the read list.
      foreach readAliasMap (@lstring methodStr) do
        if [methodStr string] == [methodName string] then
          matchingPortsInDevice += ![name string];
        end if;
      end foreach;
    end if;
    if hasWrite then #check in the read list.
      foreach writeAliasMap (@lstring methodStr) do
        if [methodStr string] == [methodName string] then
          matchingPortsInDevice += ![name string];
        end if;
      end foreach;
    end if;
  end foreach;
end routine;

routine isComponentMethodMatchingDevice
  ?? @deviceMap deviceMap #structure created during device parsing. Store all architecture device info.
  ?? @stageBody stageBody #structure created during pipeline parsing for 1 device. Store the port list.
  ?? @lstring componentName #component name of the instruction to map on pipeline
  ?? @lstring methodName #method name ...
  !  @bool ok #return true if the component.method match the device.
  ! @lstring portName #return the corresponding port that is obtained.
:
  @lstring device := [stageBody device];
  @lstringlist portList := [stageBody portList];
  ok := false;
  #get info about the device.
  @lstring componentRelatedToDeviceName;
  @portMap  portMap;       #ports for the device.
  @aliasMap readAliasMap;  #aliases for the 'read' access
  @aliasMap writeAliasMap; #aliases for the 'write' access
  [deviceMap searchKey !device ?componentRelatedToDeviceName ?portMap ?readAliasMap ?writeAliasMap];
  if [componentName string] == [componentRelatedToDeviceName string] then
    #component name is matching, next is method
    @stringset matchingPortsInDevice;
    getMatchingPortsOnDevice !portMap !readAliasMap !writeAliasMap !methodName ?matchingPortsInDevice;
    #Ok. Now, we have a stringSet (matchingPortsInDevice) that contains the port that can accept the method.
    #get a stringset of ports available in pipeline stage;
    @stringset portsAvailableInPipelineStage [emptySet];
    foreach portList (@lstring port) do
      portsAvailableInPipelineStage += ![port string];
    end foreach;
    #then checks that it maps. 3 possibilities
    # 0 match -> method can't map.
    # 1 match -> method can map \o/
    # >1 match -> ambiguity.
    @stringset intersection := matchingPortsInDevice & portsAvailableInPipelineStage;
    if [intersection count] == 0 then    # 0 match -> method can't map.
      ok := false;
      portName := [@lstring new !"" !here]; #unused value.
    elsif [intersection count] == 1 then # 1 match -> method can map \o/
      ok := true;
      portName := [@lstring new !"" !here];
      foreach intersection (@string port) do #1 loop only.
        portName := [@lstring new !port !here]; #no more location info :-/
      end foreach;
    else     # >1 match -> ambiguity.
      error device: "The component access ".[componentName string].".".[methodName string].
       " is ambiguous. It can match with the following ports:";
      foreach intersection (@string port) do #1 loop only.
        error device: "\t port ".port;
      end foreach;
      ok := false;
      portName := [@lstring new !"" !here]; #unused value.
    end if;
  elsif [componentName string] == "__fetch_component" then #special case for implicit fetch.
    if [portMap hasKey !"fetch"] then #ok.
      portName := [@lstring new !"fetch" !here];
      ok := true;
    else
      portName := [@lstring new !"" !here]; #unused value.
      ok := false;
    end if;
  else
    ok := false;
    portName := [@lstring new !"" !here]; #unused value.
  end if;
end routine;

routine getMaxPortAccess
  ?? @architectureMap architectureMap
  ?? @lstring archName
  ?? @lstring deviceName
  ?? @lstring portName
  !  @uint val
:
  @deviceMap deviceMap;
  @portMap portMap;
  @functionAllowedToAPort functionAllowedToAPort;
  [architectureMap searchKey !archName ?deviceMap ?*];
  [deviceMap searchKey !deviceName ?* ?portMap ?* ?*];
  [portMap searchKey !portName ?* ?functionAllowedToAPort];
  cast functionAllowedToAPort
  when == @isWithNumber withNumber :
    val := [[withNumber numberOfPermission] uint];
  when == @isOr isOr :
    val := [[isOr numberOfPermission] uint];
  when == @isAll isAll :
    val := [[isAll numberOfPermission] uint];
  else
    val := 1;
  end cast;
end routine;

#This routine checks that the number of accesses to the device/ports
#does not exceeds the max limits.
routine checkForPortAccessLimits
  ?? @architectureMap architectureMap
  ?? @lstring archName
  ?? @lstring deviceName
  ?? @lstring portName
  ?! @intMap accessMap
  ?! @bool foundStage
:
  #update the uint map to be sure that it does not exceed the limit.
  @lstring lportDev := [@lstring new ![deviceName string]."_".[portName string] !here];
  if [accessMap hasKey ![lportDev string]] then
    #update the value.
    @uint val;
    [accessMap searchKey !lportDev ?val];
    #compare the current value with the max.
    @uint max;
    getMaxPortAccess !architectureMap !archName !deviceName !portName ?max;
    if val >= max then
      #it will exced the max (if the current one is inserted). 
      #We did not found the correct stage.
      foundStage := false;
    else
      #ok. Update the map.
      [!?accessMap removeKey !lportDev ?*];
      [!?accessMap insertKey !lportDev !val+1];
    end if;
  else #insert a new value.
    [!?accessMap insertKey !lportDev !1];
  end if;
#  log accessMap;
end routine;


#This routine maps one instruction on one pipeline path. This is called by
# mapInstructionsOnArchitecture
# exploration is lead by instructions: i.e. At one graph node, we search for the appropriate 
# pipeline stage.
# This routine is recursive: It processes the current nodeRoot and call recursively the 
# routine to process sub-nodes.
routine mapInstructionOnPipelinePath
  ?? @architectureMap architectureMap
  ?? @lstring instName
  ?? @flatPipelineStageList fps #list of pipeline stages.
  ?? @graphNode nodeRoot        #input : graph with component/method.
  ?! @intMap accessMap          #map to record accesses to port devices.
  !  @graphNode portAccessNode  #output: graph with device/port
  ?! @uint nodeId               #to generate the 'portAccessNode' graph.
  !  @bool ok                   #return true if there was no pb.
  ?? @bool debug                #print heavy debug messages.
:
  #process the current node:
  @bool foundStage := false;
  @lstringlist data := [nodeRoot data]; #componentName methodName;
  @flatPipelineStageList copyFps := fps; #this structure will be used in recursives calls.
  @lstring deviceName := [@lstring new !"" !here];
  @lstring portName := [@lstring new !"" !here];
  if [data length] == 2 then #This is not an empty node.
    @lstring componentName;
    @lstring methodName;
    [!?data popFirst ?componentName];
    [!?data popFirst ?methodName];
    if debug then message "\t\tprocessing : ".[componentName string].".".[methodName string].": line ".[[[methodName location] line] string]."\n"; end if;
    #for each stage.
    foreach fps (@lstring pipelineName 
                 @lstring archName 
                 @lstring stageName 
                 @stageBodyList body) while not foundStage do
      #can the component access map on the stage?
      foreach body (@stageBody stageBody) while not foundStage do
        deviceName := [stageBody device];
        @deviceMap deviceMap;
        [architectureMap searchKey !archName ?deviceMap ?*];
        if debug then message "\t\t\tmatching ".[deviceName string]." ? "; end if;
        isComponentMethodMatchingDevice !deviceMap !stageBody !componentName !methodName ?foundStage ?portName;
        if debug then if foundStage then message "yes -> ".[deviceName string].".".[portName string]."\n"; 
        else message "no\n"; end if; end if;
      end foreach;
      #answer is in 'foundStage'. But, even if it matches, does it exceed max port accesses limit?
      if foundStage then
        checkForPortAccessLimits !architectureMap !archName !deviceName
                                 !portName !?accessMap !?foundStage;
        if debug & not foundStage then message "\t\t\t\t-> but excess port access limits\n"; end if;
      end if;
      if not foundStage then #not a 'else' case, because the bool may have change in the 'if'.
        #This stage does not fit. Try the next one.
        [!?copyFps popFirst ?* ?* ?* ?*];
        accessMap := [@intMap emptyMap]; #new stage -> reset accessMap.
      end if;
    end foreach;
  else #no data in node -> empty node. Don't use it.
    foundStage := true;
  end if;
  if foundStage then
    #we found a stage: start recursion and set node.
    @graphNodeList subNodeList [emptyList];
    @bool subOk := true;
    foreach [nodeRoot nextNodeList] (@graphNode subnode) while subOk do
      @graphNode portAccessSubNode;
      @intMap accessMapSubNode := accessMap; #make a copy for subnodes.
      mapInstructionOnPipelinePath !architectureMap !instName !copyFps !subnode !?accessMapSubNode ?portAccessSubNode !?nodeId ?subOk !debug;
      subNodeList += !portAccessSubNode;
    end foreach;
    ok := subOk; #ok since all subnodes are ok and current stage is ok.
    @lstringlist data [emptyList];
    @string strId := "";
    if [[nodeRoot data] length] == 2 then #This is not an empty node.
      data += !deviceName;
      data += !portName;
      strId .= [deviceName string]."_".[portName string];
    else
      strId .= "empty";
    end if;
    @string uid := getGraphNodeUniqueId[!"strId" ! subNodeList];
    portAccessNode := [@graphNode new !data !subNodeList !uid];
    nodeId := nodeId + 1;
  else
    #we did not found a stage. The instruction can not map on the pipeline.
    #This is not an error: it may map on another pipeline path.
    portAccessNode := [@graphNode new ![@lstringlist emptyList] ![@graphNodeList emptyList] !"empty"];
    ok := false;
  end if;
end routine;

#a map that contains a graphNodeMap...
#This data structure is used because each instruction can have several graphs, 
#depending on the pipeline path.
#so the first Key is the instruction name. Then it returns a second map on which
#key is the pipeline path name.
map @graphNodeMapMap {
  @graphNodeMap graphNodeMap;
  insert insertKey error message "the '%K' value is already defined in %L" ; 
  search searchKey error message "the '%K' value is not defined" ;
  remove removeKey error message "the '%K' value is not defined and cannot be removed." ;
}

#This routine maps instructions on the pipeline:
#entry is the graph of components access for each instructions.
#output is the same graph for each instruction, but component accesses are replaced by
#device/port access.
routine mapInstructionsOnArchitecture
  ?? @architectureMap architectureMap
  ?? @pipelineMap pipelineMap
  ?? @instructionPipelinePathList ippList
  ?? @graphNodeMap componentAccessMap
  !  @graphNodeMapMap portAccessMap 
  ?? @string modelName
  ?! @TfieldMap templateStruct
:
  #first, extract the pipeline paths into flatPipelineStageList (and log)
  @string logStr := "";
  @flatPipelineStageListList fpsList [emptyList];
  foreach ippList (@instructionPipelinePath ipp) do
    @string str;
    getInstructionPipelinePathString !ipp ?str;
    @flatPipelineStageList fps;
    getListOfPipelineStages !pipelineMap !ipp ?fps;
    logStr .= "<h2>Pipeline sequence ".str."</h2>\n";
    logFlatPipelineStageList !fps !?logStr;
    fpsList += !fps !str;
  end foreach;
  addStringValue !?templateStruct !lstringWith[!"HTML_LOG_PIPELINE_PATHS"] !logStr;  
  #ok. All is in fpsList (and a log file).
  portAccessMap := [@graphNodeMapMap emptyMap];
  #for each instruction
  @TfieldMapList instMapping [emptyList];
  foreach componentAccessMap (@lstring instName @graphNode nodeRoot) do
    @TfieldMap instMappingBody [emptyMap];
    addLStringValue !?instMappingBody !"name" !instName;
    @graphNodeMap portAccessMapForInstruction [emptyMap];
    @uint nbSolution := 0;
    #search for a valid pipeline path.
#    message "try to map ".instName.":\n";
    @bool foundAPath := false;
    @TfieldMapList instMappingOnPipeline [emptyList];
    foreach fpsList (@flatPipelineStageList fps @string fpsLog) do
      @TfieldMap instMappingOnPipelineBody [emptyMap];
      @graphNode portAccessNode;
#      message "\ton ".fpsLog."..";
      #This map is used to record accesses to port devices.
      # key is device'_'port. val is the number of times it has been used.
      @intMap accessMap [emptyMap];
      @uint nodeId := 0;
      @bool ok;
      mapInstructionOnPipelinePath !architectureMap !instName !fps !nodeRoot !?accessMap ?portAccessNode !?nodeId ?ok !false;
      foundAPath := foundAPath | ok;
      addStringValue !?instMappingOnPipelineBody !lstringWith[!"pipelineName"] !fpsLog;
      if ok then
        [!?portAccessMapForInstruction insertKey ![@lstring new !fpsLog !here] !portAccessNode];
        @string graphVizContent := graphNodeOutput[!portAccessNode ![instName string]];
        @string exportFileName := [instName string]."-dev".nbSolution;
        createFile !modelName."/log" !exportFileName.".dot" !graphVizContent;
        addStringValue !?instMappingOnPipelineBody !lstringWith[!"file"] !exportFileName;
        nbSolution ++;
#        message "ok\n";
      end if;
      instMappingOnPipeline += !instMappingOnPipelineBody;
    end foreach;
    addListValue   !?instMappingBody !lstringWith[!"pipelineList"] !instMappingOnPipeline;
    #not found -> cannot map.
    if not foundAPath then
      error instName: "The instruction ".instName." cannot map on the pipeline architecture. Here is the full log of mapping process:";
      #now get the full log.
      foreach fpsList (@flatPipelineStageList fps @string fpsLog) do
        message "\tTry to map ".instName." on ".fpsLog."..\n";
        @intMap accessMap [emptyMap];
        @uint nodeId := 0;
        mapInstructionOnPipelinePath !architectureMap !instName !fps !nodeRoot !?accessMap ?* !?nodeId ?* !true;
      end foreach;
    end if;
    [!?portAccessMap insertKey !instName !portAccessMapForInstruction];
    instMapping += !instMappingBody;
  end foreach;
  addListValue   !?templateStruct !lstringWith[!"instMappingOnPipeline"] !instMapping;
end routine;

#list of data (device/port)
list @stringlistList
{
  @stringlist stringlist;
}

list @lstringlistList
{
  @lstringlist stringlist;
}

routine mergeListsOfDeviceAccess
  ?? @lstringlistList list1Const
  ?? @lstringlistList list2Const
  !  @lstringlistList listOut
:
  @lstringlistList list2 := list2Const;
  listOut := [@lstringlistList emptyList];
  foreach list1Const (@lstringlist data1) do
    listOut += !data1;
    #search for 'data1' in the 2nd list.
    @lstringlistList list2Copy [emptyList];
    @bool found := false;
    foreach list2 (@lstringlist data2) do
      #same entry found.
      if not found then
        if [data2 length] == [data1 length] then
          @bool ok := true;
          foreach data1 (@lstring str1),data2 (@lstring str2) while ok do
            ok := ok & ([str1 string] == [str2 string]);
          end foreach;
          if ok then #the same
            found := true;
          else
            list2Copy += !data2;
          end if;
        else 
          list2Copy += !data2;
        end if;
      else #already found. Just copy the list.
        list2Copy += !data2;
      end if;  
    end foreach;
    #ok. get a copy of list2, without the value in list1
    list2 := list2Copy;
  end foreach;
  foreach list2 (@lstringlist data2) do
    listOut += !data2;
  end foreach;
end routine;

#This routine only checks the mergeListsOfDeviceAccess routine... 
#Not called in the Harmless compiler.
#first list:  A-B
#second list: C-B-B-C-AB
#merge should give: A-B-C-B-C-AB
routine testMergeListsOfDeviceAccess
:
  @lstringlistList list1 [emptyList];
  @lstringlistList list2 [emptyList];
  @lstringlist strListA [emptyList];
  strListA += ![@lstring new !"A" !here];
  @lstringlist strListB [emptyList];
  strListB += ![@lstring new !"B" !here];
  @lstringlist strListC [emptyList];
  strListC += ![@lstring new !"C" !here];
  @lstringlist strListAB [emptyList];
  strListAB += ![@lstring new !"A" !here];
  strListAB += ![@lstring new !"B" !here];
  list1 += !strListA;
  list1 += !strListB;
  list2 += !strListC;
  list2 += !strListB;
  list2 += !strListB;
  list2 += !strListC;
  list2 += !strListAB;
  @lstringlistList listOut;
  mergeListsOfDeviceAccess !list1 !list2 ?listOut;
  foreach listOut(@lstringlist strList) do
    foreach strList(@lstring str) do
      message [str string];
    end foreach;
  between
    message "-";
  end foreach;
  message "\n";
end routine;


#This routine gets in the graph to extract the max number of device access required.
# for example, the code
# val := ALU.read32(regIndex);
# if val != 0 then
#   val := mem.read32(val)
# end if
# will generate the graph:
# ALU.read32
#    |  \
#    |   \
#    |    mem.read32
#    |    /
#    |  /
#, then, through the graph with devices generates:
# ALUDev.rs
#    |  \
#    |   \
#    |    memDev.read
#    |    /
#    |  /
#This routine gets the lists:
# ALUDev.rs -> memDev.read, as it has the maximum length.
routine getMaxBranchAccess
  ?? @graphNode node
  ?! @lstringlistList dataList
:
  dataList += ![node data];
  @lstringlistList maxDataList [emptyList];
  foreach [node nextNodeList] (@graphNode next) do
    @lstringlistList currentBranchDataList [emptyList];
    getMaxBranchAccess !next !?currentBranchDataList;
    @lstringlistList newMaxDataList;
    #Ok, then get the max between maxDataList and currentBranchDataList.
    mergeListsOfDeviceAccess !maxDataList !currentBranchDataList ?newMaxDataList;
    maxDataList := newMaxDataList;
  end foreach;
  foreach maxDataList (@lstringlist data) do
    dataList += !data;
  end foreach;
end routine;

sortedlist @devicePortAccessList {
  @string device;
  @string port;
  @uint nbCall;
}{
  device >, port >, nbCall >
}

function getdevicePortAccessListString
  ?? @devicePortAccessList dpal
  -> @string str
:
  str := "";
  foreach dpal (@string device @string port @uint nbCall) do
    str .= device.".".port." (".[nbCall string].")";
  between
    str .= " - ";
  end foreach;
end function;

function compareDevicePortAccessList
  ?? @devicePortAccessList list1
  ?? @devicePortAccessList list2
  ->  @bool same
:
  same := [list1 length] == [list2 length];
  foreach list1 (@string device1 @string port1 @uint nbCall1), 
          list2 (@string device2 @string port2 @uint nbCall2) while same do
    same := (device1 == device2) & (port1 == port2) & (nbCall1 == nbCall2);
  end foreach;
end function;

function compareInstructionClasses
  ?? @instructionClass ic1
  ?? @instructionClass ic2
  ->  @bool same
:
  same := [ic1 count] == [ic2 count]; #should be ok for the same nb of pipelines.
  foreach ic1 (@lstring pipe1 @devicePortAccessList dpal1) while same do
    if [ic2 hasKey ![pipe1 string]] then
       @devicePortAccessList dpal2;
      [ic2 searchKey !pipe1 ?dpal2];
      same := compareDevicePortAccessList[!dpal1 !dpal2];
    else
      same := false; #ic1 is ok for that pipeline, but not ic2.
    end if;
  end foreach;
end function;

function getKeyForStringList
  ?? @lstringlist data
  -> @string key
:
  key := "";
  foreach data (@lstring str) do
    key .= [str string];
  between
    key .= ".";
  end foreach;
end function;

function getDevicePortAccessListFromFlatList
 ?? @lstringlistList flatList
 -> @devicePortAccessList outList
:
  outList := [@devicePortAccessList emptySortedList];
  @lstringlistList flatListCopy := flatList;
  @intMap intMap [emptyMap];
  foreach flatList (@lstringlist data) do
    if [data length] == 2 then
      @string key := getKeyForStringList[!data];
      @lstring lkey := [@lstring new !key !here];
      @uint nb := 1;
      if [intMap hasKey !key] then
        [intMap searchKey !lkey ?nb];
        nb := nb + 1;
        [!?intMap removeKey !lkey ?*];
      end if;
      [!?intMap insertKey !lkey !nb];
    end if;
  end foreach;
  foreach flatList (@lstringlist data) do
    if [data length] == 2 then
      @string key := getKeyForStringList[!data];
      @lstring lkey := [@lstring new !key !here];
      if [intMap hasKey !key] then
        @uint nb;
        [intMap searchKey !lkey ?nb];
        @lstring deviceName;
        @lstring portName;
        @lstringlist dataCopy := data;
        [!?dataCopy popFirst ?deviceName];
        [!?dataCopy popFirst ?portName];
        outList += ![deviceName string] ![portName string] !nb;
        [!?intMap removeKey !lkey ?*]; #only one time.
      end if;
    end if;
  end foreach;
end function;

#stores device/port access for each pipeline path
#This is ONE instruction class. 
#The map is required because there is one list for each pipeline path.
# -> key is the pipeline path.
map @instructionClass {
  @devicePortAccessList devicePortAccessList; 
  insert insertKey error message "the '%K' value is already defined in %L" ; 
  search searchKey error message "the '%K' value is not defined" ;
  remove removeKey error message "the '%K' value is not defined and cannot be removed." ;
}

#store instruction class for each instruction.
map @instructionClassMap {
  @uint id;
  @instructionClass ic; 
  insert insertKey error message "the '%K' value is already defined in %L" ; 
  search searchKey error message "the '%K' value is not defined" ;
  remove removeKey error message "the '%K' value is not defined and cannot be removed." ;
}

#This routine gets the instruction device/port graph for each pipeline path.
#Then, it "flats" graphs, to get the most longest path.
#Then it checks that each pipeline path generate the same "flat" device/port accesses (else an error is generated).
#From the flat list of device/port access, it generates a more usable "@devicePortAccessList"
#Eventually, it generates the instruction class Map: Each instruction that use the same device/port the
#same nb of times is in the same instruction class.
routine extractInstructionClasses
  ?? @graphNodeMapMap portAccessMap
  !  @instructionClassMap icMap
  !  @stringMap instToInstructionClassMap #inst Name is the Key. value is the inst class name.
  ?! @TfieldMap unused templateStruct
:
  icMap := [@instructionClassMap emptyMap];
  instToInstructionClassMap := [@stringMap emptyMap];
  @uint nbIc := 0;
  foreach portAccessMap (@lstring instName @graphNodeMap graphNodeMap) do
    @string htmlLog := "";
    @instructionClass icCurrent [emptyMap];
    htmlLog .= "<h3>Device/Port accesses (with nb of occurences)</h3>";
    foreach graphNodeMap (@lstring pipePath @graphNode deviceGraph) do
      @lstringlistList flatList [emptyList];
      getMaxBranchAccess !deviceGraph !?flatList;
      @devicePortAccessList dpal := getDevicePortAccessListFromFlatList[!flatList];
      [!?icCurrent insertKey !pipePath !dpal];
      htmlLog .= "<p>For ".[pipePath string]." :".getdevicePortAccessListString[!dpal]."</p>\n";
    end foreach;
    #search if there is an instruction class.
    @bool icFound := false;
    @string instClassName := "";
    foreach icMap (@lstring name @uint id @instructionClass ic) while not icFound do
      icFound := compareInstructionClasses[!icCurrent !ic]; #same
      if icFound then
        instClassName := [name string];
        [!?instToInstructionClassMap insertKey !instName !instClassName];
      end if;
    end foreach;
    if not icFound then
      instClassName := "instClass_".[nbIc string];
      [!?icMap insertKey ![@lstring new !instClassName !here] !nbIc !icCurrent];
      [!?instToInstructionClassMap insertKey !instName !instClassName];
      nbIc := nbIc + 1;
    end if;
      
    htmlLog .= "<p>instruction class is <a href=\"instructionClass.html#".instClassName."\">".instClassName."</a></p>\n";
    #addStringValue !?templateStruct !lstringWith[!"HTML_INSTRUCTION_CLASS_EXTRACTION_FOR_INST"] !htmlLog;  
  end foreach;
  if [option .verbose_output value] then
    message "There are ".[icMap count]." instruction classes (before reduction) for ".
            [instToInstructionClassMap count]." instructions.\n";
  end if;
end routine;

#This function simply returns how many times
#a device/port is used in pipelines. (for inst class reduction).
routine nbUsageofDevicePortInPipeline
  ?? @lstring archName
  ?? @lstring deviceName
  ?? @lstring portName
  ?? @pipelineMap pipelineMap
  !  @bool reductionPossible
  !  @uint nb
:
  reductionPossible := true;
  nb := 0;
  foreach pipelineMap (@lstring pipeName @lstring architectureName @stageList stageList) while reductionPossible do
    if [archName string] == [architectureName string] then #same architecture.
      foreach stageList (* @stageBodyList stageBodyList) while reductionPossible do
        foreach stageBodyList (@stageBody stageBody) while reductionPossible do
          if [[stageBody device] string] == [deviceName string] then #same device
            @bool found := false;
            foreach [stageBody portList] (@lstring port) while not found do
              if [portName string] == [port string] then
                #same device/port found. check that its type is not '@isRelease'
                #because it should be associated to an internal resource in that last case.
                cast stageBody
                  when == @isRelease :
                  reductionPossible := false; #Associated to a 'internal resource'.
                else
                  nb := nb+1;
                  found := true;
                end cast;
              end if;
            end foreach;
          end if;
        end foreach;
      end foreach;
    end if;
  end foreach;
end routine;

function maxAccessesToAPortFromInstruction
  ?? @instructionClassMap icMap
  ?? @lstring deviceName
  ?? @lstring portName
  -> @uint max
:
  max := 0;
  foreach icMap (* * @instructionClass ic) do
    foreach ic (* @devicePortAccessList devicePortAccessList) do
      foreach devicePortAccessList (@string device @string port @uint nbCall) do
        if ([deviceName string] == device) & ([portName string] == port) then
          if nbCall > max then
            max := nbCall;
          end if;
        end if;
      end foreach;
    end foreach;
  end foreach;
end function;

routine logInstructionClasses
  ?? @instructionClassMap icMap
  ?? @instructionClassMap newIcMap
  ?? @boolMap devicePortToRemove
  ?! @TfieldMap templateStruct
:
  @string htmlLog := "<h2>Instruction Classes before reduction</h2>";
  foreach icMap (@lstring name * @instructionClass ic) do
    htmlLog .= "<a name=".[name string]."><h3>Instruction class: ".[name string]."</h3></a>\n";
    foreach ic (@lstring pipe @devicePortAccessList devicePortAccessList) do
      htmlLog .= "<p><strong>".[pipe string]."</strong>:";
      foreach devicePortAccessList (@string device @string port @uint nbCall) do
        htmlLog .= device.".".port."(".[nbCall string].")";
      between
        htmlLog .= " -- ";
      end foreach;
      htmlLog .= "</p>\n";
    end foreach;
  end foreach;
  htmlLog .= "<h2>Device/Port that can be removed</h2>";
  htmlLog .= "<p>Some Device/port can be removed because they never cause any structural hazard inside the pipeline.</p>";
  foreach devicePortToRemove (@lstring key) do
    htmlLog .= "<p>".[key string]."</p>\n";
  end foreach;
  htmlLog .= "<h2>Instruction Classes after reduction</h2>";
  htmlLog .= "<p>Id 0 is reserved for stalls (no instruction).</p>";
  foreach newIcMap (@lstring name * @instructionClass ic) do
    htmlLog .= "<a name=".[name string]."><h3>Instruction class: ".[name string]."</h3></a>\n";
    foreach ic (@lstring pipe @devicePortAccessList devicePortAccessList) do
      htmlLog .= "<p>".[pipe string].":";
      foreach devicePortAccessList (@string device @string port @uint nbCall) do
        htmlLog .= device.".".port."(".[nbCall string].")</p>\n";
      end foreach;
    end foreach;
  end foreach;
  
  addStringValue !?templateStruct !lstringWith[!"HTML_INSTRUCTION_CLASSES"] !htmlLog;  
end routine;

routine updateInstructionClasses
  ?? @instructionClassMap icMap
  !  @instructionClassMap newIcMap
  ?! @stringMap instToInstructionClassMap #inst Name is the Key. value is the inst class name.
  ?? @boolMap devicePortToRemove
:
  newIcMap := [@instructionClassMap emptyMap];
  @stringMap pastToNewInstructionClass [emptyMap]; #Key is old ic, data is new ic.
  @uint id := 1; #id = 0 is reserved for stalls.
  foreach icMap (@lstring icName * @instructionClass ic) do
    @instructionClass newIc [emptyMap];
    foreach ic (@lstring pipeName @devicePortAccessList devicePortAccessList) do
      #update @devicePortAccessList for the instruction class.
      @devicePortAccessList newDevicePortAccessList [emptySortedList];
      foreach devicePortAccessList (@string device @string port @uint nbCall) do
        #is this device/port removable.
        @string key := device.".".port;
        if not [devicePortToRemove hasKey !key] then #not removable.
          newDevicePortAccessList += !device !port !nbCall;
        end if;
      end foreach;
      [!?newIc insertKey !pipeName !newDevicePortAccessList];
    end foreach;  
    #then look if there is already an instruction class.
    @bool icFound := false;
    foreach newIcMap (@lstring name * @instructionClass ic) while not icFound do
      icFound := compareInstructionClasses[!ic !newIc]; #same
      if icFound then
        [!?pastToNewInstructionClass insertKey !icName ![name string]];
      end if;
    end foreach;
    if not icFound then
      @lstring newIcName := [@lstring new !"reducedInstClass_".[id string] !here];
      [!?newIcMap insertKey !newIcName !id !newIc];
      [!?pastToNewInstructionClass insertKey !icName ![newIcName string]];
      id := id + 1;
    end if;
  end foreach;
  #update map that make the link between instruction name and instruction class.
  @stringMap newInstToInstructionClassMap [emptyMap];
  foreach instToInstructionClassMap (@lstring key @string oldIcName) do
    @string newIcName;
    [pastToNewInstructionClass searchKey ![@lstring new !oldIcName !here] ?newIcName];
    [!?newInstToInstructionClassMap insertKey !key !newIcName];
  end foreach;
  instToInstructionClassMap := newInstToInstructionClassMap;
  if [option .verbose_output value] then
    message "After reduction, there are ".[newIcMap count]." instruction classes\n";
  end if;
  #debug.
#  foreach pastToNewInstructionClass (@lstring old @string new) do
#    message "\tinstruction class ".[old string]." -> ".new."\n";
#  end foreach;
#  foreach instToInstructionClassMap (@lstring key @string newIcName) do
#    message "\t".[key string]." -> ".newIcName."\n";
#  end foreach;
end routine;

#to reduce instruction Classes, we iterate on each device/port (for each pipeline)
#if port is either shared or released in another port -> keep it.
#if the device/port is used only one time => remove it.
#if it is used many times, calculate the max simultaneous accesses that are possible.
#It informs if the port may be removed or not.
routine reduceInstructionClasses
  ?? @architectureMap architectureMap
  ?? @pipelineMap pipelineMap
  ?! @instructionClassMap icMap
  ?! @stringMap instToInstructionClassMap #inst Name is the Key. value is the inst class name.
  ?! @TfieldMap templateStruct
  !  @boolMap devicePortToRemove
:
  if [option .verbose_output value] then
    message "reduce instruction classes\n";
  end if;
  #first get the "removable list": that contains device/port that can be removed:
  # * not shared
  # * used either 1 time or more, but the maximum access is not achieved.
  # * without the 'release' attribute in any pipeline stage.
  devicePortToRemove := [@boolMap emptyMap]; #device.port
  foreach architectureMap (@lstring archName @deviceMap deviceMap *) do
    foreach deviceMap (@lstring deviceName * @portMap portMap * *) do
      foreach portMap (@lstring portName @bool isShared @functionAllowedToAPort functionAllowedToAPort) do
        if not isShared then
          @uint nbUsage;
          @bool reductionPossible;
          nbUsageofDevicePortInPipeline !archName !deviceName !portName !pipelineMap ?reductionPossible ?nbUsage;
          if reductionPossible then
            #message "\t".[deviceName string].".".[portName string]." usage: ".[nbUsage string]."\n";
            if nbUsage > 1 then
              #more than 1 access to the port. Get the max number of // access to port:
              @uint maxParallelAccess;
              cast functionAllowedToAPort
              when == @isWithNumber isWithNumber :
                maxParallelAccess := [[isWithNumber numberOfPermission] uint];
              else
                maxParallelAccess := 1;
              end cast;
              #get the max accesses from 1 inst.
              @uint maxFromInst := maxAccessesToAPortFromInstruction[!icMap !deviceName !portName];
              #worst case, is with this instruction class at each pipeline stage that accesses the port:
              if maxFromInst*nbUsage > maxParallelAccess then
                reductionPossible := false;
              end if;
            end if;
          #else
          #  message "\t".[deviceName string].".".[portName string]." without reduction.\n";
          end if;
          if reductionPossible then
            @string key := [deviceName string].".".[portName string];
            [!?devicePortToRemove insertKey ![@lstring new !key !here]];
            if [option .verbose_output value] then
              message "\t".key." can be removed\n";
            end if;
          end if;
        end if;
      end foreach;
    end foreach;
  end foreach;
  #then we rebuild the instruction class list without uneeded device/ports.
  @instructionClassMap newIcMap;
  updateInstructionClasses !icMap ?newIcMap !?instToInstructionClassMap !devicePortToRemove;
  logInstructionClasses !icMap !newIcMap !devicePortToRemove !?templateStruct;
  icMap := newIcMap; #replace instruction class Map
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
