syntax gadl_hard_component_parser ("gadl_lexique.gLexique") :

import "gadl_semantics.gSemantics" ;
import "gadl_semantics_memory.gSemantics" ;
import "gadl_semantics_peripherals.gSemantics" ;

#from expression.
nonterminal  <bitField> 
  ?? @varMap varMap 
  ?? @componentMap componentMap 
  ?? @bool allowExpression 
  !  @fieldList fieldList 
  ?! @varType type
  ?? @expressionContext expContext
;

#implementation related rules
nonterminal  <implementation> 
  ?! @varMap varMap 
  ?! @instructionList instList 
  ?? @componentMap componentMap
  ?? @lstring currentComponent
  ?? @expressionContext expContext
  ?? @returnTypeList returnList
;
nonterminal  <typeDeclaration> 
  !  @varType type
  ?? @componentMap componentMap
  ?? @lstring compName
  ;
nonterminal <newTypeDeclaration>
  !  @lstring idf
  !  @TypeDef Type
  ?? @componentMap componentMap
  ?? @lstring compName
;
nonterminal  <basicDeclaration> 
  ?? @varType type 
  ?? @lstring idf
  ?? @bool isConstant
  ?? @bool noDeclarationInstruction
  ?? @bool isRegister
  ?! @varMap varMap 
  ?! @instructionList instList
  ?? @componentMap componentMap
  ?? @string prefix
  ?! @uint tmpId
  ?? @expressionContext expContext
  !  @bool assign #return true if there is an assignment
;

#expression related rules
nonterminal  <expression>
  ?? @varMap varMap
  !  @cExpression outExp
  ?? @componentMap componentMap
  ?? @uint tmpId
  ?? @expressionContext expContext
;

nonterminal  <parameterDef> 
  ?? @string prefix
  ?! @parameterDefList param 
  ?! @varMap varMap
;

#peripherals related rule.
nonterminal <actionOnReadOrWrite>
  ?! @varMap globalVarMap 
  ?! @readWriteActionList readWriteActionList
;

nonterminal <cyclicPart>
  ?! @varMap globalVarMap
  ?? @lstring currentComponent
  ?! @uint nbCyclicParts #id used to identify "foreach" sections.
  ?! @cyclicPartList cyclicPartList
;

############################ both memory and component description part ################
rule <programCounterDef>
  ?! @varMap globalVarMap 
  ?? @expressionContext expContext
:
  #$program$ terminal already called.
  $counter$;
  @varType type;
  @componentMap componentMap := [@componentMap emptyMap];
  @lstring compName:= [@lstring new !"CompNameNotDefined" !here];
  <typeDeclaration> ?type !componentMap  !compName;
  if [type kind] != [@varKind unsigned] then
    error here: "The program counter register must be declared unsigned.";
  end if;
  @lstring pcName;
  $idf$ ? pcName;
  @registerVar variable;
  if expContext == [@expressionContext memory] then
    variable := [@registerVar new !type !false ![@regType  memoryProgramCounter]]; #reg definition. Type is program counter
  elsif expContext == [@expressionContext component] then
    variable := [@registerVar new !type !false ![@regType  componentProgramCounter]]; #reg definition. Type is program counter
  else
    error here: "A program counter should not be defined in ".[expContext msg] : variable;
  end if;
  [!?globalVarMap insertKey !pcName !variable];
end rule;

############################ memory description part ################
rule <memoryChunk>
  ?! @memoryChunkMap memoryChunkMap 
  ?! @varMap globalVarMap 
  ?? @bool isProg
  !  @lstring memName
:

  $memory$;
  select
    $idf$ ? memName;
  or
    #no name specified. give a default one. There can have only one unamed memory chunk per component.
    memName := [@lstring new !"default" !here];
  end select;
  ${$;
  @varMap aliasMap [emptyMap];
  #memory params.
  @uint stride := 1;
  @uint width := 8;
  @uint fromAddr := 0;
  @uint toAddr := 0;
  @uint type := 0;

  @memoryAliasMap memoryAliasMap [emptyMap];
  @memoryConstList memoryConstList [emptyList];

  @memoryChunkAliasMap memoryChunkAliasMap [emptyMap];
  repeat
  while
    <memoryParam> !?stride !?width !?fromAddr !?toAddr !?type;
  while 
    <regAliasDefAndConst> !?aliasMap !width !?memoryAliasMap !?memoryConstList !?globalVarMap !fromAddr !toAddr !stride;
  while
    @lstring chunkAliasName;
    $idf$ ?chunkAliasName;
    select 
      #constant def:ex: "R0 is read 0"
      @luint64 cst;
      <regConstDef> ?cst;
      @uint addr;
      #TODO: check that size is correct.
      [memoryAliasMap searchKey !chunkAliasName ?* ?addr ?* ?*];
      memoryConstList += !addr ![cst uint64];
    or
      #memory chunk alias. ex: internalRAM { stride := 2; type := RAM; } maps to \xFC00
      <memChunkAlias> !chunkAliasName !aliasMap !stride !width !type !?memoryChunkAliasMap !?globalVarMap;
    end select;
  end repeat; 
  if toAddr == 0 then 
    error here: "no address range given in memory description";
  end if;
  @memoryParam param := [@memoryParam new !stride !width !fromAddr !toAddr !type !isProg];
  $}$;
  [!?memoryChunkMap insertKey !memName !param !memoryAliasMap !memoryConstList !memoryChunkAliasMap];
end rule;

rule <memChunkAlias> 
  ?? @lstring chunkAliasName
  ?? @varMap aliasMap
  ?? @uint heritedStride
  ?? @uint heritedWidth
  ?? @uint heritedType
  ?! @memoryChunkAliasMap memoryChunkAliasMap
  ?! @varMap globalVarMap 
:
  @varMap memChunkAliasMap := [@varMap mapWithMapToOverride !aliasMap];
  #local aliases and consts. (offset not taken into account yet ).
  @memoryAliasMap memoryAliasMap [emptyMap];
  @memoryConstList memoryConstList [emptyList];
  ${$;
  #memory params.
  @uint stride := heritedStride;
  @uint width := heritedWidth;
  @uint type := heritedType;
  @uint fromAddr := 0;
  @uint toAddr := 0;
  repeat
  while
    <memoryParam> !?stride !?width !?fromAddr !?toAddr !?type;
  while 
    @lstring regAliasName;
    $idf$ ? regAliasName;
    #constant def:ex: "R0 is read 0"
    @luint64 cst;
    <regConstDef> ?cst;
    @uint addr;
    #TODO: check that size is correct.
    [memoryAliasMap searchKey !regAliasName ?* ?addr ?* ?*];
    memoryConstList += !addr ![cst uint64];
  while 
    <regAliasDefAndConst> !?memChunkAliasMap !width !?memoryAliasMap !?memoryConstList !?globalVarMap !fromAddr !toAddr !stride;
  end repeat;
  #isProg parameter not used in aliases.
  @memoryParam param := [@memoryParam new !stride !width !fromAddr !toAddr !type !false]; 
  $}$;
  @cExpression exp;
  select
    $maps$; $to$;
    @componentMap dummyComponentMap [emptyMap]; #no component call allowed.
    #outType not used.
    <expression> !memChunkAliasMap ?exp !dummyComponentMap !0 ![@expressionContext memory];
  or
    #no "maps to". Default is 0.
    exp := [@cIntConst new !getTypeListFrom[![@varType new ![@varKind unsigned] !0 !here]] !0L !false];
  end select;
  [!?memoryChunkAliasMap insertKey !chunkAliasName !param !memoryAliasMap !memoryConstList !exp];
end rule;

rule <regConstDef>
  !  @luint64 cst
:
  $is$; $read$;
  $unumber$ ? cst;
end rule;

rule <registerBitAccess>
  ?? @lstring regName
  ?? @uint registerSize
  !  @registerBitFieldList registerBitFieldList 
  ?! @varMap globalVarMap 
  ?? @expressionContext expContext
:
  registerBitFieldList := [@registerBitFieldList emptyList];
  ${$;
  repeat
  while
    @lstring bitFieldName;
    $idf$ ?bitFieldName;
    $:=$; $slice$;
    @varType typeSlice := [@varType new ![@varKind unsigned] !registerSize !here]; #TODO...
    @fieldList fieldList;
    @componentMap dummyMap [emptyMap];
    <bitField> !globalVarMap !dummyMap !true ?fieldList !?typeSlice ![@expressionContext memory]; #allow expression.. useful?
    registerBitFieldList += !bitFieldName !fieldList;
    
    @string bitAccessName := [regName string]."_".[bitFieldName string];
    @uint bitFieldSize;
    getFieldListSize !fieldList ?bitFieldSize;
    @varType type := [@varType new ![@varKind unsigned] !bitFieldSize !here]; #unsigned.
#    message "reg field : ".bitAccessName.", size is ".[bitFieldSize string]."\n";
    @registerVar variable;
    if expContext == [@expressionContext memory] then
      variable := [@registerVarSlice new !type !false ![@regType  memoryRegisterPart] !regName]; #reg definition. 
    elsif expContext == [@expressionContext component] then
      variable := [@registerVarSlice new !type !false ![@regType  componentRegisterPart] !regName]; #reg definition. 
    else
      error here: "A register slice should not be defined in ".[expContext msg] :variable;
    end if;
    [!?globalVarMap insertKey ![@lstring new !bitAccessName !here] !variable]; #for access in behaviors (global use)
  end repeat;
  $}$;
end rule;

rule <regAliasDefAndConst>
  ?! @varMap aliasMap
  ?? @uint defaultSize
  ?! @memoryAliasMap memoryAliasMap 
  ?! @memoryConstList memoryConstList
  ?! @varMap globalVarMap 
  ?? @uint fromAddr #used to check that the "maps to" is in the range.
  ?? @uint toAddr   #used to check that the "maps to" is in the range.
  ?? @uint stride   #used to check that the "maps to" is in the range.
:
  @lstring regAliasName;
  @bool isConstant := false;
  $register$;
  @uint size;
  select 
    size := defaultSize;
  or
    @varType type;
    @componentMap componentMap := [@componentMap emptyMap];
    @lstring compName:= [@lstring new !"CompNameNotDefined" !here];
    <typeDeclaration> ?type !componentMap  !compName ;
    if [type kind] == [@varKind signed] then
      error here: "a register must be declared unsigned.";
    elsif [type kind] == [@varKind float] then
      error here : "internal error: float registers not yet implemented";
    end if;
    size := [type size];
  end select;
  if size > defaultSize then 
    error here: "the register size (".[size string]." bits) should be lower or equal than default memory access size (".[defaultSize string]." bits)";
  end if;
  $idf$ ? regAliasName;
  $maps$; $to$;
  @luint64 tmpAddr;
  $unumber$ ? tmpAddr;
  @luint addr := [@luint new ![[tmpAddr uint64] uint] ![tmpAddr location]];
  @registerBitFieldList registerBitFieldList [emptyList];
  if (([addr uint]*stride) < fromAddr) | (([addr uint]*stride) > toAddr) then
    error here: "the register allocation is not in the memory range.";
  end if;
  @luint64 resetVal := [@luint64 new !0L !here];
  select
    #nothing. register alias definition.
  or
    $:=$;
    $unumber$ ? resetVal;
  or
    <registerBitAccess> !regAliasName !size ?registerBitFieldList !?globalVarMap ![@expressionContext memory];
  or
    $is$; $read$;
    @luint64 val;
    $unumber$ ? val;
    memoryConstList += ![addr uint] ![val uint64];
    isConstant := true;
  end select;
  if defaultSize == 0 then
    error here: "no default size for register defined in memory component...";
  end if;
  [!?memoryAliasMap insertKey !regAliasName !size ![addr uint] !registerBitFieldList !resetVal]; #idf <-> addr
  @varType type := [@varType new ![@varKind unsigned] !size !here]; #register size is unsigned.
  @registerVar variable := [@registerVar new !type !isConstant ![@regType memoryRegister]]; #reg definition.
  [!?aliasMap insertKey !regAliasName !variable];     #for code generation (memory internal use)
  [!?globalVarMap insertKey !regAliasName !variable]; #for access in behaviors (global use)
end rule;

rule <memoryParam>
  ?! @uint stride
  ?! @uint width
  ?! @uint from
  ?! @uint to
  ?! @uint type
:
  select
    $stride$;
    $:=$; 
    @luint64 locUint;
    $unumber$ ? locUint;
    stride := [[locUint uint64] uint];
  or
    $width$;
    $:=$; 
    @luint64 locUint;
    $unumber$ ? locUint;
    width := [[locUint uint64] uint];
  or
    $address$;
    $:=$; 
    @luint64 locUint;
    $unumber$ ? locUint;
    from := [[locUint uint64] uint];
    $..$;
    @luint64 locUint2;
    $unumber$ ? locUint2;
    to := [[locUint2 uint64] uint];
  or
    $type$;
    $:=$; 
    select
      $ROM$;
      type := 0;
    or
      $RAM$;
      type := 1;
    or
      $register$;
      type := 2;
    end select;
  end select;
end rule;

################################# component part ###############################
routine mixComponentAndGlobalVarMap
 ?? @varMap globalVarMap 
 ?? @varMap componentOnlyVarMap 
 !  @varMap componentVarMap
:
  #This 4 next lines are required, because both local map (component) 
  # and global map (for register) may change.
  componentVarMap := [@varMap mapWithMapToOverride !globalVarMap];
  foreach componentOnlyVarMap (@lstring name @abstractVar var) do
    [!?componentVarMap insertKey !name !var];
  end foreach;
end routine;

rule <componentRegisterDeclaration>
  ?! @varMap globalVarMap
  ?? @componentMap componentMap
  ?! @instructionList componentDeclarationList
  ?! @memoryAliasMap memoryAliasMap
:
  $register$;
  @varType type;
  @lstring compName:= [@lstring new !"CompNameNotDefined" !here];
  <typeDeclaration> ?type !componentMap  !compName;
  if [type kind] == [@varKind signed] then
    error here: "a register must be declared unsigned.";
  elsif [type kind] == [@varKind float] then
    error here : "internal error: float registers not yet implemented";
  end if;

  @lstring idf;
  $idf$ ? idf;
  #message "size of ".[idf string].": ".[[type size] string]."\n";
  @registerBitFieldList registerBitFieldList;
  @luint64 resetVal := [@luint64 new !0L !here];
  select
    registerBitFieldList := [@registerBitFieldList emptyList];
  or
    <registerBitAccess> !idf ![type size] ?registerBitFieldList !?globalVarMap ![@expressionContext component];
  end select;
  #select
  #or
  #  $:=$;
  #  $unumber$ ?resetVal;
  #end select;
  @uint tmpId := 0; #used to get unique tmp variable names.
  <basicDeclaration> !type !idf !false !true !true !?globalVarMap !?componentDeclarationList !componentMap !"" !?tmpId ![@expressionContext component] ?*;
  [!?memoryAliasMap insertKey !idf ![type size] !0 !registerBitFieldList !resetVal]; #address set to 0 -> not used.
end rule;

rule <component> 
  ?! @varMap globalVarMap 
  ?! @componentMap componentMap
  ?! @uint nbCyclicParts #id used to identify "foreach" sections.
:
  #first pass. get only prototypes.
  @lstring compName;
  $component$; 
  $idf$ ?compName; 
  ${$;
  @varMap componentOnlyVarMap := [@varMap emptyMap];
  @functionMap methodMap := [@functionMap emptyMap];
  @instructionList componentDeclarationList := [@instructionList emptyList];
  @memoryChunkMap memoryChunkMap [emptyMap];
  @memoryAliasMap memoryAliasMap [emptyMap]; #registers declared outside of memory parts.
  @readWriteActionList readWriteActionList [emptyList];
  @cyclicPartList cyclicPartList [emptyList];
  @TypeStructDefMap TypeList [emptyMap];
  [!?componentMap insertKey !compName !globalVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !globalVarMap !readWriteActionList !cyclicPartList !TypeList];

  repeat
    select #basic declaration and component functions.
      #declare a register, or an internal var:
      #a register becomes a global var and is accessible everywhere: 
      #  get and set methods are generated automatically
      #  its value is given when displaying internal regs during simulation.
      #an internal variable can only be used in the component (object approach)
      
      @returnTypeList returnList [emptyList];
#      @varType type := [@varType new ![@varKind unsigned] !0 !here]; #TODO: remove.
      select
        if [componentMap hasKey ![compName string]] then
          [!?componentMap removeKey !compName ?* ?* ?* ?* ?* ?* ?* ?* ?*];
        end if;
        #use globalVarMap. Does not take into account component local vars (not needed).
        [!?componentMap insertKey !compName !globalVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !globalVarMap !readWriteActionList !cyclicPartList !TypeList];
        repeat
          #insert the  temporary component, to allow the use of other methods.
          if [componentMap hasKey ![compName string]] then
            [!?componentMap removeKey !compName ?* ?* ?* ?* ?* ?* ?* ?* ?*];
          end if;
          #use globalVarMap. Does not take into account component local vars (not needed).
          [!?componentMap insertKey !compName !globalVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !globalVarMap !readWriteActionList !cyclicPartList !TypeList];
          @varType type;
          <typeDeclaration> ?type !componentMap   !compName;
          returnList += ![@functionOutTypeClassic new !type];
        while 
          $,$;
        end repeat;
      or
        #return no value. return list stays empty.
        $void$;
      end select;
      @lstring idf;
      $idf$ ? idf;
      select
        #declaration
        @string prefix := "gadl_" . [compName string] . "_";
        #This may be the declaration of a variable, in that case, the 'returnList' size should be 1
        # and only 1.
        if [returnList length] != 1 then
          error here: "invalid declaration of a variable.";
        end if;
        @functionOutType firstOut;
        [returnList first ?firstOut];
        @varType typeVar;
        cast firstOut
        when == @functionOutTypeClassic classicOut :
          typeVar := [classicOut outType];
        else
          error here: "internal error with return type.." :typeVar;
        end cast;
        #classic var. No generation of the variable declaration instruction.
        @uint tmpId := 0; #used to get unique tmp variable names.
        <basicDeclaration> !typeVar !idf !false !true !false !?componentOnlyVarMap !?componentDeclarationList !componentMap !prefix !?tmpId ![@expressionContext component] ?*;
      or
        #method
        @varMap componentVarMap;
        mixComponentAndGlobalVarMap !globalVarMap !componentOnlyVarMap ?componentVarMap;
        @parameterDefList paramList := [@parameterDefList emptyList];
        @instructionList code;
        #insert the  temporary component, to allow the use of other methods.
        if [componentMap hasKey ![compName string]] then
          [!?componentMap removeKey !compName ?* ?* ?* ?* ?* ?* ?* ?* ?*];
        end if;
        [!?componentMap insertKey !compName !componentVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !globalVarMap !readWriteActionList !cyclicPartList !TypeList];
        #message "\n\n************* methode *********\n\n" ;
        # log TypeList;
        <componentFunction> !returnList !componentVarMap !?paramList ?code !componentMap !compName;
        #then remove the temporary component
        [!?methodMap insertKey !idf !paramList !returnList !code];
      end select;
    or
      if [componentMap hasKey ![compName string]] then
        [!?componentMap removeKey !compName ?* ?* ?* ?* ?* ?* ?* ?* ?*];
      end if;
      #use globalVarMap. Does not take into account component local vars (not needed).
      [!?componentMap insertKey !compName !globalVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !globalVarMap !readWriteActionList !cyclicPartList !TypeList];
      <componentRegisterDeclaration> !?globalVarMap !componentMap !?componentDeclarationList !?memoryAliasMap;
    or #memory (not for program code)
      @lstring memName;
      <memoryChunk> !?memoryChunkMap !?globalVarMap !false ?memName;
      #It must be called here, because methodMap is modified 
      #and may be used by other component functions.
      addMemoryRelatedMethods !memoryChunkMap !?methodMap !compName !memName;
    or #LL1 restriction: must set the $program$ terminal here.
      $program$;
      select  #memory (can have program code)
        @lstring memName;
        <memoryChunk> !?memoryChunkMap !?globalVarMap !true ?memName;
        #It must be called here, because methodMap is modified 
        #and may be used by other component functions.
        addMemoryRelatedMethods !memoryChunkMap !?methodMap !compName !memName;
      or #program counter register definition.
        <programCounterDef> !?globalVarMap ![@expressionContext component];
      end select;
    or
      <actionOnReadOrWrite> !?globalVarMap !?readWriteActionList;
    or
      <cyclicPart> !?globalVarMap !compName !?nbCyclicParts !?cyclicPartList;
    or
      @lstring name;
      @TypeDef Type;
      if [componentMap hasKey ![compName string]] then
        [!?componentMap removeKey !compName ?* ?* ?* ?* ?* ?* ?* ?* ?*];
      end if;
      #use globalVarMap. Does not take into account component local vars (not needed).
      [!?componentMap insertKey !compName !globalVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !globalVarMap !readWriteActionList !cyclicPartList !TypeList];   
      <newTypeDeclaration>  ?name ?Type !componentMap !compName;
      @lstring key := [@lstring new ![name string] !here];
      [!?TypeList insertKey !key !Type ];
    end select;
  while
  end repeat;

  #get chunks methods may not be called directly.
  if [memoryChunkMap count] != 0 then
    generateGetChunkMethod !compName !memoryChunkMap !?methodMap;
  end if;
  @varMap componentVarMap;
  mixComponentAndGlobalVarMap !globalVarMap !componentOnlyVarMap ?componentVarMap;
  #remove the temporary component in component map, and store the final one.
  if [componentMap hasKey ![compName string]] then
    [!?componentMap removeKey !compName ?* ?* ?* ?* ?* ?* ?* ?* ?*];
  end if;
  [!?componentMap insertKey !compName !componentVarMap !componentDeclarationList !methodMap !memoryChunkMap !memoryAliasMap !componentOnlyVarMap !readWriteActionList !cyclicPartList !TypeList];
  $}$;
end rule;

rule <newTypeDeclaration>
  #Voir @varTypeDef que doit renvoyer newtypeDeclaration
  !  @lstring typedefName
  !  @TypeDef Type
  ?? @componentMap componentMap
  ?? @lstring compName
:
  @varTypeStructDefMap varTypeStructDefMap [emptyMap];
  $typedef$;
  $idf$ ?typedefName;
  ${$;
  repeat
  while
    @varType type;
    @lstring memberName;
    <typeDeclaration> ?type !componentMap !compName;
    $idf$ ?memberName;
    [!?varTypeStructDefMap insertKey !memberName !type];
  end repeat;
  $}$;
  @varKind kind;
  kind := [@varKind type];
  Type := [@TypeDef new !kind !1 !here ![typedefName string] !varTypeStructDefMap];
end rule;

rule <componentFunction> 
  ?? @returnTypeList returnList
  ?? @varMap varMap 
  ?! @parameterDefList paramList 
  !  @instructionList code
  ?? @componentMap componentMap
  ?? @lstring currentComponent
:
  @varMap functionVarMap := [@varMap mapWithMapToOverride !varMap];
  select
  or
    <parameterDef> !"" !?paramList !?functionVarMap; #prefix ""?
  end select;
  ${$;
  code := [@instructionList emptyList];
  <implementation> !?functionVarMap !?code !componentMap !currentComponent ![@expressionContext component] !returnList;
  $}$;
end rule;
end syntax ;
# vim:ft=ggs:ts=2:sw=2
