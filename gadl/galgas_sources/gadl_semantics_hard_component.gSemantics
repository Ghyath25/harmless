semantics gadl_semantics_hard_component:
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_memory.gSemantics" ;
  import "gadl_semantics_hard_pipeline.gSemantics" ;
  import "gadl_templates.gSemantics" ;
  import "gadl_template_data_preparation.gSemantics"; #varMapDeclaration

function getComponentsMethodParam
  ?? @returnTypeList returnTypeList
  ?? @parameterDefList param
  -> @string code
:
  code := "";
  @bool first := true; #for the ',' between arguments.
  @uint id := 0;
  @returnTypeList returnTypeListTemp := returnTypeList;
  #remove the first argument (as the C returns the first argument).
  if [returnTypeListTemp length] > 0 then
    [!?returnTypeListTemp popFirst ?*];
  end if;
  foreach returnTypeListTemp (@functionOutType functionOutType) do
    if not first then
      code .= ", ";
    end if;
    @string typeStr;
    [functionOutType getTypeCString ?typeStr];
    code .= typeStr." &__return__".[id string];  # C++ only!
    id := id + 1;
    first := false;
  end foreach;
  foreach param (@bool out @lstring name @classicVar variable) do
    if not first then 
      code .= ", ";
    end if;
    @varType type := [variable type];
    @string typeStr := [type getCType];
    if out then 
      code .= typeStr; 
      code .= " &";  # C++ only!
    else 
      code .= "const "; 
      code .= typeStr; 
      code .= " "; 
    end if;
    @cIdf idfClass := [@cIdf new !getTypeListFrom[![variable type]] !name !variable];
    code .= [idfClass generateCode !"" !"" ![@codeCtx C]];
    first :=false;
  end foreach;
end function;

#get all vars that are declared as "register", EXCLUDING memory chunks defined as registers.
# (it includes registers defined in memory part, but not in memory regions defined as register).
function getRegisters
  ?? @varMap globalVarMap
  ?? @bool   includeSlices
  -> @varMap regMap
:
  regMap := [@varMap emptyMap];
  foreach globalVarMap(@lstring varName @abstractVar var) do
    cast var
    when == @registerVarSlice rvs :
      if not [regMap hasKey ![[rvs baseRegisterName] string] ] then
        [!?regMap insertKey ![rvs baseRegisterName] !var];
      end if;
      if includeSlices then
        [!?regMap insertKey !varName !var];
      end if;
    when == @registerVar :
      [!?regMap insertKey !varName !var];
    when == @classicVar :
      #nothing.
    else
      error here: "internal error: unknown abstract var.";
    end cast;
  end foreach;
end function;

function getComponentReturnString
  ?? @returnTypeList returnTypeList
  -> @string returnTypeStr
:
  if [returnTypeList length] > 0 then
    @functionOutType firstFunctionOutType;
    [returnTypeList first ?firstFunctionOutType];
    [firstFunctionOutType getTypeCString ?returnTypeStr];
  else #no return.
    returnTypeStr := "void";
  end if;
end function;

##
## New TypeDef function 
##
function getComponentTypeDef
  ?? @TypeStructDefMap TypeDefMap
  -> @TfieldMapList TypeDefList
:
  TypeDefList :=[@TfieldMapList emptyList];
  foreach  TypeDefMap (@lstring name @TypeDef TypeDef) do
    @TfieldMap TypeDefBody [emptyMap]; 
    @TfieldMapList member [emptyList];
    #message "OK TD ".name."  ".[TypeDef idTabType] ;
      
    addLStringValue !?TypeDefBody !"name" !name; 
    foreach [ TypeDef varTypeStructDefMap ] (@lstring namev @varType type )do
      @TfieldMap memberBody [emptyMap];        
      #getDeclaration
      @string decla ;
      [type getDeclaration ?decla ![namev string] ];
      addStringValue !?memberBody !lstringWith[!"declaration"] !decla;
      member += !  memberBody;     
      #message "MEMBRE \n";
    end foreach;
    addListValue !?TypeDefBody !lstringWith[!"memberList"] !member;
    TypeDefList += !TypeDefBody;
  end foreach;
end function;


function getComponentMethodCode
  ?? @functionMap methodMap
  -> @TfieldMapList methodTplList
:
  methodTplList := [@TfieldMapList emptyList];
  foreach methodMap (@lstring methodName @parameterDefList param  @returnTypeList returnTypeList @instructionList instCode) do
    @TfieldMap methodTplBody [emptyMap];
    addLStringValue !?methodTplBody !"name" !methodName;
    #return type.
    @string returnTypeStr := getComponentReturnString[!returnTypeList];
    addStringValue !?methodTplBody !lstringWith[!"returnTypeStr"] !returnTypeStr;
    #parameters
    @string paramStr := getComponentsMethodParam[!returnTypeList !param];
    addStringValue !?methodTplBody !lstringWith[!"paramStr"] !paramStr;
    #then body implementation
    @string codeStr := "";
    codeStr .= generateImplementation[!instCode !3 !"" !"" ![@codeCtx C]];
    addStringValue !?methodTplBody !lstringWith[!"codeStr"] !codeStr;
    #end
    methodTplList += !methodTplBody;
  end foreach;
end function;

function memoryChunksImplementation
  ?? @memoryChunkMap memoryMap
  -> @TfieldMapList memTplList
:
  memTplList := [@TfieldMapList emptyList];
  foreach memoryMap(@lstring memChuckName @memoryParam param ...) do
    @TfieldMap memTplBody [emptyMap];
    addLStringValue !?memTplBody !"name" !memChuckName;
    addUnsignedValue !?memTplBody !lstringWith[!"stride"]   ![[param stride] uint64];
    addUnsignedValue !?memTplBody !lstringWith[!"width"]    ![[param width] uint64];
    addUnsignedValue !?memTplBody !lstringWith[!"addrFrom"] ![[param addrFrom] uint64];
    addUnsignedValue !?memTplBody !lstringWith[!"addrTo"]   ![[param addrTo] uint64];
    addUnsignedValue !?memTplBody !lstringWith[!"type"]     ![[param type] uint64];
    addBoolValue     !?memTplBody !lstringWith[!"isProg"]   ![param isProg];
    #end
    memTplList += !memTplBody;
  end foreach;
end function;

routine generateComponentCode
  ??@componentMap componentMap
  ?! @TfieldMap templateStruct
:
  @TfieldMapList componentTpl [emptyList];
  foreach componentMap (@lstring componentName 
                        @varMap componentVar 
                        @instructionList componentDeclarationList
                        @functionMap methodMap
                        @memoryChunkMap memoryMap
                        @memoryAliasMap memoryAliasMap
                        @varMap localVar
                        @readWriteActionList readWriteActionList
                        @cyclicPartList cyclicPartList
                        @TypeStructDefMap TypeStructDefList
                        ...) do
    @TfieldMap componentTplBody [emptyMap];
    addLStringValue !?componentTplBody !"name" !componentName;

    @string initLocals := generateImplementation[!componentDeclarationList !1 !"" !"" ![@codeCtx C]];
    addStringValue !?componentTplBody !lstringWith[!"initLocals"] !initLocals;
    addListValue !?componentTplBody !lstringWith[!"localVar"] !varMapDeclaration[!localVar ![@codeCtx C]];
    addListValue !?componentTplBody !lstringWith[!"registers"] !componentRegisterDeclaration[!memoryAliasMap];
    addListValue !?componentTplBody !lstringWith[!"memoryChunks"] !memoryChunksImplementation[!memoryMap];
    addListValue !?componentTplBody !lstringWith[!"methodList"] !getComponentMethodCode[!methodMap];
    addListValue !?componentTplBody !lstringWith[!"typedefList"] !getComponentTypeDef [!TypeStructDefList]; 
    #registers (defined both in components and memory chunks).
    @TfieldMapList regTplList [emptyList];
    getMemoryRegisterSetGetCode !componentName !"" !memoryAliasMap ![@memoryConstList emptyList] !false !?regTplList;
    addMemoryRegistersImplementation !componentName !memoryMap !?regTplList;
    addListValue !?componentTplBody !lstringWith[!"registerList"] !regTplList;
    componentTpl += !componentTplBody;
  end foreach;
  addListValue   !?templateStruct !lstringWith[!"componentList"] !componentTpl;
end routine;

#this routine gives the code related to local vars declaration in components.
#the generated code should be included in the private part of arch.h
function componentRegisterDeclaration
  ?? @memoryAliasMap memoryAliasMap
  -> @TfieldMapList regTplList
:
  regTplList := [@TfieldMapList emptyList];
  #registers declaration.
  foreach memoryAliasMap (@lstring idf @uint size @uint address @registerBitFieldList registerBitFieldList ...) do
    @TfieldMap regTplBody [emptyMap];
    @varType type := [@varType new ![@varKind unsigned] !size !here];
    @string CType := [type getCType];
    addStringValue !?regTplBody !lstringWith[!"type"] !CType;
    addStringValue !?regTplBody !lstringWith[!"name"] !getInternalComponentRegisterName[!idf];
    #end
    regTplList += !regTplBody;
  end foreach;
end function;

routine generateComponentImplementationFiles
  ?! @TfieldMap templateStruct
  ?! @componentMap componentMap
:
  generateComponentCode !componentMap !?templateStruct;
  generateGetProgramChunkMethod !componentMap !? templateStruct;
  setConstRegisterAtReset !componentMap !? templateStruct;
  generateResetFunc !componentMap !? templateStruct;
end routine;

end semantics;
# vim:ft=ggs:ts=2:sw=2
