semantics gadl_semantics_expression:
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics";
  import "gadl_semantics_AST_expression.gSemantics";
  import "gadl_expression_functions.gSemantics"; #nbBitsToCodeSigned

#In this file:
# definition of @expression, @expressionContext, @fieldList
# def of subclasses:
# * expDummy
# * expIntConst
# * expInstructionSize
# * expInstructionAddress
# * expIdf
# * expCast
# * expBitFieldOp
# * expUnary
# * expBinary
#
# useful readers for expression:
# * getUVal ! @uint64 val ! @bool ok => return the uint64 value if possible (no eval).

# reader for expIdf
# * string that returns the debug itemList string.
# * lstring (same as string, with location of the first item)
# * getLocalVar: check that it is an expIdf, and then refers to a local var.
#
# * reader @idfItemList string -> @string name :



#expressionContext associate a context to an expression. 
#This is used to allow expressions in only specific context. For instance, the
#'instruction size' expression can be used in the syntax view, but not in a component
enum @expressionContext {
  component,
  memory,
  behavior,
  syntaxView, #syntax is a keyword :-/
  timing,
  instCycle, #related to the fourth view of instruction: inst cycle without pipeline.
  architecture,
  defaultSection, #default is a keyword :-/
  peripheral
}

reader @expressionContext msg -> @string outResult :
  switch selfcopy
    when component      : outResult := "an expression in a component description" ;
    when memory         : outResult := "an expression in a memory description" ;
    when behavior       : outResult := "an expression in a behavior view" ;  
    when syntaxView     : outResult := "an expression in a syntax view" ;  
    when timing         : outResult := "an expression in a timing view" ;
    when instCycle      : outResult := "an expression in an instruction cycle (fourth) view" ;
    when architecture   : outResult := "an expression in the architecture description" ;
    when defaultSection : outResult := "an expression in the default section" ;
    when peripheral     : outResult := "an expression in a peripheral description" ;
  end switch ;
end reader ;

abstract class @expression {
  @varAbstractType type; #out type of the expression.
}

list @expressionlist {
  @expression exp;
}

### Dummy expression. used to generate special code in the simulator.
class @expDummy extends @expression {
  @string expCode;
}

class @expIntConst extends @expression {
  @uint64 value;
  @bool negative; #if true, the real value is (-value). Kind should be signed.
}

class @expInstructionSize extends @expression {
}

class @expInstructionAddress extends @expression {
}

list @idfItemList
{
  @lstring idf;
  @idfItemType type; #see gadl_semantics_AST_expression.gSemantics: basic, tabular, function call.
  @expressionlist paramList; #for a function call, or 1 item for tabular.
  @idfItemSpecificType specificType; #specific type (register, peripheral method, â€¦)
}

reader @idfItemList string -> @string name :
  name := "";
  foreach selfcopy (@lstring idf @idfItemType type ...) 
    do 
      name.=[idf string];
      if type == [@idfItemType functionCall] then name .= "(..)"; end if;
      if type == [@idfItemType tabular] then name .= "[..]"; end if;
    between name.="."; 
  end foreach;
end reader;

#define the type of the idf that have been 
#determined during 'getExp' method (build of expIdf).
enum @idfType
{
  unknown,          #should not be determined -> error
  structMember,     #(toto.titi.tata)  -> toto defined as type.
  localVar,         #(idf, including fields)
  tabularAccess,    #(tab[<exp>]), -> tab defined as tabular. TODO: on garde???
  registerAccess,   #(SP)
  registerBitField, #(CR.CR0)
  componentCall,    #(fetcher.fetch())
  periphCall,       #(device.method() or method() inside a peripheral).
  memoryAccess      #(memSpace.read8())
}

reader @idfType msg -> @string out :
  switch selfcopy
    when unknown          : out := "an unknown type";
    when structMember     : out := "a member of a defined type";
    when localVar         : out := "a local variable";
    when tabularAccess    : out := "a value of a tabular";
    when registerAccess   : out := "a register access";
    when registerBitField : out := "a bitfield of a register";
    when componentCall    : out := "a component call";
    when periphCall       : out := "a peripheral's method call";
    when memoryAccess     : out := "a memory access";
  end switch;
end reader;

#define the type of the idf item that have been 
#determined during 'getExp' method (build of expIdf).
enum @idfItemSpecificType
{
  unknown,          #should not be determined -> error
  register,         #->access through a function in code generation
  periphMethod,     #
  standard          #basic item (nothing special).
}

reader @idfItemSpecificType msg -> @string out :
  switch selfcopy
    when unknown          : out := "an unknown item type";
    when register         : out := "a register access";
    when periphMethod     : out := "a peripheral method";
    when standard         : out := "a standard item";
  end switch;
end reader;

reader @expIdf string -> @string name :
  name := [idfList string];
end reader;

reader @expIdf lstring -> @lstring name :
  @string str :=  [idfList string];
  @location loc := here;
  if [idfList length] > 0 then
    @lstring first;
    [idfList first ?first ?* ?* ?*];
    loc := [first location];
  end if;
  name := [@lstring new !str !loc];
end reader;

class @expIdf extends @expression {
  @idfItemList idfList;  #may be idf1.idf2.idf3
  @idfType detectedType; #type detected using maps (varMap, methodMap, ..)
  @bool isConst;
  @string codePrefix;
}

class @expCast extends @expression {
  @expression expCasted;
}

list @fieldList {
  @expression expFrom;
  @expression expTo;
  @location loc;
  @bool only1Exp; #will be 'true' for a 1bit interval.
}

class @expBitFieldOp extends @expression {
  @expression expField ;
  @fieldList fList;
}

#unary code id 0 -> "!"
#unary code id 1 -> "~"
#unary code id 2 -> "-"
class @expUnary extends @expression {
  @expression exp;
  @uint id; 
}

# in the order: * / % + - >> << < > <= >= = !=  & ^ | && || ^^ ror rol cat (from 0) 
class @expBinary extends @expression {
  @expression expLeft;
  @expression expRight;
  @uint id; 
}
###############################################################################
#
###############################################################################

reader @expression getLocalVar
  ?? @location expLoc
  -> @lstring idf
:
  if (selfcopy is == @expIdf) then
    const @expIdf expIdf := (cast selfcopy : @expIdf);
    if [expIdf detectedType] == [@idfType localVar] then
      #ok, only one item.
      [[expIdf idfList] first ?idf ?* ?* ?*];
    else
      error expLoc: "The expression should be a local variable" : idf;
    end if;
  else
    error expLoc: "The expression should be a local variable" :idf;
  end if;
end reader;

###############################################################################
# getUVal return the unsigned value, if possible.
###############################################################################
method @expression getUVal
  ! @uint64 val
  ! @bool ok
:
  val := 0L;
  ok := false;
end method;

override method @expIntConst getUVal
  ! @uint64 val
  ! @bool ok
:
  val := value;
  ok := true;
end method;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
