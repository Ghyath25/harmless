syntax gadl_implementation_parser ("gadl_lexique.gLexique") :
  import "gadl_options.gOption" ;
  import "gadl_semantics_AST_implementation.gSemantics" ;

nonterminal <expression> !@ASTExpression exp;
nonterminal <idf> !@ASTExpression exp;
nonterminal <bitField> !@ASTfieldList fieldList;


rule <implementationOrEmpty>
  ?! @ASTInstructionList instList
:
  select
    #empty implementation
  or
    <implementation> !?instList;
  end select;
end rule;


rule <ifInstruction>
  ! @ASTInstruction inst
:
  @ASTExpression expIf;
  @ASTInstructionList IfInstructionList [emptyList];
  @ASTInstructionList elseInstructionList [emptyList];
  const @location loc := here;
  <expression>  ?expIf;
  $then$;
  <implementationOrEmpty> !?IfInstructionList;
  select
    #no else.
  or
    $else$;
    <implementationOrEmpty> !?elseInstructionList;
  or
    $elseif$;
    @ASTInstruction instElse;
    <ifInstruction> ?instElse;
    elseInstructionList += !instElse;
  end select;
  inst := [@ASTInstIf new !loc !expIf !IfInstructionList !elseInstructionList];
  
end rule;

rule <ifBlock>
  ?! @ASTInstructionList instList
:
  $if$;
  @ASTInstruction inst;
  <ifInstruction> ?inst;
  instList += !inst;
  $end$; $if$;  
end rule;

rule <return>
  ?! @ASTInstructionList instList
:
  @ASTExpression exp;
  $return$;
  <expression> ?exp;
  instList += ![@ASTInstReturn new !here !exp];
end rule;

#this rule is used to prevent the execution of the next xx instructions.
rule <instNop>
  ?! @ASTInstructionList instList
:
  @ASTExpression exp;
  $nop$;
  <expression> ?exp;
  $instruction$;
  instList += ![@ASTInstNop new !here !exp];
end rule;

rule <loopBlock>
  ?! @ASTInstructionList instList
:
  @ASTInstructionList loopInstList [emptyList];
  $loop$;
  const @location loc := here;
  @ASTExpression guard;
  <expression> ?guard;
  $while$;
  @ASTExpression expCondition;
  <expression> ?expCondition;
  $do$;
  <implementation> !?loopInstList;
  $end$; $loop$;
  instList += ![@ASTInstLoop new !loc !guard !expCondition !loopInstList];
end rule;

rule <errorHandling>
  ?! @ASTInstructionList instList
:
  @bool onlyWarn;
  select 
    $warning$;
    onlyWarn := true;
  or 
    $error$;
    onlyWarn := false;
  end select;
  @lstring msg;
  $caracterStr$ ?msg;
  instList += ![@ASTInstError new !here !onlyWarn !msg];
end rule;

#This instruction print the text in parameter on stderr.
#used to model the uart.
rule <instPrint>
  ?! @ASTInstructionList instList
:
  $print$;
  repeat
    select
      @ASTExpression exp;
      <expression> ?exp;
      instList += ![@ASTInstPrint new !here !exp];
    or  
      @lstring msg;
      $caracterStr$ ?msg;
      instList += ![@ASTInstMessage new !here !msg];
    end select;
  while $,$;
  end repeat;
end rule;

rule <assignmentLeft>
  ?? @ASTExpression idf
  ?! @ASTInstructionList instList
:
  @ASTfieldList fieldList;
  select
    fieldList := [@ASTfieldList emptyList];
  or
    <bitField> ?fieldList; 
  end select;
  @ASTExpression exp;
  $:=$;
  <expression> ?exp;
  instList += ![@ASTInstAssignment new !here !idf !fieldList !exp];
end rule;

rule <assignmentOrFunctionCall>
  ?! @ASTInstructionList instList
:
  @ASTExpression idf;
  <idf> ?idf;
  select
    #function call.
    instList += ![@ASTInstFunctionCall new !here !idf];
  or
    <assignmentLeft> !idf !?instList;
  end select;
end rule;

rule <typeDeclaration>
  ! @varAbstractType type
:
  @varAbstractType typeBase; #type of an item in a tabular
  select 
    @luint varSize;
    $uvar$ ? varSize;
    typeBase := [@varBaseType new ![@varKind unsigned] ![varSize uint] !here];
  or
    @luint varSize;
    $svar$ ? varSize; 
    typeBase := [@varBaseType new ![@varKind signed] ![varSize uint] !here];
  or
    $void$;
    typeBase := [@varBaseType new ![@varKind unsigned] !0 !here]; #void <=> u0
  or
    @lstring typeName;
    $type$;
    $idf$ ? typeName;
    typeBase := [@varStructType new ![@varKind custom] !typeName];
  end select;
  #this may be a tabular.
  select
    @luint64 tabLength;
    $[$; $unumber$ ?tabLength; $]$;
    type := [@varTabularType new ![@varKind tabular] !typeBase ![tabLength uint]];
  or
    type := typeBase;
  end select;
end rule;
  
rule <declaration>
  ?! @ASTInstructionList instList
:
  @varAbstractType type;
  <typeDeclaration> ?type;
  repeat
    @lstring idf;
    $idf$ ?idf;
    instList += ![@ASTInstDeclaration new !here ![@varClass localVar] !type !idf];
    select
    or 
      <assignmentLeft> ![idf getASTExp] !?instList;
    end select;
  while
    $,$;
  end repeat;
end rule;

rule <typeDefinition>
  ?! @ASTInstructionList instList
:
  @typedefMemberMap memberMap [emptyMap];
  @lstring idf;
  $typedef$;
  const @location loc := here;
  $idf$ ?idf;
  ${$;
  repeat
    @varAbstractType type;
    @lstring member;
    <typeDeclaration> ?type;
    $idf$ ?member;
    [!?memberMap insertKey !member !type];
  while
  end repeat;
  $}$;
  instList += ![@ASTInstTypeDefinition new !loc !idf !memberMap];
end rule;

rule <implementation> 
  ?! @ASTInstructionList instList
:
  repeat
    select
      <ifBlock> !?instList;
    or
      <return> !?instList;
    or
      <instNop> !?instList;
    or
      <loopBlock> !?instList;
    or
      <errorHandling> !?instList;
    or
      <instPrint> !?instList;
    or
      <assignmentOrFunctionCall> !?instList;
    or
      <declaration> !?instList;
    or
      <typeDefinition> !?instList;
    end select;
  while
  end repeat;
end rule;



end syntax ;
# vim:ft=ggs:ts=2:sw=2
