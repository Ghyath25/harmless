semantics gadl_memory :
  import "gadl_options.gOption" ;
  import "gadl_semantics_AST_expression.gSemantics" ;
  import "gadl_semantics_GetExp.gSemantics" ;
  import "gadl_semantics_expression_eval.gSemantics" ;
  import "gadl_templates.gSemantics" ;
  

###############################################################################
# base file for memory chunks.
# it defines :
# * enum @memType (RAM, ROM, ..
# * class @memoryMapping -> a memory location: address and mem space.
#
# * map @ASTmemoryParamMap -> base AST memory map
# * map @memoryParamMap    -> decorated map: A MEMORY CHUNK
#
# * ASTmemSpaceMap : memory space.
#
# available readers:
# * string (for @memType @memoryMapping @ASTmemoryParamMap)
# * @ASTmemoryParamMap getMemMap -> get decorated structure from AST.
# 
# @ASTmemSpaceMap:
#   * getMemSpaceMap
#
# modifier @functionMap
#   * addMemoryAccess
###############################################################################
# map @memSpaceMap is defined in gadl_varIdfStruct.gSemantics

enum @memType {
  rom,ram,register,GPR
}

class @memoryMapping
{
  @lstring memSpaceName;
  @luint64 baseAddress;
}

map @ASTmemoryParamMap
{
  @uint width;
  @ASTExpression ASTexpSize;
  @memType access;
  @memoryMapping memoryMapping;
  insert insertKey error message "the '%K' memory chunk is declared twice." ; 
  search searchKey error message "the '%K' memory chunk is not defined." ;
}

map @memoryParamMap
{
  @uint width;
  @uint expSize;
  @memType access;
  @memoryMapping memoryMapping;
  insert insertKey error message "the '%K' memory chunk is declared twice." ; 
  search searchKey error message "the '%K' memory chunk is not defined." ;
  remove removeKey error message "the '%K' memory chunk is not defined and could not be removed." ;
}

###############################################################################
# reader string
###############################################################################

reader @memoryMapping string -> @string str
:
  str := [memSpaceName string].":".[[baseAddress uint64] string];
end reader ;

reader @ASTmemoryParamMap string -> @string str
:
  str := "";
  foreach selfcopy
  before str .= "\nmemory chunk\n";
  do
    str .= "\t".[lkey string]."\n";
    str .= "\t\twidth  :".[width string]."\n";
    str .= "\t\tsize   : (not computed yet)\n";
    str .= "\t\taccess :".[access string]."\n";
    str .= "\t\tmapping:".[memoryMapping string]."\n";
  end foreach;
end reader;

reader @memoryParamMap string -> @string str
:
  str := "";
  foreach selfcopy
  before str .= "\nmemory chunk\n";
  do
    str .= "\t".[lkey string]."\n";
    str .= "\t\twidth  :".[width string]."\n";
    str .= "\t\tsize   :".[expSize string]."\n";
    str .= "\t\taccess :".[access string]."\n";
    str .= "\t\tmapping:".[memoryMapping string]."\n";
  end foreach;
end reader;

reader @memType string -> @string outResult :
  switch selfcopy
    when rom      : outResult := "a read-only memory";
    when ram      : outResult := "a read/write memory";
    when register : outResult := "a register bank";
    when GPR      : outResult := "a GPR bank";
  end switch ;
end reader ;

reader @memType id -> @uint id :
  switch selfcopy
    when rom      : id := 0;
    when ram      : id := 1;
    when register : id := 2;
    when GPR      : id := 3;
  end switch ;
end reader ;
###############################################################################
# getMemMap
###############################################################################
reader @ASTmemoryParamMap getMemMap
  -> @memoryParamMap memMap
:
  memMap := [@memoryParamMap emptyMap];
  @expressionContext ctx := [@expressionContext memory];
  @symbolValueMap symbolMap [default];
  @varIdfStruct idfStruct [default]; #no symbol here.
  
  foreach selfcopy do
    #expression related to size.
    @expression expSize := [[ASTexpSize getExp !ctx !symbolMap !idfStruct] eval !symbolMap];
    if not (expSize is >= @expIntConst) then
      error lkey: "The memory size expression cannot statically be computed to an integer.";
    else
      @expIntConst intExp := (cast expSize:@expIntConst);
      if [intExp negative] then
        error lkey: "the memory size should not be negative";
      end if;
      [!?memMap insertKey !lkey !width ![[intExp value] uint] !access !memoryMapping];
    end if;
  end foreach;
end reader;

map @ASTmemSpaceMap 
{
  @uint width;
  @bool isProgram;
  @uint stride; #default value, a power of 2
  insert insertKey error message "the '%K' memory chunk is declared twice." ; 
  search searchKey error message "the '%K' memory chunk is not defined." ;
}

method @ASTmemSpaceMap checkProgramSpace
:
  #check that there is one and only one program chunk
  @bool hasProgram := false;
  foreach selfcopy do
    if isProgram then
      if hasProgram then
        error lkey: "Only one memory space should be declared.";
      end if;
      hasProgram := true;
    end if;
  end foreach;
  if not hasProgram then
    error here: "There is no memory space defined to get the program. Use to 'program' keyword before the memory space definition to define one.";
  end if;
end method;

reader @ASTmemSpaceMap getMemSpaceMap
  -> @memSpaceMap memSpaceMap
:
  [selfcopy checkProgramSpace];
  memSpaceMap := [@memSpaceMap emptyMap];
  foreach selfcopy do
    @functionMap methodMap [emptyMap];
    #add accessors for the current width, and 8, 16 and 32 bits.
    [!?methodMap addMemoryAccess !width ![lkey location]];
    if width > 8 then
      [!?methodMap addMemoryAccess !8 ![lkey location]];
      if width > 16 then
        [!?methodMap addMemoryAccess !16 ![lkey location]];
        if width > 32 then
          [!?methodMap addMemoryAccess !32 ![lkey location]];
        end if;
      end if;
    end if;
    #the stride
    # -> remove 1: 4 becomes 3 => needs 2 bits to be encoded
    @uint strideBits := nbBitsToCodeUnsigned[![stride uint64]-1L]; 
    if stride != (1<<strideBits) then
      error lkey: "The stride in the memory definition should be a power of Two.";
    end if;
    [!?memSpaceMap insertKey !lkey !width !methodMap !isProgram !strideBits];
  end foreach;
end reader;

modifier @functionMap addMemoryAccess
 ?? @uint width
 ?? @location loc
:
  #TODO address space is limited to 32 bits at this date.
  @varBaseType addressType := [@varBaseType new ![@varKind unsigned] !32 !loc];
  @lstring addStr := [@lstring new !"_addr" !loc]; #internal name.
  #read
  @lstring nameRead := [@lstring new !"read".[width string] !loc];
  @varBaseType outTypeRead := [@varBaseType new ![@varKind unsigned] !width !loc];
  @parameterDefList paramRead [emptyList];
  paramRead += !false !addressType !addStr;
  [!?self insertKey !nameRead !paramRead !outTypeRead ![@instructionList emptyList]];
  #write
  @lstring nameWrite := [@lstring new !"write".[width string] !loc];
  @lstring wrStr := [@lstring new !"_value" !loc]; #internal name.
  @varBaseType outTypeWrite := [@varBaseType new ![@varKind unsigned] !0 !loc]; #void
  @varBaseType typeWrite := [@varBaseType new ![@varKind unsigned] !width !loc];
  @parameterDefList paramWrite [emptyList];
  paramWrite += !false !addressType !addStr;
  paramWrite += !false !typeWrite !wrStr;
  [!?self insertKey !nameWrite !paramWrite !outTypeWrite ![@instructionList emptyList]];
end modifier;

method @memoryParamMap setInTemplate
  ?? @lstring name
  ?! @TfieldMap templateStruct
:
  @TfieldMapList memMapTpl [emptyList];
  foreach selfcopy do
    @TfieldMap memParamTplBody [emptyMap];
    addLStringValue !?memParamTplBody !"name" !lkey;

    addUnsignedValue !?memParamTplBody !lstringWith[!"width"]   ![width uint64];
    addUnsignedValue !?memParamTplBody !lstringWith[!"size"] ![expSize uint64];
    addUnsignedValue !?memParamTplBody !lstringWith[!"type"]  ![[access id] uint64];

    addLStringValue !?memParamTplBody !"memSpaceName"  ![memoryMapping memSpaceName];
    addLUnsignedValue !?memParamTplBody !"baseAddress"  ![memoryMapping baseAddress];

    memMapTpl += !memParamTplBody;    
  end foreach;
  addListValue !?templateStruct !name !memMapTpl;  
end method;

reader @memoryParamMap memSpaceWithRegisterBank
  ?? @memSpaceMap memSpaceMap
  -> @intMap memSpaceWithRegister
:
  memSpaceWithRegister := [@intMap emptyMap];
  foreach selfcopy do
    if access == [@memType GPR] then
      #mathing.
      @lstring memSpace := [memoryMapping memSpaceName];
      if not [memSpaceWithRegister hasKey ![memSpace string]] then
        [memSpaceMap searchKey !memSpace ?* ?* ?* ?@uint stride];
        [!?memSpaceWithRegister insertKey !memSpace !stride];
      end if;
    end if;
  end foreach;
end reader;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
