semantics gadl_semantics_register_access :
  import "gadl_components.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_memory.gSemantics" ;

#This list get pipeline information for the DDC:
# for each component that get registers, it stores the 
# * pipeline stage where the registers are read
# * pipeline stage where the registers are written
#
list @DDCPipelineInfoList {
  @lstring associatedComponent;
  @lstring pipelineReadName;
  @lstring pipelineStageReadName;
  @lstring pipelineWriteName;
  @lstring pipelineStageWriteName;  
}

##this class is used only to get information about the memory registers file
## -> a unique name
## -> nb of elements (i.e. if this is a 32 bits registers, it is the size/4). It uses the stride.
## key is componentName_memoryName_memoryChunkName or
## key is componentName_memoryName.
#map @DDCMemoryRegisterInfoMap {
#  @lstring componentName;
#  @lstring memoryName;
#  @lstring memoryChunkName;
#  @uint nbElt;
#  @uint width;
#  @sint chunkId feature setter; #store the chunkId. Default is '-1' -> bad value.
#  @uint chunkOffset feature setter; #store the chunkOffset. Default is '0'
#  insert insertKey error message "the '%K' memSpaceWithRegister is already defined in %L" ; 
#  search searchKey error message "the '%K' memSpaceWithRegister is not defined" ;
#}

#access to a register file.
#Key is the memory chunk name.
map @DDCRegisterFileAccess {
  @bool read;  #got a read  access;
  @bool write; #got a write access;
  insert insertKey error message "the '%K' DDCRegisterFileAccess is already defined in %L" ; 
  search searchKey error message "the '%K' DDCRegisterFileAccess is not defined" ;
  remove removeKey error message "the '%K' DDCRegisterFileAccess is not defined and cannot be removed." ;
}


##list all the R/W accesses. It should have
##"@boolMap" entries. One entry for each
##register file.
## key is componentName_memoryName -> memid.
#map @DDCRegisterFileAccess {
#  @lstring componentName;
#  @lstring memoryName;
#  @stringMap methodAccessMap; #method access map -> read32, memoryName_read8, memoryName_memoryChunkName_write32..
#  #String value is either "read" or "write".
#  insert insertKey error message "the '%K' DDCRegisterFileAccess is already defined in %L" ; 
#  search searchKey error message "the '%K' DDCRegisterFileAccess is not defined" ;
#  remove removeKey error message "the '%K' DDCRegisterFileAccess is not defined and cannot be removed." ;
#}

#This map stores for each instruction (the key) the 
#structures that records the read/write registers access.
map @DDCRegisterAccessMap
{
  @boolMap registerReadAccess;  #read  access to a register (defined using keyword 'register')
  @boolMap registerWriteAccess; #write access to a register (defined using keyword 'register')
  @DDCRegisterFileAccess registerFileAccess; #R/W/ access to a register file (inside memory part).
  insert insertKey error message "the '%K' @DDCRegisterAccessMap is already defined in %L" ; 
  search searchKey error message "the '%K' @DDCRegisterAccessMap is not defined" ;
}

#used to store a register mask for each item in memSpaceWithRegister and in classical registers.
#key is the register file access:
# key is componentName_memoryName_memoryChunkName or
# key is componentName_memoryName.
map @regMaskMap
{
  @string readMaskStr; #as the result of an expression.
  @string writeMaskStr;
  insert insertKey error message "the '%K' @regMaskMap is already defined in %L" ; 
}

map @regMaskMapMap
{
  @uint64 registerReadMask;
  @uint64 registerWriteMask;
  @regMaskMap regMaskMap;
  insert insertKey error message "the '%K' @regMaskMapMap is already defined in %L" ; 
  search searchKey error message "the '%K' @regMaskMapMap is not defined" ;
}

####################################################################################
# below are the 'getRegisterUsage' methods for:
# * instructions
#   - @instIf
#   - @instReturn
#   - @instNop
#   - @instLoop
#   - @instError
#   - @instPrint
#   - @instMessage
#   - @instFunctionCall
#   - @instAssignment
#   - @instDeclaration
#     -> @instDeclarationRegSlice 
#   - @instTypeDefinition
# * expressions.
#   - expDummy
#   - expIntConst
#   - expInstructionSize
#   - expInstructionAddress
#   - expIdf
#   - expCast
#   - expBitFieldOp
#   + expUnary
#   - expBinary
####################################################################################
abstract method @instruction getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
;

override method @instError getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @instMessage getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @instPrint getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @instNop getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [cond getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
end method;

override method @instIf getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [cond getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  foreach instIfList do
    [inst getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  end foreach;
  foreach instElseList do
    [inst getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  end foreach;
end method;

override method @instDeclaration getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @instTypeDefinition getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @instLoop getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [expCondition getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  foreach loopInstList do
    [inst getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  end foreach;
end method;

override method @instAssignment getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  #right part of assignment.
  [exp getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  #left part are written.
  [idf getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !true];
end method;

routine checkForAccessInRegisterFile
 ?? @idfItemList idfList
 ?? @bool read #read or write access.
 ?? @boolMap memSpaceWithRegister
 ?! @DDCRegisterFileAccess registerFileAccess #it stores registers accesses (output)
:
  @lstring memChunkName := [idfList idfAtIndex !0]; #we don't need the type of access considered.
  message "check for reg file access ".[memChunkName string].":";
  if [memSpaceWithRegister hasKey ![memChunkName string]] then #this is a mem space with regs.
    message "match";
    if [registerFileAccess hasKey ![memChunkName string]] then
      message "update";
      #already a file access -> update
      if read then
        [!?registerFileAccess setReadForKey !true ![memChunkName string]]; #update
      else
        [!?registerFileAccess setWriteForKey !true ![memChunkName string]]; #update
      end if;
    else
      message "insert";
      #no access. Insert entry.
      @bool R := read;
      @bool W := not read;
      [!?registerFileAccess insertKey !memChunkName !R !W];
    end if;
  end if;
  message "\n";

#  #foreach memory part defined as 'register'
#  foreach memSpaceWithRegister (* @lstring DDCcomponentName @lstring DDCmemoryName @lstring DDCmemoryChunkName * @uint width * *) do
#    #the component call should match (easy)
#    if [componentName string] == [DDCcomponentName string] then
#      #ok. Then, the method should match. If this is a memory alias, it is appended at the end of mem name.
#      @string methodKey := [DDCmemoryName string];
#      if [DDCmemoryChunkName string] != "" then
#        methodKey .= "_".[DDCmemoryChunkName string];
#      end if;
#      #then, look for a read or write access (read32, read16, .. method).
#      #Quick and dirty :-/
#      if ([methodName string] == (methodKey."_".accessType.[width string])) |
#         ([methodName string] == (methodKey."_".accessType."64")) |
#         ([methodName string] == (methodKey."_".accessType."32")) |
#         ([methodName string] == (methodKey."_".accessType."16")) |
#         ([methodName string] == (methodKey."_".accessType."8")) then
#         #The method is related to a register file. Store it.
#         @stringMap methodAccessMap [emptyMap];
#         @bool entryExist := false;
#         @string memId := [componentName string]."_".[DDCmemoryName string];
#         if [registerFileAccess hasKey !memId] then
#           #already a file access.
#           entryExist := true;
#           [registerFileAccess searchKey ![@lstring new !memId ![componentName location]] ?* ?* ?methodAccessMap];
#         end if;
#         @bool mapUpdate := false;
#         if not [methodAccessMap hasKey ![methodName string]] then
#           mapUpdate := true;
#           #not previously stored, update.
#           [!?methodAccessMap insertKey !methodName !accessType];
#         end if;
#         if not entryExist then
#           #add it
#           [!?registerFileAccess insertKey ![@lstring new !memId ![componentName location]] !componentName !DDCmemoryName !methodAccessMap];
#         else
#           if mapUpdate then
#             [!?registerFileAccess setMethodAccessMapForKey !methodAccessMap !memId]; #update
#           end if;
#         end if;
#      end if;
#    end if;
#  end foreach;
#  #logRegisterFileAccess !registerFileAccess;
end routine;

override method @instFunctionCall getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  #register defined using the 'register' keyword.
  foreach [exp idfList] do
    foreach paramList do
      [exp getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
    end foreach;
  end foreach;
  switch [exp detectedType]
    when unknown,structMember,localVar,tabularAccess,registerAccess,registerBitField:
      error loc: "invalid detected type for a function call".[[exp detectedType] msg];
    when componentCall:
      @instructionList instList := [varIdfStruct->componentMap getInstList ![exp idfList]];
      foreach instList do
        [inst getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
      end foreach;
    when memoryAccess:
      #register file (memory). This could be only a write (the instruction does not returns any value).
      checkForAccessInRegisterFile ![exp idfList] !false !memSpaceWithRegister !?registerFileAccess;  
  end switch;
end method;

override method @instReturn getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [exp getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
end method;

##Expression category.
abstract method @expression getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
;

override method @expIdf getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool assignment
:
  #parameters (if any).
  foreach idfList do
    foreach paramList do
      [exp getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
    end foreach;
  end foreach;

  switch detectedType
    when unknown,structMember,localVar,tabularAccess: #nothing to do.
    when registerAccess,registerBitField:
      @lstring regName := [idfList idfAtIndex !0]; #more than one idf in list for slices.
      if assignment then #from the left part of an assignment expression
        if not [registerWriteAccess hasKey ![regName string]] then
          [!?registerWriteAccess insertKey !regName];
        end if;
      else
        if not [registerReadAccess hasKey ![regName string]] then
          [!?registerReadAccess insertKey !regName];
        end if;
      end if;
    when componentCall:
      #instructions
      @instructionList instList := [varIdfStruct->componentMap getInstList !idfList];
      foreach instList do
        [inst getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
      end foreach;
    when memoryAccess: #only a read inside an expression.
      checkForAccessInRegisterFile !idfList !true !memSpaceWithRegister !?registerFileAccess;  
  end switch;
end method;

override method @expBinary getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [expLeft getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
  [expRight getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
end method;

override method @expBitFieldOp getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [expField getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
end method;

override method @expCast getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [expCasted getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
end method;

override method @expDummy getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @expInstructionAddress getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @expInstructionSize getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @expIntConst getRegisterUsage
 ?? @varIdfStruct unused varIdfStruct
 ?! @boolMap unused registerReadAccess
 ?! @boolMap unused registerWriteAccess
 ?! @DDCRegisterFileAccess unused registerFileAccess
 ?? @boolMap unused memSpaceWithRegister
 ?? @bool unused assignment
:
end method;

override method @expUnary getRegisterUsage
 ?? @varIdfStruct varIdfStruct
 ?! @boolMap registerReadAccess
 ?! @boolMap registerWriteAccess
 ?! @DDCRegisterFileAccess registerFileAccess
 ?? @boolMap memSpaceWithRegister
 ?? @bool unused assignment
:
  [exp getRegisterUsage !varIdfStruct !?registerReadAccess !?registerWriteAccess !?registerFileAccess !memSpaceWithRegister !false];
end method;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
