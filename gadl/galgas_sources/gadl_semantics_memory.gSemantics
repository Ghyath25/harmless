semantics gadl_semantics_memory:
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "template_semantics.gSemantics" ;
  import "gadl_semantics_implementation_code_generation.gSemantics"; #generateImplementation
  import "gadl_templates.gSemantics" ;

#see global data structure definitions in gadl_semantics...

#return the storage name.
routine getStorageName
  ?? @string compName
  ?? @string memChunkName
  !  @string storageName
:
    storageName := compName."_".memChunkName."Chunk";
end routine;

#generate code related to the stride -> shift the address.
#checks that the stride is a power of 2 (tested)
routine setStrideCode 
  ?? @string idfFromString #C identifier of the address
  ?? @uint stride          #stride value
  ?? @location errorLocation
  ?! @instructionList code
  ?? @uint addrFrom
  !  @string idfToString   #C identifier of the address, corrected with the stride
  !  @bool idfModified
:
    if stride == 0 then
      error here: "stride is set to 0. It must be a power of 2 that is higher or equal to 1.";
    end if;
    @uint tmp := stride-1;
    @uint nbBits := nbBitsToCodeUnsigned[![tmp uint64]];
    if nbBits > 0 then
      idfToString := idfFromString . "WithStride";
      idfModified := true;
      @string codeStr := "u32 ".idfToString." = ";
      if addrFrom == 0 then
        codeStr .= idfFromString;
      else
        codeStr .= [addrFrom string]." + (".idfFromString." - ".[addrFrom string].")";
      end if;
      if stride != (1 << nbBits) then #power  of 2?
        error errorLocation: "The stride value must be a power of 2.";
        #message "bits " . nbBits. "\nstride ";
      end if;
      #nbBits := nbBits - 1;
      codeStr .= " << ".[nbBits string];
      codeStr .= ";";
      @cDummy inst := [@cDummy new !here !codeStr];
      code += !inst;
    else
      idfToString := idfFromString;
      idfModified := false;
    end if;
end routine;

#this method is used to get identifiers used in the "maps to" expression. 
#Each identifier that correspond to a memory alias (register definition) leads
#to generate an instruction that generate the read access.

# This is the main method that update the address (in the generated code) to take
# into account the "maps to" offset. It also generate read access for registers used
# in the "maps to" expression.
routine setMapsToInstruction
  ?? @string idfFromString #C identifier of the address
  ?? @bool   idfModified   #to know if it is still the "const" argument.
  ?? @cExpression mapsToExpression
  ?! @instructionList code
  !  @string idfToString   #C identifier of the address, corrected with the stride
:
  #generateAliasRegisterAccess !compName !chunkName !mapsToExpression !memoryAliasMap !?code;
  @string mapsCode := [mapsToExpression generateCode !"" !"" ![@codeCtx C]];
  if idfModified then 
    idfToString := idfFromString;
    @cDummy inst0:=[@cDummy new !here !idfFromString." += ".mapsCode.";"];
    code += !inst0;
  else
    idfToString := idfFromString . "WithShift";
    @cDummy inst0:=[@cDummy new !here !"u32 ".idfToString." = ".idfFromString." + ".mapsCode.";"];
    code += !inst0;
  end if;
end routine;

#check that memory chunks does not overlap.
#check that @ min < @ max.
routine checkMemoryOverlap
  ?? @memoryChunkMap memoryChunkMap 
:
  @uint i := 0;
  foreach memoryChunkMap (@lstring memStr1 @memoryParam param1 ...) do
    @uint addressMin1 := [param1 addrFrom];
    @uint addressMax1 := [param1 addrTo];
    if addressMax1 <= addressMin1 then
      error [memStr1 location]:"invalid address range. min > max!!";
    end if;
    i := i + 1;
    @uint j := 0;
    foreach memoryChunkMap (@lstring memStr2  @memoryParam param2 ...) do
      j := j + 1;
      if i > j then
        @uint addressMin2 := [param2 addrFrom];
        @uint addressMax2 := [param2 addrTo]; #addressMax included.
        if (addressMin2 > addressMax1) | (addressMin1 > addressMax2) then
          #ok
        else error [memStr1 location]: "memory chunk overlapped another memory chunk defined in ".
                                       [[memStr1 location] locationString];
          message "1st address range :".[addressMin1 string]." to ".[addressMax1 string]."\n";
          message "2nd address range :".[addressMin2 string]." to ".[addressMax2 string]."\n";
        end if;
      end if;
    end foreach;
  end foreach;
end routine;

#routine getBaseAddress
#  ?? @memoryParam param
#  !  @uint base
#:
#  @uint addressMin1 := [param1 addrFrom];
#
#end routine;

routine updateTemplateForProgramCounter
  ?! @TfieldMap templateStruct
  ?? @varType type
  ?? @lstring name
:
  #size of PC in bytes and bits
  @uint pcSizeInBits := [type size];
  @uint pcSizeInBytes := (pcSizeInBits/8);
  if (pcSizeInBits & 7) != 0 then
    pcSizeInBytes := pcSizeInBytes+1;
  end if;
  addStringValue !?templateStruct !lstringWith[!"PC_SIZE_IN_BITS"] ! [pcSizeInBits string];
  addStringValue !?templateStruct !lstringWith[!"PC_SIZE_IN_BYTES"] ! [pcSizeInBytes string];
  #C type of PC.
  addStringValue !?templateStruct !lstringWith[!"PC_C_TYPE"] ![type getCType];
  addStringValue !?templateStruct !lstringWith[!"PC_NAME"] ![name string];
end routine;

#check that there is one and only one program counter.
#however, if the no behavior option is used, no program counter can be defined (but no more than 1).
routine programCounterAccess
  ?! @TfieldMap templateStruct
  ?? @varMap varMap
:
  #check that there is only one program counter.
  @bool found := false;
  foreach varMap (@lstring name @abstractVar var) do
    cast var
    when >= @registerVar reg :
      if [reg regType] == [@regType componentProgramCounter] |
         [reg regType] == [@regType memoryProgramCounter] then #this is a program counter.
        if found then
          error here: "can only use one program counter at this date.";
        else
         @varType type := [reg type];
          if not ([type kind] == [@varKind unsigned]) then 
            error [type location]: "Program counter should be unsigned";
          end if;
          updateTemplateForProgramCounter !?templateStruct !type !name;
        end if;
        found := true;
      end if;
    else # classical var.
    end cast;
  end foreach;
  if not found then
    if [option gadl_options.noBehavior value] then
      #no program counter. Define one dummy one to allow correct compilation.
      @varType pcType := [@varType new ![@varKind unsigned] !32 !here];
      updateTemplateForProgramCounter !?templateStruct !pcType ![@lstring new !"dummyPC" !here];
    else
      #there should have one program counter in execute mode!
      error here: "there is no program counter defined in this description.";
    end if;
  end if;
  #generate access fonctions using templates.
end routine;

#return the C Size that can store a value of nbBits;
routine getStdCTypeFor
  ?? @uint nbBits
  !  @uint CSize
:
  @varType type := [@varType new ![@varKind unsigned] !nbBits !here];
  [type getCSize ?CSize];
end routine;

routine generateReadAccess
  ?? @string storageName
  ?? @uint nbBits
  ?? @string addrIdf
  ?? @bool accessAlwaysOk #getChunk may return NULL. if flag is set, a condition is inserted.
  ?! @instructionList code
:
  @cDummy inst1:=[@cDummy new !here !"roStorage *ro = (roStorage *)".storageName.";"];
  code += !inst1;
  @cDummy inst2;
  @string conditionStr := "";
  if not accessAlwaysOk then
    conditionStr := "if(ro) ";
  end if;
  if nbBits!= 8 & nbBits!= 16 & nbBits!= 32 & nbBits!= 64 then
    #non standard type.
    @uint CType;
    getStdCTypeFor !nbBits ?CType;
    @uint mask := (1<<nbBits)-1;
    inst2:=[@cDummy new !here !conditionStr."return ((ro->read".[CType string]."AtAddress(".addrIdf.")) & ".[mask hexString].");"];
  else
    inst2:=[@cDummy new !here !conditionStr."return ro->read".[nbBits string]."AtAddress(".addrIdf.");"];
  end if;
  code += !inst2;
  if not accessAlwaysOk then
    @cDummy inst3:=[@cDummy new !here !"else return 0;"];
    code += !inst3;
  end if;
end routine;

routine generateWriteAccess
  ?? @string storageName
  ?? @uint nbBits
  ?? @string addrIdf
  ?? @bool accessAlwaysOk #getChunk may return NULL. if flag is set, a condition is inserted.
  ?! @instructionList code
:
  @cDummy inst1:=[@cDummy new !here !"rwStorage *rw = (rwStorage *)".storageName.";"];
  code += !inst1;
  @cDummy inst2;
  @string conditionStr := "";
  if not accessAlwaysOk then
    conditionStr := "if(rw) ";
  end if;
  if nbBits!= 8 & nbBits!= 16 & nbBits!= 32 & nbBits!= 64 then
    #non standard type.
    @uint CType;
    @varType type := [@varType new ![@varKind unsigned] !nbBits !here];
    [type getCSize ?CType];
    @uint mask := (1<<nbBits)-1;
    inst2:=[@cDummy new !here !conditionStr."rw->write".[CType string].
                                 "AtAddress(".addrIdf.", value & ".[mask hexString].");"];
  else
    inst2:=[@cDummy new !here !conditionStr."rw->write".[nbBits string].
                                 "AtAddress(".addrIdf.", value);"];
  end if;
  code += !inst2;
end routine;

routine generateReadMethod
  ?? @lstring methodName
  ?? @instructionList code
  ?? @uint nbBits
  ?! @functionMap methodMap 
:
  if not [methodMap hasKey ![methodName string]] then
    #message "generate read  method " . [methodName string]. "\n";
    #return type
    @varType type := [@varType new ![@varKind unsigned] !nbBits !here];
    #param
    @parameterDefList paramList := [@parameterDefList emptyList];
    @lstring paramName := [@lstring new !"address" !here];
    @varType paramType := [@varType new ![@varKind unsigned] !32 !here]; #u32 by default
    @classicVar paramVar := [@classicVar new !paramType !true !"" !""]; #address is constant
    paramList += !false !paramName !paramVar;
    #add method in component's method map.
    @returnTypeList returnTypeList [emptyList];
    returnTypeList += ![@functionOutTypeClassic new !type];
    [!?methodMap insertKey !methodName !paramList !returnTypeList !code];
  end if;
end routine;

routine generateWriteMethod
  ?? @lstring methodName
  ?? @instructionList code
  ?? @uint nbBits
  ?! @functionMap methodMap 
:
  #method name
  if not [methodMap hasKey ![methodName string]] then
    #message "generate write method ". [methodName string] . "\n";
    #return type
    @varType type := [@varType new ![@varKind unsigned] !0 !here]; #void
    #param
    @parameterDefList paramList := [@parameterDefList emptyList];
    @lstring paramName := [@lstring new !"address" !here];
    @varType paramType := [@varType new ![@varKind unsigned] !32 !here]; #u32 by default
    @classicVar paramVar := [@classicVar new !paramType !true !"" !""]; #address is contant
    paramList += !false !paramName !paramVar;
    @lstring paramName2 := [@lstring new !"value" !here];
    @varType paramType2 := [@varType new ![@varKind unsigned] !nbBits !here];
    @classicVar paramVar2 := [@classicVar new !paramType2 !true !"" !""]; #value is constant
    paramList += !false !paramName2 !paramVar2;
    #add method in component's method map.
    @returnTypeList returnTypeList [emptyList];
    returnTypeList += ![@functionOutTypeClassic new !type];
    [!?methodMap insertKey !methodName !paramList !returnTypeList !code];
  end if;
end routine;

routine generateGlobalReadMethod
  ?? @lstring compName
  ?? @uint nbBits
  ?! @functionMap methodMap 
  ?? @memoryParam param
:
  #method name
  @lstring methodName := [@lstring new !"read".[nbBits string] !here];
  #implementation
  @instructionList code := [@instructionList emptyList];
  @string addrIdf;
  setStrideCode !"address" ![param stride] ![compName location] !?code ![param addrFrom] ?addrIdf ?*;
  @string storageName := [compName string]."_getChunk(".addrIdf.")";
  generateReadAccess !storageName !nbBits !addrIdf !false !?code;
  generateReadMethod !methodName !code !nbBits !?methodMap;
end routine;

routine updateWriteWithConsts
  ?? @memoryConstList memoryConstList
  ?! @instructionList code
  ?? @uint writeAccessWidth
  ?? @memoryParam param
:
  if [memoryConstList length] != 0 then
    @string exp := "";
    @bool start := true;
    foreach memoryConstList (@uint address ...) do
      if not start then exp .= " && "; end if;
      start := false;
      @uint realAddr := [param addrFrom] + address*[param stride];
      @uint max;
      if [param width] mod 8 == 0 then max := realAddr + [param width]/8;
      else max :=realAddr + [param width]/8 + 1;
      end if;
      if writeAccessWidth == [param width] then
        exp .= "(address != ".[address string].")";
      else #writeAccessWidth < memoryWidth
        if address == 0 then
          exp .= "(address > ".[max string].")";
        else
          exp .= "(address < ".[realAddr string]." || address >= ".[max string].")";
        end if;
      end if;
    end foreach;
    @varType bool := [@varType new ![@varKind unsigned] !1 !here];
    @cIfBlock ifBlock :=[@cIfBlock new !here ![@cExpDummy new !getTypeListFrom[!bool] !exp] !code ![@instructionList emptyList]];
    code := [@instructionList emptyList];
    code += !ifBlock;
  end if;
end routine;

routine generateGlobalWriteMethod
  ?? @lstring compName
  ?? @uint nbBits
  ?! @functionMap methodMap 
  ?? @memoryParam param
  ?? @memoryConstList memoryConstList
:
  #method name
  @lstring methodName := [@lstring new !"write".[nbBits string] !here];
  #implementation
  @instructionList code := [@instructionList emptyList];
  @string addrIdf;
  setStrideCode !"address" ![param stride] ![compName location] !?code ![param addrFrom] ?addrIdf ?*;
  @string storageName := [compName string]."_getChunk(".addrIdf.")";
  generateWriteAccess !storageName !nbBits !addrIdf !false !?code;
  updateWriteWithConsts !memoryConstList !?code !nbBits !param;
  generateWriteMethod !methodName !code !nbBits !?methodMap;
end routine;

routine generateChunkReadMethod
  ?? @lstring compName
  ?? @uint nbBits
  ?! @functionMap methodMap 
  ?? @lstring chunkName
  ?? @memoryParam param 
:
  #method name
  @lstring methodName := [@lstring new ![chunkName string]."_read".[nbBits string] !here];
  #implementation
  @instructionList code := [@instructionList emptyList];
  @string addrIdf;
  setStrideCode !"address" ![param stride] ![chunkName location] !?code ![param addrFrom] ?addrIdf ?*;

  @string storageName;
  getStorageName ![compName string] ![chunkName string] ?storageName;
  #no check for value out of boundaries...
  generateReadAccess !storageName !nbBits !addrIdf !true !?code;
  generateReadMethod !methodName !code !nbBits !?methodMap;
end routine;

routine generateChunkWriteMethod
  ?? @lstring compName
  ?? @uint nbBits
  ?! @functionMap methodMap 
  ?? @lstring chunkName
  ?? @memoryParam param 
  ?? @memoryConstList memoryConstList
:
  #method name
  @lstring methodName := [@lstring new ![chunkName string]."_write".[nbBits string] !here];
  #implementation
  @instructionList code := [@instructionList emptyList];
  @string addrIdf;
  setStrideCode !"address" ![param stride] ![compName location] !?code ![param addrFrom] ?addrIdf ?*;
  @string storageName;
  getStorageName ![compName string] ![chunkName string] ?storageName;
  generateWriteAccess !storageName !nbBits !addrIdf !true !?code;
  updateWriteWithConsts !memoryConstList !?code !nbBits !param;
  generateWriteMethod !methodName !code !nbBits !?methodMap;
end routine;

routine generateAliasReadMethod
  ?? @lstring compName
  ?? @uint nbBits
  ?! @functionMap methodMap 
  ?? @lstring chunkName
  ?? @memoryChunkAliasMap memoryChunkAliasMap
:
  foreach memoryChunkAliasMap (@lstring aliasName 
                               @memoryParam param
                               @memoryAliasMap memoryAliasMapInAlias
                               @memoryConstList memoryConstList
                               @cExpression mapsToExpression) do
    #method name
    @lstring methodName := [@lstring new ![chunkName string]."_"
                                          .[aliasName string]
                                          ."_read".[nbBits string] !here];
    #implementation
    @instructionList code := [@instructionList emptyList];
    @string addrIdf;
    @bool idfModified;
    setStrideCode !"address" ![param stride] ![chunkName location] !?code ![param addrFrom] ?addrIdf ?idfModified;
    @string chunkReadAccess := [chunkName string]."_read";
    setMapsToInstruction !addrIdf !idfModified !mapsToExpression !?code ?addrIdf;
    @string storageName;
    getStorageName ![compName string] ![chunkName string] ?storageName;
    #no check for value out of boundaries...
    generateReadAccess !storageName !nbBits !addrIdf !true !?code;
    generateReadMethod !methodName !code !nbBits !?methodMap;
  end foreach;
end routine;

routine generateAliasWriteMethod
  ?? @lstring compName
  ?? @uint nbBits
  ?! @functionMap methodMap 
  ?? @lstring chunkName
  ?? @memoryChunkAliasMap memoryChunkAliasMap
  ?? @memoryConstList memoryConstList
:
  foreach memoryChunkAliasMap (@lstring aliasName 
                               @memoryParam param
                               @memoryAliasMap memoryAliasMapInAlias
                               @memoryConstList memoryAliasConstList
                               @cExpression mapsToExpression) do
    #method name
    @lstring methodName := [@lstring new ![chunkName string]."_"
                                          .[aliasName string]
                                          ."_write".[nbBits string] !here];
    #implementation
    @instructionList code := [@instructionList emptyList];
    @string addrIdf;
    @bool idfModified;
    setStrideCode !"address" ![param stride] ![compName location] !?code ![param addrFrom] ?addrIdf ?idfModified;
    setMapsToInstruction !addrIdf !idfModified !mapsToExpression !?code ?addrIdf;
    @string storageName;
    getStorageName ![compName string] ![chunkName string] ?storageName;
    generateWriteAccess !storageName !nbBits !addrIdf !true !?code;
    updateWriteWithConsts !memoryConstList !?code !nbBits !param;
    generateWriteMethod !methodName !code !nbBits !?methodMap;
  end foreach;
end routine;

routine getChunkCondition
  ?? @lstring compName
  ?? @lstring memChunkName
  ?? @memoryParam param
  !  @string conditionCode
:
  @string storageName;
  getStorageName ![compName string] ![memChunkName string] ?storageName;
  @uint addressMin := [param addrFrom];
  @uint addressMax := [param addrTo];
  if(addressMin == 0) then
    conditionCode := "if(address<=".[addressMax string]."U)";
  elsif(addressMax == 0xFFFFFFFF) then
    conditionCode := "if(address>=".[addressMin string]."U)";
  else
    conditionCode := "if((address>=".[addressMin string]."U) && (address<=".[addressMax string]."U))";
  end if;
  conditionCode .= " return ".storageName.";";
end routine;

#memory overlap must have been detected previously!!
routine generateGetChunkMethod 
  ?? @lstring compName
  ?? @memoryChunkMap memoryChunkMap 
  ?! @functionMap methodMap 
:
  #method name
  @lstring methodName := [@lstring new !"getChunk" !here];
  if not [methodMap hasKey ![methodName string]] then
    #return type
    @functionOutTypeCustom typeCustom := [@functionOutTypeCustom new !"storage *"];
    #param
    @parameterDefList paramList := [@parameterDefList emptyList];
    @lstring paramName := [@lstring new !"address" !here];
    @varType paramType := [@varType new ![@varKind unsigned] !32 !here]; #u32 by default
    @classicVar paramVar := [@classicVar new !paramType !true !"" !""]; #address is constant
    paramList += !false !paramName !paramVar;
    #implementation
    @instructionList code := [@instructionList emptyList];
    foreach memoryChunkMap (@lstring memChunkName @memoryParam param ...) do
      @string conditionCode;
      getChunkCondition !compName !memChunkName !param ?conditionCode;
      @cDummy inst:=[@cDummy new !here !conditionCode];
      code += !inst;
    end foreach;
    code += ![@cDummy new !here !"return NULL;"]; #error detected.
    @returnTypeList returnTypeList [emptyList];
    returnTypeList += !typeCustom;
    [!?methodMap insertKey !methodName !paramList !returnTypeList !code];

  end if;
end routine;

routine generateGetProgramChunkMethod
  ?? @componentMap componentMap
  ?! @TfieldMap templateStruct
:
  @string code := "";
  #used to check memory overlaps.
  @memoryChunkMap progMemoryChunkMap [emptyMap];
  foreach componentMap(@lstring compName * * * @memoryChunkMap memoryMap ...) do
    foreach memoryMap(@lstring memChunckName 
                      @memoryParam param 
                      @memoryAliasMap memoryAliasMap
                      @memoryConstList memoryConstList
                      @memoryChunkAliasMap memoryChunkAliasMap) do
      if [param isProg] then
        [!?progMemoryChunkMap insertKey !memChunckName !param !memoryAliasMap !memoryConstList !memoryChunkAliasMap];
        @string conditionCode;
        getChunkCondition !compName !memChunckName !param ?conditionCode;
        code .= "\t".conditionCode."\n";
      end if;
    end foreach;
  end foreach;
  checkMemoryOverlap !progMemoryChunkMap;
  addStringValue !?templateStruct !lstringWith[!"GET_PROGRAM_CHUNK"] !code;
end routine; 

#generate read and write methods.
routine generateReadWriteMethods
  ?? @lstring compName
  ?? @uint nbBits
  ?? @uint type
  ?! @functionMap methodMap 
  ?? @memoryParam param
  ?? @memoryAliasMap unused memoryAliasMap
  ?? @lstring chunkName
  ?? @memoryConstList memoryConstList
  ?? @memoryChunkAliasMap memoryChunkAliasMap
:
  generateGlobalReadMethod !compName !nbBits !?methodMap !param;
  generateChunkReadMethod  !compName !nbBits !?methodMap !chunkName !param;
  generateAliasReadMethod  !compName !nbBits !?methodMap !chunkName !memoryChunkAliasMap;
  if type != 0 then  # ROM?
    generateGlobalWriteMethod !compName !nbBits !?methodMap !param !memoryConstList;
    generateChunkWriteMethod  !compName !nbBits !?methodMap !chunkName !param !memoryConstList;
    generateAliasWriteMethod  !compName !nbBits !?methodMap !chunkName !memoryChunkAliasMap !memoryConstList;
  end if;
end routine;

routine addMemoryRelatedMethods 
  ?? @memoryChunkMap memoryChunkMap 
  ?! @functionMap methodMap 
  ?? @lstring compName
  ?? @lstring chunkName
:
  # check that addesses are correct
  checkMemoryOverlap !memoryChunkMap;
  #log memoryChunkMap;
  #generateGetChunkMethod !compName !memoryChunkMap !?methodMap;

  @memoryParam param;
  @memoryAliasMap memoryAliasMap;
  @memoryConstList memoryConstList; #consts
  @memoryChunkAliasMap memoryChunkAliasMap;
  [memoryChunkMap searchKey !chunkName ?param ?memoryAliasMap ?memoryConstList ?memoryChunkAliasMap];
  #for 64, generate also 32, 16 and 8.
  #for 32, generate also 16 and 8.
  #for 16, generate also 8.
  @uint width := [param width];
  @uint type := [param type];
  generateReadWriteMethods   !compName !width !type !?methodMap !param !memoryAliasMap !chunkName !memoryConstList !memoryChunkAliasMap;
  if width == 64 then
    width := 32;
    generateReadWriteMethods !compName !width !type !?methodMap !param !memoryAliasMap !chunkName !memoryConstList !memoryChunkAliasMap;
  end if;
  if width == 32 then
    width := 16;
    generateReadWriteMethods !compName !width !type !?methodMap !param !memoryAliasMap !chunkName !memoryConstList !memoryChunkAliasMap;
  end if;
  if width == 16 then
    width := 8;
    generateReadWriteMethods !compName !width !type !?methodMap !param !memoryAliasMap !chunkName !memoryConstList !memoryChunkAliasMap;
  end if;
end routine;

# return the internal name of a register defined in a component (corresponding
# to the symbol used in the generated simulator).
# All access to the component register symbol SHOULD use this routine.
function getInternalComponentRegisterName
  ?? @lstring regIdf
  -> @string internalRegName
:
  internalRegName := "__".[regIdf string];
end function;

#function that gives all the registers (in component or in mem) for a given component.
# in the templates, fields are:
# * CType      -> u32, u8, ... the C type returned by the getter accessor
# * size       -> the real size (in bits).
# * regName    -> the register name (without the field)
# * field      -> only defined for a register field (use 'if exists ...' in templates)
# * getterCode -> the getter code (in a whole)
# * setterCode -> the setter code (in a whole)
# * isConst    -> true if the register is constant.
routine getMemoryRegisterSetGetCode
  ?? @lstring compName
  ?? @string methodPrefix
  ?? @memoryAliasMap memoryAliasMap  
  ?? @memoryConstList memoryConstList
  ?? @bool isRegisterMappedInMem
  ?! @TfieldMapList regTplList
:
  foreach memoryAliasMap (@lstring idf @uint size @uint address @registerBitFieldList registerBitFieldList ...) do
    @TfieldMap regTplBody [emptyMap];
    #name
    addLStringValue !?regTplBody !"regName" !idf;
    addUnsignedValue!?regTplBody !lstringWith[!"size"] ![size uint64];
    #type
    @varType type := [@varType new ![@varKind unsigned] !size !here];
    addStringValue  !?regTplBody !lstringWith[!"CType"] ![type getCType];
    
    #check if this is a constant value.
    @bool isConst := false;
    @uint64 constVal := 0L;
    foreach memoryConstList (@uint constAddr @uint64 val) do
      if constAddr == address then
        isConst := true;
        constVal := val;
      end if;
    end foreach;
    addBoolValue  !?regTplBody !lstringWith[!"isConst"] !isConst;

    #get method.
    @string getterCode := "";
    if isConst then 
      getterCode := "return ".[constVal string].";";
    else
      if isRegisterMappedInMem then      
        @string readMethodName := methodPrefix."_read".[size string];
        @string readImplementationName;
        getComponentMethodImplementationName ![compName string] !readMethodName !"" ? readImplementationName;
        getterCode .= "return ".readImplementationName."(".[address hexString].");";
      else
        getterCode .= "return ".getInternalComponentRegisterName[!idf].";";
      end if;
    end if;
    addStringValue  !?regTplBody !lstringWith[!"getterCode"] !getterCode;
    
    #setter code.
    @string setterCode := "";
    if not isConst then 
      if isRegisterMappedInMem then
        @string writeMethodName := methodPrefix."_write".[size string];
        @string writeImplementationName;
        getComponentMethodImplementationName ![compName string] ! writeMethodName !"" ? writeImplementationName;
        setterCode := writeImplementationName."(".[address hexString].", value);";
      else
        @string maskStr := getMaskFor [![type size] ![type location] ![@codeCtx C]];
        @string regName := getInternalComponentRegisterName[!idf];
        setterCode := regName." = value & ".maskStr.";";
      end if;
    end if;
    addStringValue  !?regTplBody !lstringWith[!"setterCode"] !setterCode;
    #end
    regTplList += !regTplBody;

    #now the register fields.
    #bit access get/set method.
    @classicVar varIdf := [@classicVar new !type !false !"" !"()"]; #not constant
    @cIdf idfExp := [@cIdf new !getTypeListFrom[![varIdf type]] !idf !varIdf];
    foreach registerBitFieldList (@lstring  name @fieldList fieldList) do
      @TfieldMap regFieldTplBody [emptyMap];
      addLStringValue  !?regFieldTplBody !"regName" !idf;
      addLStringValue  !?regFieldTplBody !"field" !name;
      addBoolValue     !?regFieldTplBody !lstringWith[!"isConst"] !false;
      
      #type.
      @uint bitFieldSize;
      getFieldListSize !fieldList ?bitFieldSize;
      @varType bitFieldType := [@varType new ![@varKind unsigned] !bitFieldSize !here];
      @string CType := [bitFieldType getCType];
      addStringValue  !?regFieldTplBody !lstringWith[!"CType"] !CType;
      addUnsignedValue!?regFieldTplBody !lstringWith[!"size"] ![bitFieldSize uint64];

      #get code
      @string getterCode := "return ";
      @cBitFieldOp getExp := [@cBitFieldOp new !getTypeListFrom[![@varType new ![@varKind unsigned] !bitFieldSize !here]] !idfExp !fieldList];
      getterCode .= [getExp generateCode !"" !"" ![@codeCtx C]];
      getterCode .= ";";
      addStringValue  !?regFieldTplBody !lstringWith[!"getterCode"] !getterCode;

      #set code
      @lstring valueStr := [@lstring new !"value" !here];
      @lstring valTemp := [@lstring new !"__temp" !here];
      @classicVar varTemp := [@classicVar new !type !true !"" !""]; #__temp not constant
      @string setterCode := "\n\t\t\t".[type getCType]." ".[valTemp string]." = ".[idf string]."();\n\t\t\t";
      #use getExp as a dummy expression (required for tabulars).
      @cIdf valueExp := [@cIdf new !getTypeListFrom[![varTemp type]] !valueStr !varTemp];
      @leftAssignPart leftPart [emptyList];
      @cIdf leftIdf := [@cIdf new !getTypeListFrom[!type] !valTemp !varTemp];
      leftPart += !leftIdf !fieldList;
      @cAssign assignInst := [@cAssign new !here !leftPart !valueExp !0];
      setterCode .= [assignInst generateImplementation !0 !"" !"" ![@codeCtx C]];
      setterCode .= "\t\t\tset".[idf string]."(".[valTemp string].");";
      addStringValue  !?regFieldTplBody !lstringWith[!"setterCode"] !setterCode;

      #end
      regTplList += !regFieldTplBody;
    end foreach;
  end foreach;
end routine;

routine addMemoryRegistersImplementation
  ?? @lstring compName
  ?? @memoryChunkMap memoryMap
  ?! @TfieldMapList regTplList
:
  foreach memoryMap(@lstring memChuckName 
                    * 
                    @memoryAliasMap memoryAliasMap
                    @memoryConstList memoryConstList
                    @memoryChunkAliasMap memoryChunkAliasMap) do
    @string methodPrefix := [memChuckName string];
    getMemoryRegisterSetGetCode !compName !methodPrefix !memoryAliasMap !memoryConstList !true !?regTplList;
    foreach memoryChunkAliasMap (
                    @lstring memChuckAliasName 
                    *
                    @memoryAliasMap memoryAliasInAliasMap
                    @memoryConstList memoryConstInAliasList
                    *) do
      methodPrefix := [memChuckName string]."_".[memChuckAliasName string];
      getMemoryRegisterSetGetCode !compName !methodPrefix !memoryAliasInAliasMap !memoryConstInAliasList !true !?regTplList;
    end foreach;
  end foreach;
end routine;

routine setConstRegisterAtReset
  ?? @componentMap componentMap
  ?! @TfieldMap templateStruct
:
  @string code := "";
  foreach componentMap(@lstring compName * * * @memoryChunkMap memoryMap ...) do
    foreach memoryMap(@lstring memChunckName 
                      @memoryParam param 
                      @memoryAliasMap memoryAliasMap
                      @memoryConstList memoryConstList
                      @memoryChunkAliasMap memoryChunkAliasMap) do
      foreach memoryConstList (@uint address @uint64 value) do
        @uint realAddr := [param addrFrom] + address*[param stride];
        @string storageName;
        getStorageName ![compName string] ![memChunckName string] ?storageName;
        @uint CType;
        getStdCTypeFor ![param width] ?CType;
        code .= "\t".storageName."->put".[CType string]."AtAddr(".[realAddr string].", ".[value string].");\n";
      end foreach;
    end foreach;
  end foreach;
  addStringValue !?templateStruct !lstringWith[!"CONST_MEM_INIT"] !code;
end routine;

routine getRegistersInMap
 ?? @componentMap componentMap
 !  @registersMapsInMemoryMap registersInMemMap
:
  registersInMemMap := [@registersMapsInMemoryMap emptyMap];
  #find registers mapped in memory.
  foreach componentMap(@lstring compName * * * @memoryChunkMap memoryMap ...) do
    foreach memoryMap (@lstring memName * @memoryAliasMap memoryAliasMap * *) do
      foreach memoryAliasMap(@lstring regName @uint size @uint address @registerBitFieldList registerBitFieldList ...) do
        [!?registersInMemMap insertKey !regName !compName !memName !size !address !registerBitFieldList];
      end foreach;
    end foreach;
  end foreach;
end routine;

#init registers (mapped in mem or defined in a component)
#call component 'reset' functions.
routine generateResetFunc
  ?? @componentMap componentMap
  ?! @TfieldMap templateStruct
:
  @string code := "";
  foreach componentMap(@lstring compName * * @functionMap methodMap @memoryChunkMap memoryMap ... ) do
    #First, init registers, as unitialised registers will be set to 0.
    #A reset method may overwrite this value.

    # memory registers only: component registers are initialized in a 
    # standard way (reset)
    foreach memoryMap(@lstring memChuckName *
                      @memoryAliasMap memoryAliasMap ...) do
      foreach memoryAliasMap(@lstring regName @uint size @uint address @registerBitFieldList registerBitFieldList @luint64 resetVal) do
        #TODO: check that value fits into the reg.
        @uint nbBits := nbBitsToCodeUnsigned[![resetVal uint64]];
        if nbBits > size then
          error resetVal: "The reset value (".[nbBits string]." bits) does not fit into the register ".[regName string];
        end if;
        #init reg regName with value resetVal;
        code .= "\tset".[regName string]."(";
        @cIntConst val := [@cIntConst new !getTypeListFrom[![@varType new ![@varKind unsigned] !nbBits !here]] ![resetVal uint64] !false];
        code .= [val generateCode !"" !"" ![@codeCtx C]].");\n";
      end foreach;
    end foreach;
    #reset func.
    if [methodMap hasKey !"reset"] then
      #Check that there is no argument.
      @parameterDefList param;
      @returnTypeList outTypeList;
      [methodMap searchKey ![@lstring new !"reset" !here] ?param ?outTypeList ?*];
      if [param length] == 0 & [outTypeList length] == 0 then
        @string implementationResetCall;
        getComponentMethodImplementationName ![compName string] !"reset" !"" ?implementationResetCall;
        code .= "\t".implementationResetCall."();\n";
      else
        if [option .verbose_output value] then
          message "Does not take care into account reset method of component ".[compName string].
                  ", because the method has arguments";
        end if;
      end if;
    end if;
  end foreach;
  addStringValue !?templateStruct !lstringWith[!"REGS_AND_COMPONENT_RESET"] !code;
end routine;

#it returns the number of elements:
#It calculates the address range
#and divide it by the stride.
#This is used in the DDC to deal with registers
function getNbOfElementsInChunk
  ?? @memoryParam param
  -> @uint nbElt
:
  @uint range := (([param addrTo] - [param addrFrom]) + 1);
  nbElt := range/[param stride];
  if range mod [param stride] != 0 then
    nbElt := nbElt + 1;
  end if;
end function;

end semantics;
# vim:ft=ggs:ts=2:sw=2
