semantics gadl_semantics_timingSectionAutomata:
  import "gadl_semantics_implementation_code_generation.gSemantics"; #inst implementation  
  import "gadl_templates.gSemantics" ;
  import "gadl_template_data_preparation.gSemantics" ; #addStringlist

list @timingInstructionList {
  @timingInstruction instruction ;
}
#Timing instructions
#timingInstruction
#|-> @tLoop
#|-> @tIf
#|-> @tEmit
#|-> @tWaitSignal
#|-> @tWaitCycle
#|-> @tDeclaration
#|-> @tAssignOrCall -> assignment or component's method call.

abstract class @timingInstruction {
     @location loc;
}

class @tEmit extends @timingInstruction {
  @lstring name;
  @bool broadcast;
}

class @tWaitSignal extends @timingInstruction {
  @lstring name;
}

class @tWaitCycle extends @timingInstruction {
  @cExpression expCycle;
}

class @tDeclaration extends @timingInstruction {
  @instructionList instList; #instructions to generate the code.
}

class @tAssignOrCall extends @timingInstruction {
  @instructionList instList;
}

class @tLoop extends @timingInstruction{
  @timingInstructionList instList feature setter; 
  @cExpression conditionExp;
  @luint64 loopValue;
  @lstring invariantLoopVarName;
}

class @tIf extends @timingInstruction{
  @timingInstructionList instList feature setter; 
  @timingInstructionList instListElse feature setter;
  @cExpression expIf;
}

######################################################
map @timingMap {
  @varMap varMap;
  @boolMap SignalIn;
  @boolMap SignalOut;
  @timingInstructionList instList; 
  @bool externalActivation; #using activation, will run one loop.
  insert insertKey error message "the '%K' timing section is already defined in %L" ; 
  search searchKey error message "the '%K' timing section is not defined" ;
}

######################################################
#Adjacency matrix
######################################################
list @luint64list
{
  @luint64 val;
}

# store information about a state.
list @timingStateList{
  @string info feature setter;
  @cExpressionList invariantList feature setter;
  @cExpressionList waitCycleList feature setter;
}

#store information about a transtion.
class @timingTransition {
  @instructionList updateList; #code that should be executed
  @cExpressionList guardList;  #condition list.
  @stringlist synchroInList;   #synchronization (wait for)
  @stringlist synchroOutList;  #synchronization (emit)
  @stringlist synchroOutBroadcastList;  #(emit without waiting) 
}

array @timingStateArray : @timingTransition[2] ;

#Adjacency matrix
#contains an array of dim x dim places
#first  dimension is destination d
#second dimension is source s
#if there is a transition from state s to d, then
# -> [stateArray valueAtIndex !destination! source] should return the @timingTransition
class @adjMat{
  @uint dim;
  @timingStateList stateList ;
  @timingStateArray stateArray ;
}

#***************************************************************************
# routines
#***************************************************************************
function getEmptyTransition
  -> @timingTransition transition
:
  transition := [@timingTransition new ![@instructionList emptyList] ![@cExpressionList emptyList]
                 ![@stringlist emptyList]  ![@stringlist emptyList] ![@stringlist emptyList]];
end function;

modifier @timingTransition addUpdate
  ?? @cInstruction inst
:
  updateList += !inst;
end modifier;

modifier @timingTransition addGuard
  ?? @cExpression exp
:
  guardList += !exp;
end modifier;

modifier @timingTransition addSynchro
  ?? @string signalName
  ?? @bool sigIn
  ?? @bool broadcast
:
  if sigIn then synchroInList += ! signalName; #wait
  else 
    if broadcast then
      synchroOutBroadcastList += !signalName; #emit without waiting
    else
      synchroOutList += !signalName; #emit with rendez-vous
    end if;
  end if;
end modifier;

modifier @adjMat addState
  ?? @string info   # information about the node
  !  @uint   nodeId # id of the new created node
:
  nodeId := [stateList length];
  @timingStateList tmp := stateList ;
  tmp += !info ![@cExpressionList emptyList] ![@cExpressionList emptyList];
  stateList := tmp;
end modifier;

modifier @adjMat updateStateInfo
  ?? @uint nodeId
  ?? @string info
:
  @timingStateList tsList := stateList  ;
  if nodeId >= [tsList length] then
    error here: "internal error in timing section: try to update a non existing state";
  else
    @string newInfo := [tsList infoAtIndex !nodeId];
    if newInfo != "" then newInfo .= ","; end if;
    newInfo .= info;
    [!?tsList setInfoAtIndex !newInfo !nodeId];
  end if;
  stateList := tsList; 
end modifier;

modifier @adjMat addStateInvariant
  ?? @uint nodeId
  ?? @cExpression invariant
:
  @timingStateList tsList := stateList  ;
  if nodeId >= [tsList length] then
    error here: "internal error in timing section: try to update a non existing state";
  else
    @cExpressionList invList := [tsList invariantListAtIndex !nodeId];
    invList += !invariant;
    [!?tsList setInvariantListAtIndex !invList !nodeId];    
  end if;
  stateList := tsList; 
end modifier;

modifier @adjMat addWaitCycle
  ?? @uint nodeId
  ?? @cExpression cycle
:
  @timingStateList tsList := stateList  ;
  if nodeId >= [tsList length] then
    error here: "internal error in timing section: try to update a non existing state";
  else
    @cExpressionList waitCycleList := [tsList waitCycleListAtIndex !nodeId];
    waitCycleList += !cycle;
    [!?tsList setWaitCycleListAtIndex !waitCycleList !nodeId];    
  end if;
  stateList := tsList; 
end modifier;

reader @adjMat getTransition
  ?? @uint dst
  ?? @uint src
  -> @timingTransition transition
:
   @bool valid :=  [stateArray isValueValidAtIndex !dst !src];
   if not valid then 
     error here:"internal error: try to read a non existing transition";
   end if;
   transition := [stateArray valueAtIndex !dst !src];
end reader;

#add information on a transition.
modifier @adjMat updateTransition
  ?? @uint dst
  ?? @uint src
  ?? @timingTransition transition
:
   [!?stateArray setValueAtIndex !transition !dst !src] ;
end modifier ;

reader @adjMat getIncomingTransitions 
 ?? @uint dst
 -> @uintlist transitionList
:
  @range dimSrc:= [stateArray rangeForAxis !1];
  transitionList := [@uintlist emptyList];
  for src in dimSrc do
    @bool valid :=  [stateArray isValueValidAtIndex !dst !src];
    if valid then  
      transitionList += !src;
    end if;
  end for;
end reader;

reader @adjMat getOutputTransitions 
 ?? @uint src
 -> @uintlist transitionList
:
  @range dimDst:= [stateArray rangeForAxis !0];
  transitionList := [@uintlist emptyList];
  for dst in dimDst do
    @bool valid :=  [stateArray isValueValidAtIndex !dst !src];
    if valid then  
      transitionList += !dst;
    end if;
  end for;
end reader;

modifier @adjMat addTransition 
  ?? @uint source
  ?? @uint destination
  ?? @timingTransition transition
:
  @bool update := false;
  if [stateArray sizeForAxis !0] > destination &
     [stateArray sizeForAxis !1] > source then
     #array is currently large enough -> we have to update transition?
     @bool b :=  [stateArray isValueValidAtIndex !destination !source];
     if b then 
       error here :"internal error: There is already a transition";
     end if;
  end if;
  if not update then
    [!?stateArray forceValueAtIndex !transition !destination !source] ;   
  end if;
end modifier;

#this reader should not be called directly: it gets the label for a transition.
reader @timingTransition getGraphVizExport
  -> @string dotFile
:
  dotFile := "[label = \"";
  #update list.
  foreach updateList(@cInstruction inst)
  before dotFile .= "up :";
  do 
    dotFile .= [inst generateImplementation !0 !"" !"" ![@codeCtx Uppaal]];
  between dotFile .= ", ";
  end foreach;
  #guard list
  foreach guardList(@cExpression exp)
  before dotFile .= "guard :";
  do 
    dotFile .= [exp generateCode !"" !"" ![@codeCtx Uppaal]];
  between dotFile .= ", ";
  end foreach;
  #signals
  foreach synchroInList(@string sig)
  before dotFile .= "wait for :";
  do 
    dotFile .= sig;
  between dotFile .= ", ";
  end foreach;
  foreach synchroOutList(@string sig)
  before dotFile .= "emit :";
  do 
    dotFile .= sig;
  between dotFile .= ", ";
  end foreach;
  foreach synchroOutBroadcastList(@string sig)
  before dotFile .= "broadcast emit :";
  do 
    dotFile .= sig;
  between dotFile .= ", ";
  end foreach;
  dotFile .= "\"];";
end reader;

reader @adjMat getGraphVizExport
  -> @string dotFile
:
  dotFile := "digraph timingAutomata{\n";
  @uint nodeId := 0;
  foreach stateList (@string  name @cExpressionList invList @cExpressionList waitCycleList) do
    @string invariantStr:="";  
    foreach invList (@cExpression exp) do
      invariantStr .= [exp generateCode !"" !"" ![@codeCtx Uppaal]];
    between invariantStr .= ", ";
    end foreach;
    dotFile .= " \"".[nodeId string ] ."\" [label=\"".name;
    if invariantStr != "" & name != "" then
      dotFile .= " - ";
    end if;
    dotFile .= invariantStr;
    foreach waitCycleList (@cExpression exp)
    before if invariantStr != "" then dotFile .= ", "; end if; dotFile .= "wait for ";
    do 
      @string waitStr := [exp generateCode !"" !"" ![@codeCtx Uppaal]];
      dotFile .= waitStr;
    between dotFile .= "+";
    after dotFile .= " cycles";
    end foreach;
    dotFile .= "\" ];\n";
    nodeId := nodeId + 1;
  end foreach;

  @range dstRange:= [stateArray rangeForAxis !0];
  @range srcRange:= [stateArray rangeForAxis !1];
  for dst in dstRange  do
    for src in srcRange do
      @bool b :=  [stateArray isValueValidAtIndex !dst !src];
      if b then 
        dotFile .=" \"".[src string]."\" -> \"".[dst string]."\" ";
        @timingTransition transition := [stateArray valueAtIndex !dst !src];
        dotFile .= [transition getGraphVizExport];
        dotFile .="\n";
      end if;
    end for;
  end for;
  dotFile .= "}\n";
end reader;

#################################################################################
# method to update the matrix.
# here is a modifier associated to each 
# instruction that updates the adjacency matrix
# to construct the automata.
#
# the matrix models the HARMLESS automata, i.e. a "Wait for xx cycle" timing
# is done in one state, contrary to the Uppaal approach.
#################################################################################
abstract method @timingInstruction buildAdjMatrix 
  ?! @adjMat mat
  ?! @uintlist stack
  ?! @uint current
  ?? @varMap varMap
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
;

override method @tAssignOrCall buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist unused stack
  ?! @uint current
  ?? @varMap unused varMap
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
:
  if not uppaalExport then #not exported to Uppaal -> only related to communicate with the simulator.
    @uint newStateId;
    [!?mat addState !"" ?newStateId];
    @timingTransition transition := getEmptyTransition[];
    foreach instList (@cInstruction inst) do
      [!?transition addUpdate !inst];
    end foreach;
    [!?mat addTransition !current !newStateId !transition];
    current := newStateId;
  end if;
end method;

override method @tDeclaration buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist unused stack
  ?! @uint current
  ?? @varMap unused varMap
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
:
  #this can be a "declare and assign instruction"
  #first remove all declaration.
  @instructionList instListWithoutDeclare [emptyList];
  foreach instList (@cInstruction inst) do
    cast inst
    when == @cDeclareVar : #nothing
    else
      instListWithoutDeclare += !inst;
    end cast;
  end foreach;
  #if there are assign, it works as a tAssignOrCall
  if [instListWithoutDeclare length] > 0 then    
    if not uppaalExport then #not exported to Uppaal -> only related to communicate with the simulator.
      @uint newStateId;
      [!?mat addState !"" ?newStateId];
      @timingTransition transition := getEmptyTransition[];
      foreach instListWithoutDeclare (@cInstruction inst) do
        [!?transition addUpdate !inst];
      end foreach;
      [!?mat addTransition !current !newStateId !transition];
      current := newStateId;
    end if;
  end if;
end method;

override method @tWaitSignal buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist unused stack
  ?! @uint current
  ?? @varMap unused varMap
  ?? @bool unused uppaalExport #Uppaal export and simulation are identical.
:
  @uint newStateId;
  [!?mat addState !"" ?newStateId];
  #add transition beween current and emit
  @timingTransition transition := getEmptyTransition[];
  [!?transition addSynchro ![name string] !true !false]; #wait, no broadcast (not used).
  [!?mat addTransition !current !newStateId !transition];
  current := newStateId;
end method;

override method @tEmit buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist unused stack
  ?! @uint current
  ?? @varMap unused varMap
  ?? @bool unused uppaalExport #Uppaal export and simulation are identical.
:
  @uint newStateId;
  [!?mat addState !"" ?newStateId];
  #add transition beween current and emit
  @timingTransition transition := getEmptyTransition[];
  [!?transition addSynchro ![name string] !false !broadcast];
  [!?mat addTransition !current !newStateId !transition];
  current := newStateId;
end method;

override method @tWaitCycle buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist unused stack
  ?! @uint current
  ?? @varMap unused varMap
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
:
  if uppaalExport then
    #   - init a clock from incoming transitions (to the state that waits): clock = 0
    #   - add an invariant (clock <= xx) into the state
    #   - add a guard to output transitions (clock == xx)

    #build a @cIdf (identifier as an expression) to model the "cycle" idf.
    #and other stuff to build expressions and instructions.
    @varType clockType := [@varType new ![@varKind unsigned] !32 !here];
    @classicVar clockVar := [@classicVar new !clockType !false !"" !""];
    @cIdf clockIdf := getExpIdf[![@varKind unsigned] !32 !false !"" !"" ![@lstring new !"cycle" !here]];
    @leftAssignPart leftPartClock [emptyList];
    leftPartClock += !clockIdf ![@fieldList emptyList];  
    @varTypeList boolOutType := getTypeListFrom[!getBoolVarType[]]; #return type of exp: bool
    @cIntConst expZero := getExpUint[!1 !0L];
    #get predecessors (incoming transitions)
    @uintlist predList := [mat getIncomingTransitions !current];
    foreach predList (@uint src) do 
      #update transition from predecessor to stateId node.
      #build instruction "clock = 0" and affect to update list of transition
      @timingTransition transition := [mat getTransition !current !src];
      @cAssign assign := [@cAssign new !here !leftPartClock !expZero !0];
      [!?transition addUpdate !assign];
      [!?mat updateTransition !current !src !transition];
    end foreach;
    #add invariant condition on stateId node.
    @cBinaryBasicOp comp := [@cBinaryBasicOp new !boolOutType !clockIdf !expCycle !9]; # '<='
    [!?mat addStateInvariant !current !comp]; #clock <= cycle
    #add a guard on output transition: clock = cycle
    @uint newStateId;
    [!?mat addState !"" ?newStateId];
    @timingTransition transition := getEmptyTransition[];
    @cBinaryBasicOp equ := [@cBinaryBasicOp new !boolOutType !clockIdf !expCycle !11]; # '='
    [!?transition addGuard !equ];
    [!?mat addTransition !current !newStateId !transition];
    current := newStateId;
  else 
    #simulation: associate a waiting period to the state.
    [!?mat addWaitCycle !current !expCycle];
  end if;
end method;


override method @tLoop buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist stack
  ?! @uint current
  ?? @varMap varMap
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
:
  #build a @cIdf (identifier as an expression) to model the "invariant" idf.
  #and other stuff to build expressions and instructions.
  @abstractVar variableLoop;
  [varMap searchKey !invariantLoopVarName ?variableLoop]; #var is defined (internal error otherwise)
  @varTypeList LoopVarType := getTypeListFrom[![variableLoop type]];
  @cIdf loopIdf := [@cIdf new !getTypeListFrom[![variableLoop type]] !invariantLoopVarName !variableLoop];
  @leftAssignPart loopLeftPart [emptyList];
  loopLeftPart += !loopIdf ![@fieldList emptyList];
  @cIntConst expLoop := getExpUint[!32 ![loopValue uint64]];  
  @cIntConst expZero := getExpUint[!1 !0L];  
  @cIntConst expOne := getExpUint[!1 !1L];  
  @varTypeList boolOutType := getTypeListFrom[!getBoolVarType[]]; #return type of exp: bool
  @varTypeList u32OutType := getTypeListFrom[![@varType new ![@varKind unsigned] !32 !here]]; 
  #store the state that evaluates condition loop.
  stack += !current;
  #each pred init the clock.
  @uintlist predList := [mat getIncomingTransitions !current];
  foreach predList (@uint x)  do 
    @timingTransition transition := [mat getTransition !current !x];
    @cAssign assign := [@cAssign new !here !loopLeftPart !expZero !0]; #invLoop = 0;
    [!?transition addUpdate !assign];
    [!?mat updateTransition !current !x !transition];
  end foreach;
  #condition true.
  @uint newStateId;
  [!?mat addState !"" ?newStateId];
  @timingTransition transitionTrue := getEmptyTransition[];
  if uppaalExport then
    #limit only in Uppaal with the max nb of loops.
    @cBinaryBasicOp comp := [@cBinaryBasicOp new !boolOutType !loopIdf !expLoop !9]; # 'loopIdf <= expLoop'
    [!?transitionTrue addGuard !comp]; 
  else
    [!?transitionTrue addGuard !conditionExp]; 
  end if;
  [!?mat addTransition !current !newStateId !transitionTrue];
  current := newStateId;
  #loop if the condition is true
  foreach instList (@timingInstruction t) do
    [t buildAdjMatrix !?mat !?stack !?current !varMap !uppaalExport];
  end foreach;
  #get back the state that evaluates condition loop.
  @uint id ;
  [!?stack popLast ?id];
  #and close the loop.
  @timingTransition transitionInc := getEmptyTransition[];
  @cBinaryBasicOp inc := [@cBinaryBasicOp new !LoopVarType !loopIdf !expOne !3]; # 'invLoop+1'
  @cAssign assignInc := [@cAssign new !here !loopLeftPart !inc !0]; #invLoop = invLoop+1;
  [!?transitionInc addUpdate !assignInc];
  [!?mat addTransition !current !id !transitionInc];
  current := id;
  #exit transition. (false condition)
  [!?mat addState !"" ?newStateId];
  @timingTransition transitionFalse := getEmptyTransition[];
  @cUnaryOp expFalse := [@cUnaryOp new !boolOutType !conditionExp !0]; #!(exp)
  if not uppaalExport then #can always exit in Uppaal
    [!?transitionFalse addGuard !expFalse];
  end if;
  [!?mat addTransition !current !newStateId !transitionFalse];
  current := newStateId;
end method;

override method @tIf buildAdjMatrix
  ?! @adjMat mat
  ?! @uintlist stack
  ?! @uint current
  ?? @varMap varMap
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
:
  @string ifIdStr := [current string];
  @varTypeList boolOutType := getTypeListFrom[!getBoolVarType[]]; #return type of exp: bool
  #add a node to start evaluate the if :-/ really needed?
  @uint newStateId;
  [!?mat addState !"if_".ifIdStr ?newStateId];
  [!?mat addTransition !current !newStateId !getEmptyTransition[]];
  current := newStateId;
  stack += !current;
  
  #branch if the condition is true.
  @timingTransition transition := getEmptyTransition[];
  if not uppaalExport then # no condition in Uppaal
    [!?transition addGuard !expIf];
  end if;
  [!?mat addState !"condOk_".ifIdStr ?newStateId];
  [!?mat addTransition !current !newStateId !transition];
  current := newStateId;
  
  foreach instList (@timingInstruction t) do
    [t buildAdjMatrix !?mat !?stack !?current !varMap !uppaalExport];
  end foreach;

  #end of the 'if' branch
  [!?mat addState !"endIf_".ifIdStr ?newStateId];
  [!?mat addTransition !current !newStateId !getEmptyTransition[]];
  current :=newStateId;

  #get back the state that is the start of the 'if'
  @uint id ;
  [!?stack popLast ?id]; 
  #and put the last state of the if ('end if')
  stack += !current;
  #generate the else branch (from 'id').
  current := id;
  [!?mat addState !"else".ifIdStr ?newStateId];
  @timingTransition transitionFalse := getEmptyTransition[];
  @cUnaryOp expFalse := [@cUnaryOp new !boolOutType !expIf !0]; #!(exp)
  if not uppaalExport then # no condition in Uppaal
    [!?transitionFalse addGuard !expFalse];
  end if;
  [!?mat addTransition !current !newStateId !transitionFalse];
  current := newStateId;
  foreach instListElse (@timingInstruction t) do
    [t buildAdjMatrix !?mat !?stack !?current !varMap !uppaalExport];
  end foreach;
  #get back the "end if" state (i.e. last state of the if branch).
  [!?stack popLast ?id]; 
  [!?mat addTransition !current !id !getEmptyTransition[]];
  current :=id   ;
end method;

#function that generate an expression that is the sum of
#the expressions in the list.
function getExpSum
  ?? @cExpressionList expList
  -> @cExpression sum
:
  if [expList length] == 0 then sum := getExpUint[!32 !0L]; #return 0
  else
    @cExpressionList expListMod := expList;
    @cExpression left;
    [!?expListMod popFirst ?left];
    foreach expListMod (@cExpression exp) do
      @cExpression right;
      [!?expListMod popFirst ?right];
      @varType leftType;
      @varType rightType;
      checkOneExpressionOutType !left ?leftType;
      checkOneExpressionOutType !right ?rightType;
      @varType outType :=typeAdd[!leftType !rightType];
      left := [@cBinaryBasicOp new !getTypeListFrom[!outType] !left !right !3]; #'+'
    end foreach;
    sum := left;
  end if;
end function;

#calculate the sum of the list for wait cycles -> no more useful.
function getUint64ListSum
  ?? @luint64list waitCycleList
  -> @uint64 sum
:
  sum := 0L;
  foreach waitCycleList (@luint64 val) do 
    sum := sum+[val uint64]; 
  end foreach;
end function;

#transform the Harmless automata into an Uppaal compliant automata:
#Changes are:
# * remove the 'wait xx cycle' in states and
#   - init a clock from incoming transitions (to the state that waits): clock = 0
#   - add an invariant (clock <= xx) into the state
#   - add a guard to output transitions (clock == xx)
function buildUppaalAutomata 
  ?? @adjMat harmlessAutomata
  -> @adjMat uppaalAutomata
:
  uppaalAutomata := harmlessAutomata;
  #for each state.
  @uint stateId := 0;
  foreach [uppaalAutomata stateList] (* * @cExpressionList waitCycleList) do
    #if there is a wait, generate the Uppaal related transitions.
    if [waitCycleList length] > 0 then
      #build a @cIdf (identifier as an expression) to model the "cycle" idf.
      #and other stuff to build expressions and instructions.
      @varType clockType := [@varType new ![@varKind unsigned] !32 !here];
      @classicVar clockVar := [@classicVar new !clockType !false !"" !""];
      @cIdf clockIdf := getExpIdf[![@varKind unsigned] !32 !false !"" !"" ![@lstring new !"cycle" !here]];
      @leftAssignPart leftPartClock [emptyList];
      leftPartClock += !clockIdf ![@fieldList emptyList];  
      @cExpression expCycle:=getExpSum[!waitCycleList];
      @varTypeList boolOutType := getTypeListFrom[!getBoolVarType[]]; #return type of exp: bool
      @cIntConst expZero := getExpUint[!1 !0L];    
      #get predecessors (incoming transitions)
      @uintlist predList := [uppaalAutomata getIncomingTransitions !stateId];
      foreach predList (@uint src) do 
        #update transition from predecessor to stateId node.
        #build instruction "cycle = 0" and affect to update list of transition
        @timingTransition transition := [uppaalAutomata getTransition !stateId !src];
        @cAssign assign := [@cAssign new !here !leftPartClock !expZero !0];
        [!?transition addUpdate !assign];
        [!?uppaalAutomata updateTransition !stateId !src !transition];
      end foreach;
      #add invariant condition on stateId node.
      @cBinaryBasicOp comp := [@cBinaryBasicOp new !boolOutType !clockIdf !expCycle !9]; # '<='
      [!?uppaalAutomata addStateInvariant !stateId !comp]; #cycle < sum.
      #add a guard on output transitions: cycle = sum
      @uintlist nextList := [uppaalAutomata getOutputTransitions !stateId];      
      foreach nextList (@uint dst) do
        #update output transition to add guard: cycle = sum
        @timingTransition transition := [uppaalAutomata getTransition !dst !stateId];
        @cBinaryBasicOp equ := [@cBinaryBasicOp new !boolOutType !clockIdf !expCycle !11]; # '='
        [!?transition addGuard !equ];
        [!?uppaalAutomata updateTransition !dst !stateId !transition];
      end foreach;      
    end if;
    stateId := stateId + 1;
  end foreach;
end function;


function computeMatAdj
  ?? @timingInstructionList instList
  ?? @varMap varMap
  ?? @bool externalActivation # if there is an external activation, we have to generate an empty last state.
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
  -> @adjMat automata
:
  @timingStateList stateList [emptyList];
  @timingStateArray tb :=  [@timingStateArray  new !1 !1];
  automata := [@adjMat new !1 !stateList !tb];
  @uintlist stack [emptyList];
  @uint firstState;
  @uint current;
  
  #we have to generate 2 states, because the first one does NOT have incoming transitions at this time.
  #Other call to 'buildAdjMatrix' may generate incorrect behavior if they call the 'getIncomingTransitions' modifier.
  #The set of incoming transitions to the second state will not change.
  [!?automata addState !"start" ?firstState];
  [!?automata addState !"startEnd" ?current];
  [!?automata addTransition !firstState !current !getEmptyTransition[]];
  foreach instList (@timingInstruction t) do
      [t buildAdjMatrix !?automata !?stack !?current !varMap !uppaalExport];
  end foreach;
  if externalActivation then
    #with external activation, we have to set another state 'last'. When we are in this state, one loop
    #of the automata have been done.
    @uint previous := current;
    [!?automata addState !"last" ?current];
    [!?automata addTransition !previous !current !getEmptyTransition[]];
  end if;
  [!?automata addTransition !current !firstState !getEmptyTransition[]]; #loop from the last state to init. 
end function;

function getTemplateExpList
  ?? @cExpressionList expList
  ?? @bool uppaalExport
  -> @TfieldMapList expTplList
:
  expTplList := [@TfieldMapList emptyList];
  #registers declaration.
  foreach expList (@cExpression exp) do
    @TfieldMap expTplBody [emptyMap];
    if uppaalExport then
      @string expStr := [exp generateCode !"" !"" ![@codeCtx Uppaal]];
      addStringValue !?expTplBody !lstringWith[!"exp"] !getXMLCompliant[!expStr];
    else
      @string expStr := [exp generateCode !"_arch->" !"" ![@codeCtx C]];
      addStringValue !?expTplBody !lstringWith[!"exp"] !expStr;      
    end if;
    #end
    expTplList += !expTplBody;
  end foreach;
end function;

# this routine give information about adjacency matrix to be used 
# in the template subsystem.
routine adjacencyMatrixTemplate
  ?? @adjMat mat
  ?! @TfieldMap templateStruct
  ?? @bool uppaalExport #true if Uppaal export, false if simulation.
  ?? @pointList stateCoordinateList
:
  @string uppaalStr := "";
  @codeCtx codeContext;
  if uppaalExport then 
    #Uppaal export
    uppaalStr := "Uppaal";
    codeContext := [@codeCtx Uppaal];
  else
    #simulation
    codeContext := [@codeCtx C];
  end if;
  @TfieldMapList timingPointListTpl [emptyList];
  #state list.
  @TfieldMapList stateListTpl [emptyList];
  @uint stateId := 0;
  #if we do not have coordinates...
  @pointList stateCoordinateListUpdated;
  if uppaalExport then
    @uint nbStates := [[mat stateList] length];
    if [stateCoordinateList length] != nbStates then #there was a pb with the 'dot' program
      if [option .verbose_output value] then
        message "*** To have a more readable Uppaal export, consider installing graphviz tool\n";
        message "*** -> sudo apt-get install graphviz on Debian/Ubuntu.\n";
      end if;
      stateCoordinateListUpdated := [@pointList emptyList];
      @uint id := 0;
      foreach [mat stateList] (...) do
        stateCoordinateListUpdated += !id !0 !0;
        id := id + 1;
      end foreach;
    else
      stateCoordinateListUpdated := stateCoordinateList;
    end if;
  else
    stateCoordinateListUpdated := stateCoordinateList;
  end if;

  foreach [mat stateList] (@string info @cExpressionList invariantList @cExpressionList waitCycleList), stateCoordinateListUpdated (@uint id @uint x @uint y) do
    @TfieldMap stateListTplBody [emptyMap];
    #state information
    if info != "" then
      addStringValue !?stateListTplBody !lstringWith[!"info"] !info;
    end if;
    if uppaalExport then #specific to Uppaal
      #no invariant in simulation.
      addListValue !?stateListTplBody !lstringWith[!"invariant"] !getTemplateExpList[!invariantList !true];
      #is state urgent?
      #state is urgent, until if we should wait in the state or there are synchro on output edges.
      @bool urgent := [invariantList length] == 0; #wait in that state?
      if urgent then
        @uintlist nextList := [mat getOutputTransitions !stateId];      
        foreach nextList (@uint dst) do
          @timingTransition transition := [mat getTransition !dst !stateId];
          if [[transition synchroInList] length] > 0 then urgent := false; end if;
          if [[transition synchroOutList] length] > 0 then urgent := false; end if;
          if [[transition synchroOutBroadcastList] length] > 0 then urgent := false; end if;
        end foreach;
      end if;
      addBoolValue !?stateListTplBody !lstringWith[!"urgent"] !urgent;
    else #specific to simulation.
      #wait cycles.
      addListValue !?stateListTplBody !lstringWith[!"waitCycles"] !getTemplateExpList[!waitCycleList !true];
    end if;
    #state coordinates
    addUnsignedValue !?stateListTplBody !lstringWith[!"id"] ![id uint64];
    addUnsignedValue !?stateListTplBody !lstringWith[!"x"] ![x uint64];
    addUnsignedValue !?stateListTplBody !lstringWith[!"y"] ![y uint64];
    stateListTpl += !stateListTplBody;
    stateId := stateId+1;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"stateList".uppaalStr] !stateListTpl;  
  #transitions
  @timingStateArray stateArray := [mat stateArray];
  @TfieldMapList transitionListTpl [emptyList];
  @range dimSrc:= [stateArray rangeForAxis !1];
  @range dimDst:= [stateArray rangeForAxis !0];
  for src in dimSrc do
    for dst in dimDst do
      @bool valid :=  [stateArray isValueValidAtIndex !dst !src];
      if valid then
        @TfieldMap transitionListTplBody [emptyMap];  
        @timingTransition transition := [stateArray valueAtIndex !dst !src];
        #src transition
        addUnsignedValue !?transitionListTplBody !lstringWith[!"src"] ![src uint64];
        #dst transition
        addUnsignedValue !?transitionListTplBody !lstringWith[!"dst"] ![dst uint64];
        #guard transition
        addListValue !?transitionListTplBody !lstringWith[!"guardList"] !getTemplateExpList[![transition guardList] !uppaalExport];  
        #synchro
        addStringlist !?transitionListTplBody !lstringWith[!"waitSignalList"] !lstringWith[!"name"] ![transition synchroInList];
        addStringlist !?transitionListTplBody !lstringWith[!"emitSignalList"] !lstringWith[!"name"] ![transition synchroOutList];
        addStringlist !?transitionListTplBody !lstringWith[!"emitBroadcastSignalList"] !lstringWith[!"name"] ![transition synchroOutBroadcastList];
        #update
        @stringlist updateList [emptyList];
        foreach [transition updateList] (@cInstruction inst) do
          updateList += ![inst generateImplementation !0 !"" !"" !codeContext];
        end foreach;
        addStringlist !?transitionListTplBody !lstringWith[!"updateList"] !lstringWith[!"str"] !updateList;
        #store in structure.
        transitionListTpl += !transitionListTplBody;
      end if;      
    end for;
  end for;
  addListValue !?templateStruct !lstringWith[!"transitionList".uppaalStr] !transitionListTpl;  
end routine;


list @pointList {
  @uint id;
  @uint x;
  @uint y;
}
#this routine: 
# * generates the .dot file (graphviz)
# * call the external 'dot' program to get back state coordinates
# * return coordinates of each states.
routine getAutomataCoordinates
  ?? @string modelName
  ?? @adjMat automata
  ?? @lstring timingName
  !  @pointList pointList
:
  pointList := [@pointList emptyList];
  @string dotFile := [automata getGraphVizExport];
  const @string filename := modelName."/log/timing_".[timingName string]."Uppaal.dot";
  createFile !modelName."/log/" !"timing_".[timingName string]."Uppaal.dot" !dotFile;
  const @string command := "python ".modelName."/getCoordFromDot.py ".filename ;
  #run script
  @string result := [command popen];
  #result format for each line:%d %d %d //-> 'state id' 'x location' 'y location'
  @stringlist lineList := [result componentsSeparatedByString !"\n"];
  foreach lineList (@string line) do
    if line != "" then
      @stringlist itemList := [line componentsSeparatedByString !" "];
      @string item;
      [!?itemList popFirst ?item];
      if item == "point" then
        [!?itemList popFirst ?item];
        @uint id := [item decimalUnsignedNumber];
        [!?itemList popFirst ?item];
        @uint x := [item decimalUnsignedNumber];
        [itemList first ?item]; 
        @uint y := [item decimalUnsignedNumber];
        pointList += !id !x !y;
      end if;
    end if;
  end foreach;
end routine;


end semantics ;
# vim:ft=ggs:ts=2:sw=2
