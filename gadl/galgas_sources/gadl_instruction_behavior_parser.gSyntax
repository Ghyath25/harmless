syntax gadl_instruction_behavior_parser ("gadl_lexique.gLexique") :

import "gadl_options.gOption" ;
import "gadl_semantics_function.gSemantics" ; #@parameterDefList
import "gadl_semantics_behavior_data_structures.gSemantics" ;

#TODO: faire en sorte qu'une variable placee dans un 
#      select n'utilise pas un mapToOvverride, car si c'est le même nom, ça va coincer!!!
#      il n'y a pas de vérification à ce niveau là (dans le même behavior).


#from gadl_function_parser
nonterminal <functionDefParam> !@parameterDefList parameterDefList;

#from gadl_implementation_parser
nonterminal <typeDeclaration> ! @varAbstractType type;
nonterminal <assignmentLeft> ?? @ASTExpression idf ?! @ASTInstructionList instList;
nonterminal <implementation> ?! @ASTInstructionList instList;
nonterminal <declaration> ?! @ASTInstructionList instList;
nonterminal <implementationOrEmpty> ?! @ASTInstructionList instList;


#from gadl_expression_parser
nonterminal <paramCall> !@ASTExpressionlist idfExpList;

rule <behaviorImplementationPart>
  ?! @ASTbehaviorChunkList chunkList
:
  @ASTInstructionList instList [ emptyList];
  $do$;
  @location loc := here;
  <implementationOrEmpty> !?instList;
  $end$; $do$; 
  chunkList += ![@ASTbehChunkImplementation new !loc !instList];
end rule;

rule <behaviorFieldDeclaration>
  ?! @ASTInstructionList instList
:
  $field$; 
  @varAbstractType type;
  <typeDeclaration> ?type;
  @lstring idf;
  $idf$ ?idf;
  instList += ![@ASTInstDeclaration new !here ![@varClass field] !type !idf];
end rule;

rule <otherBehaviorCall> 
  ?! @ASTbehaviorChunkList chunkList
:
  @lstring postRefName;
  @lstring behaviorCallName;
  $idf$ ?behaviorCallName;
  @ASTExpressionlist idfExpList;
  select
    <paramCall> ?idfExpList;
  or
    #nothing.
    idfExpList := [@ASTExpressionlist emptyList];
  end select;
  #suffix?
  select
    #no post ref name.
    postRefName := [@lstring new !"" !here];    
  or
    $postReference$ ?postRefName;
  end select;
  chunkList += ![@ASTbehChunkCall new ![behaviorCallName location] !behaviorCallName !idfExpList !postRefName];
end rule;

rule <behavior>
  ?! @ASTbehaviorMap ASTbehaviorMap
  ?! @uint unused internalBehaviorId #TODO: remove?
:
  $behavior$;
  @lstring behaviorName;
  $idf$ ?behaviorName;
  @parameterDefList parameterDefList;
  select
    <functionDefParam> ?parameterDefList;
  or
    parameterDefList :=[@parameterDefList emptyList];
  end select;
  @ASTBehBody body;
  <behaviorBody> ?body;
  $end$; $behavior$;
  [!?ASTbehaviorMap insertKey !behaviorName !parameterDefList !body];
end rule;

rule <behaviorBody>
  !@ASTBehBody body
:
  @ASTInstructionList fieldList [emptyList];
  @ASTInstructionList varDeclarationList [emptyList];
  @stringset referenceSet [emptySet];
  @ASTbehaviorChunkList chunkList [emptyList];
  @location loc := here;
  repeat
  while
    <behaviorFieldDeclaration> !?fieldList;
  while
    <declaration> !?varDeclarationList;
  while
    #implementation
    <behaviorImplementationPart> !?chunkList;
  while
    #ref only. Add it.
    @lstring refName;
    $reference$ ?refName;
    referenceSet += ![refName string];
  while
    <selectPart> !?chunkList;
  while
    #other behaviors call.
    <otherBehaviorCall> !?chunkList;
  end repeat;
  body := [@ASTBehBody new !loc !fieldList !varDeclarationList !referenceSet !chunkList];
end rule;

rule <selectPart>
  ?! @ASTbehaviorChunkList chunkList
:
  @ASTBehBodyList bodyList [emptyList];
  $select$;
  @location loc := here;
  repeat
  while
    $case$;
    @ASTBehBody body;
    <behaviorBody> ?body;
    bodyList += !body;
  end repeat;
  $end$;
  $select$;
  chunkList += ![@ASTbehChunkSelect new !loc !bodyList];
end rule;

end syntax ;
# vim:ft=ggs:ts=2:sw=2
