semantics gadl_semantics_peripherals:
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_components.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_templates.gSemantics" ;
  import "gadl_semantics_memory.gSemantics" ;

routine generateCodeForRegistersMappedInMemory
  ?? @componentMap componentMap
  ?! @TfieldMap templateStruct
:
  @registersMapsInMemoryMap registersInMemMap;
  getRegistersInMap !componentMap ?registersInMemMap;
  @TfieldMapList periphRWRegisterList := [@TfieldMapList emptyList];
  foreach componentMap(* * * * * * * @readWriteActionList readWriteActionList ...) do
    foreach readWriteActionList (@bool accessType @lstring regName @instructionList instList) do
      if [registersInMemMap hasKey ![regName string]] then #this is a register in a memory chunk
        @TfieldMap periphRWRegisterBody [emptyMap];
        @lstring componentName;
        @lstring memoryName;
        @uint address;
        [registersInMemMap searchKey !regName ?componentName ?memoryName ?* ?address ?*];
        addLStringValue !?periphRWRegisterBody !"regName" !regName;
        addBoolValue !?periphRWRegisterBody !lstringWith[!"accessType"] !accessType; #true = read
        @string codeCpp := "";
        codeCpp .= generateImplementation[!instList !1 !"m_arch->" !"" ![@codeCtx C]];
        addStringValue !?periphRWRegisterBody !lstringWith[!"codeCpp"]  !codeCpp;
        @string storageName;
        getStorageName ![componentName string] ![memoryName string] ?storageName;
        addStringValue !?periphRWRegisterBody !lstringWith[!"storageName"]  !storageName;
        addUnsignedValue !?periphRWRegisterBody !lstringWith[!"address"]  ![address uint64];
        periphRWRegisterList += !periphRWRegisterBody;
      end if;
    end foreach;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"periphRWRegisterList"] !periphRWRegisterList;
end routine;

routine generateCodeForCyclicParts
  ?? @componentMap componentMap
  ?! @TfieldMap templateStruct
:
  @TfieldMapList periphCyclicList := [@TfieldMapList emptyList];
  @uint nbCyclic := 0;
  foreach componentMap(* * * * * * * * @cyclicPartList cyclicPartList *) do
    foreach cyclicPartList(@cExpression cycleExp @cExpression conditionExp @instructionList instList @uint id) do
      @TfieldMap periphCyclicBody [emptyMap];
      @string conditionExpCode := "";
      conditionExpCode .= [conditionExp generateCode !"" !"" ![@codeCtx C]];
      addStringValue  !?periphCyclicBody !lstringWith[!"conditionExpCode"]  !conditionExpCode;
      @string bodyCode := generateImplementation[!instList !2 !"" !"" ![@codeCtx C]];
      addStringValue  !?periphCyclicBody !lstringWith[!"bodyCode"]  !bodyCode;

      #second function: The function that returns the number of cycles.
      @string cycleExpCode := "";
      cycleExpCode .= [cycleExp generateCode !"m_arch->" !"" ![@codeCtx C]];
      addStringValue  !?periphCyclicBody !lstringWith[!"cycleExpCode"]  !cycleExpCode;
      nbCyclic := nbCyclic + 1;
      periphCyclicList += !periphCyclicBody;
    end foreach;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"periphCyclicList"] !periphCyclicList;
end routine;

routine getCodeForComponentRegister
  ?? @componentMap componentMap
  ?? @lstring reg
  !  @string codeRead
  !  @string codeWrite
:
  codeRead := "";
  codeWrite := "";
  foreach componentMap(* * * * * * * @readWriteActionList readWriteActionList ...) do
    foreach readWriteActionList (@bool accessType @lstring regName @instructionList instList) do
      if [reg string] == [regName string] then
        @string code := generateImplementation[!instList !3 !"" !"" ![@codeCtx C]];
        if accessType then codeRead .= code;
        else codeWrite .= code;
        end if;
      end if;
    end foreach;
  end foreach;
end routine;

routine generateCodeForRegistersDefinedInComponents
  ?? @varMap globalVarMap
  ?? @componentMap componentMap
  ?! @TfieldMap templateStruct
:
  #get a map that contains all the registers that have an action.
  @boolMap regMap [emptyMap];
  foreach componentMap(* * * * * * * @readWriteActionList readWriteActionList ...) do
    foreach readWriteActionList (@bool accessType @lstring regName @instructionList code) do
      if [regMap hasKey ![regName string]] then
        #This is not really a limitation :-/
        error [regName location] : "Registers defined in a component can only trigger one action on a read or write access.";
      else
        [!?regMap insertKey ! regName];
      end if;
    end foreach;
  end foreach;

  @TfieldMapList periphCompRegisterList := [@TfieldMapList emptyList];
  foreach globalVarMap (@lstring varName @abstractVar var) do
    #message "found ".[varName string]."..";
    cast var
    when >= @registerVar reg :
      if [reg regType] == [@regType componentRegister] then
        # this is a component register.
        @TfieldMap periphCompRegisterListBody [emptyMap];
        @string codeRead;
        @string codeWrite;
        getCodeForComponentRegister !componentMap !varName ?codeRead ?codeWrite;
        addLStringValue !?periphCompRegisterListBody !"name" !varName;
        addStringValue  !?periphCompRegisterListBody !lstringWith[!"codeRead"]  !codeRead;
        addStringValue  !?periphCompRegisterListBody !lstringWith[!"codeWrite"] !codeWrite;
        periphCompRegisterList += !periphCompRegisterListBody;
      end if;
    else
    end cast;    
  end foreach;
  addListValue !?templateStruct !lstringWith[!"periphCompRegisterList"] !periphCompRegisterList;
end routine;

routine peripheralsPart
  ?! @TfieldMap templateStruct
  ?? @componentMap componentMap
  ?? @varMap globalVarMap
:
  @string codeH    := "";
  @string codeCpp  := "";
  @string codeInit := "";
  generateCodeForRegistersMappedInMemory !componentMap !?templateStruct;
  if [codeInit length] > 0 then
    codeInit := "\t#ifndef GADL_NO_ACTION\n". codeInit."\t#endif\n";
  end if;

  generateCodeForCyclicParts !componentMap !?templateStruct;
  generateCodeForRegistersDefinedInComponents !globalVarMap !componentMap !?templateStruct;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
