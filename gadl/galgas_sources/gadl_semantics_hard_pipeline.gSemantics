semantics gadl_semantics_hard_pipeline:
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_hard_arch.gSemantics" ;

#----------------------------------------------------------------------------
#--- Pipeline
#----------------------------------------------------------------------------

#store the body description of a pipeline stage. Example:
# fetcher : absBranch
# SRU bypass in <Execute> : write;
abstract class @stageBody {
  @lstring device;
  @lstringlist portList;
}

abstract class @releaseOrBypass extends @stageBody {  
  @lstring inStage;
}

class @isRelease extends @releaseOrBypass {  
}

class @isBypass extends @releaseOrBypass {  
}

class @resourceAndPortAllowed extends @stageBody {
}

list @stageBodyList
{
  @stageBody stageBody;
}

#list of pipeline stages.
#This map is included in a @pipelineMap
#key is the stage name.
list @stageList
{
  @lstring stageName;
  @stageBodyList stageBodyList; #Body of the pipeline List
}

#This map stores the information of different pipelines, the key of the map
#is the name of pipeline.
#This is a sequential pipeline.
map @pipelineMap{
  @lstring architectureName;
  @stageList stageList;
  insert insertKey error message "the '%K' pipeline is already defined in %L" ; 
  search searchKey error message "the '%K' pipeline is not defined in map" ;
  remove removeKey error message "the '%K' pipeline is not defined and cannot be removed." ;
}

#return the pipeline stage just after a defined stage.
function getPipelineStageAfter
  ?? @stageList stageList
  ?? @lstring pipelineStage
  -> @lstring str
:
  str := [@lstring new !"" !here];
  @bool next := false;
  foreach stageList (@lstring stageName *) do
    if next then
      str := stageName;
      next := false;
    end if;
    if [stageName string] == [pipelineStage string] then next := true; end if;
  end foreach;
end function;

#get the pipeline stage corresponding to the device.port access
#Note: It searches ONLY the first occurence.
routine getPipelineStageForDevicePort
  ?? @pipelineMap pipelineMap
  ?? @lstring archName
  ?? @lstring deviceName
  ?? @string port
  !  @lstring pipelineName
  !  @lstring pipelineStageName
  !  @bool found
:
  pipelineStageName := [@lstring new !"" !here];
  pipelineName := [@lstring new !"" !here];
  found := false;
  foreach pipelineMap (@lstring pipeName @lstring architectureName @stageList stageList) while not found do
    if [architectureName string] == [archName string] then #based on same architecture
      foreach stageList (@lstring stageName @stageBodyList stageBodyList) while not found do
        foreach stageBodyList (@stageBody stageBody) while not found do
          if [[stageBody device] string] == [deviceName string] then
            #same device
            #now check for port.
            foreach [stageBody portList] (@lstring portName) while not found do
              if [portName string] == port then 
                found := true;
              end if;
            end foreach;
            if found then
              pipelineName := pipeName;
              cast stageBody
                when >= @releaseOrBypass rob :
                  pipelineStageName := [rob inStage];
                when == @resourceAndPortAllowed :
                  pipelineStageName := stageName;
                else
                  error here : "internal error: cast error with 'getPipelineStageForDevicePort'";
              end cast;
              #message "corresponding stage: ".[pipelineStageName string]."\n";
            end if;
          end if;
        end foreach;
      end foreach;
    end if;
  end foreach;
end routine;

#----------------------------------------------------------------------------
#--- Machine
#----------------------------------------------------------------------------

list @complexPipelineList{
  @stringlist simplePipelinesList; #stores simple pipelines that forms the complex pipeline
}

abstract class @pipelineExpression {
}
abstract method @pipelineExpression parcours ?!@string ioChaine ;
abstract method @pipelineExpression buildComplexPipelineList ?!@complexPipelineList complexPipelineList ;

class @pipelineSequence extends @pipelineExpression {
  @pipelineExpression mLeftOperand ;
  @pipelineExpression mRightOperand ;
}

override method @pipelineSequence parcours ?!@string ioChaine :
  ioChaine .= "(" ;
  [mLeftOperand parcours !? ioChaine] ;
  ioChaine .= "," ;
  [mRightOperand parcours !? ioChaine] ;
  ioChaine .= ")" ;
end method ;

override method @pipelineSequence buildComplexPipelineList ?!@complexPipelineList complexPipelineList:
  [mLeftOperand buildComplexPipelineList !?complexPipelineList];
  [mRightOperand buildComplexPipelineList !?complexPipelineList];
end method ;

class @pipelineParallel extends @pipelineExpression {
  @pipelineExpression mLeftOperand ;
  @pipelineExpression mRightOperand ;
}
override method @pipelineParallel parcours ?!@string ioChaine :
  ioChaine .= "(" ;
  [mLeftOperand parcours !? ioChaine] ;
  ioChaine .= "|" ;
  [mRightOperand parcours !? ioChaine] ;
  ioChaine .= ")" ;
end method ;

override method @pipelineParallel buildComplexPipelineList ?!@complexPipelineList complexPipelineList :
  @complexPipelineList mList := complexPipelineList ;
  [mLeftOperand  buildComplexPipelineList !?complexPipelineList] ;
  [mRightOperand buildComplexPipelineList !?mList] ;
  foreach mList (@stringlist simplePipelinesList1) do
    @bool exists := false ;
    foreach complexPipelineList (@stringlist simplePipelinesList2) while not exists do
      exists := simplePipelinesList2 == simplePipelinesList1 ;
    end foreach ;
    if not exists then
      complexPipelineList += ! simplePipelinesList1 ;
    end if ;
  end foreach ;
end method ;

class @simplePipeline extends @pipelineExpression {
  @lstring mPipelineName ;
  @lstring mPipelineAlias ;
}
override method @simplePipeline parcours ?!@string ioChaine :
  ioChaine .= [mPipelineName string] ;
  if [mPipelineAlias string] != "" then
    ioChaine .= " " . [mPipelineAlias string] ;
  end if;
end method ;

override method @simplePipeline buildComplexPipelineList ?!@complexPipelineList complexPipelineList :
  @complexPipelineList mList := complexPipelineList ;
  complexPipelineList := [@complexPipelineList emptyList] ;
  foreach mList do
    @stringlist e := simplePipelinesList ;
    e += ![mPipelineName string] ;
    complexPipelineList += !e ;
  end foreach ;   
end method ;

#To store machine and pipeline expression (the key is the name of machine).
map @machineMap{
  @pipelineExpression pipelineExpression;
  insert insertKey error message "the '%K' machine is already defined in %L" ; 
  search searchKey error message "the '%K' machine is not defined in map" ;
  remove removeKey error message "the '%K' machine is not defined and cannot be removed." ;
}

#To store machine and pipeline expression (the key is the name of machine).
map @complexPipelineMap{
  @complexPipelineList complexPipelineList; #stores simple pipelines that forms the complex pipeline for each machine
  insert insertKey error message "the '%K' complex pipeline is already defined in %L" ; 
  search searchKey error message "the '%K' complex pipeline is not defined in map" ;
  remove removeKey error message "the '%K' complex pipeline is not defined and cannot be removed." ;
}

#Visualization of machine's expression, for example: (((p1 fetch1|p1 fetch2),(p2|p3)),(p4 finish3|p4 finish4))
routine outputMachineExpression
  ?? @machineMap machineMap
  !  @complexPipelineMap complexPipelineMap
:
  complexPipelineMap := [@complexPipelineMap emptyMap];
  foreach machineMap (@lstring name @pipelineExpression pipelineExpression) do
  @complexPipelineList complexPipelineList := [@complexPipelineList listWithValue ![@stringlist emptyList]];
    @string ioChaine := "";
    [pipelineExpression parcours !?ioChaine];
#    message ioChaine . "\n";
    [pipelineExpression buildComplexPipelineList !?complexPipelineList];
    [!?complexPipelineMap insertKey !name !complexPipelineList];
#    log complexPipelineList ;
  end foreach;
#  outputComplexPipeline ?complexPipelineMap;
end routine;
                                                                 
end semantics ;
# vim:ft=ggs:ts=2:sw=2
