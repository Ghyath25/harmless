semantics gadl_semantics_pipeline_configuration :
  import "gadl_semantics_instruction_classes.gSemantics" ;
  import "gadl_semantics_register_access.gSemantics" ;
  import "gadl_isa.gSemantics" ; #instructionImplementationMap

#give instruction class for each instruction. Implemented in instruction.h
#This works even if there is no architecture (instToInstructionClassMap and icMap are empty maps).
routine giveInstructionItsClass
  ?? @instructionImplementationMap impMap #get all instructions, including those without any behavior.
  ?? @stringMap instToInstructionClassMap #inst Name is the Key. value is the inst class name.
  ?? @instructionClassMap icMap
  ?! @TfieldMap templateStruct
:
  @TfieldMapList icTplList [emptyList];
  foreach impMap (@lstring instName ...) do #get all instructions, with or without behavior.
    @TfieldMap icTplBody [emptyMap];
    @uint classID;
    if [instToInstructionClassMap hasKey ![instName string]] then #with behavior
      @string instClass;
      [instToInstructionClassMap searchKey !instName ?instClass];
      [icMap searchKey ![@lstring new !instClass !here] ?classID ?*];
    else #no behavior
      classID := 0;
    end if;
    addLStringValue  !?icTplBody !"name" !instName;
    addUnsignedValue !?icTplBody !lstringWith[!"id"] ![classID uint64];
    icTplList += !icTplBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"InstClassList"] !icTplList;
end routine;

#here is the pipeline definition for the P2A .config file.
routine pipelineDefinitionForP2A
  ?? @lstring pipelineName
  ?? @stageList stageList
  ?! @string p2aStr
:
  p2aStr .= "pipeline ".[pipelineName string]."\n";
  foreach stageList (@lstring stageName @stageBodyList stageBodyList) do
    p2aStr .= [pipelineName string]." addStage ".[stageName string]."\n";
  end foreach;
  p2aStr .= "\n";
end routine;

routine resourcesDefinitionForP2A
  ?? @lstring pipelineName
  ?? @stageList stageList
  ?? @boolMap devicePortToRemove
  ?? @architectureMap architectureMap
  ?? @lstring architectureName
  ?? @bool foundDDCStage
  ?! @boolMap resourceDefined
  ?! @string p2aStr
:
  # TODO: We have to save the order of resource declaration.
  #first resource is for the Data Dep access (implicit external resource)
  if foundDDCStage then
    p2aStr .= [pipelineName string]." addResource external DDCRes 0 priority\n";
  end if;
  # a resource is an access to device/port.
  foreach stageList (@lstring stageName @stageBodyList stageBodyList) do
    foreach stageBodyList (@stageBody stageBody) do
      foreach [stageBody portList] (@lstring portName) do
        @lstring deviceName := [stageBody device];
        @string key := [deviceName string].".".[portName string];
        if not [devicePortToRemove hasKey !key] then #not in remove list
          if not [resourceDefined hasKey !key] then #not already added
            [!?resourceDefined insertKey ![@lstring new !key !here]];
            p2aStr .= [pipelineName string]." addResource ";
            @bool isShared := isDevicePortShared[!architectureMap !architectureName !deviceName !portName];
            if isShared then
              p2aStr .= "external ";
            else
              p2aStr .= "internal 1 "; #max allowed value not taken into account yet.
            end if;
            @string resourceName := [deviceName string]."_".[portName string];
            p2aStr .= resourceName." 0 priority\n";
          end if;
        end if;
      end foreach;
    end foreach;
  end foreach;
  p2aStr .= "\n";
end routine;

#return OK, if the instruction class can go into the pipeline.
#tested OK.
function isInstructionClassGoingOnPipeline
  ?? @instructionPipelinePathList ippList
  ?? @lstring pipelineName
  ?? @instructionClass ic
  -> @bool ok
:
  ok := false;
  foreach ic (@lstring icPathName @devicePortAccessList devicePortAccessList) while not ok do
    @bool ippFound := false;
    foreach ippList (@instructionPipelinePath ipp) while not ippFound do
      @string str;
      getInstructionPipelinePathString !ipp ?str;
      if str == [icPathName string] then
        #ok, get the matching pipeline path.
        ippFound := true;
        foreach ipp (@simplePipeline pipeline) while not ok do
          ok := [[pipeline mPipelineName] string] == [pipelineName string];
        end foreach;
      end if;
    end foreach;
  end foreach;
end function;

routine getDDCResource
  ?? @lstring pipelineName
  ?? @stageList stageList
  ?? @DDCPipelineInfoList DDCPipelineInfoList #DDC related struct.
  !  @lstring DDCResourceStage
  !  @bool foundDDCStage
:
  #get the stage associated to the DDC (external resource).
  DDCResourceStage := [@lstring new !"" !here];
  foundDDCStage := false;
  foreach DDCPipelineInfoList (* @lstring pipelineReadName @lstring pipelineStageReadName * *) do
    if [pipelineReadName string] == [pipelineName string] then #ok, good pipeline.
      DDCResourceStage := getPipelineStageAfter[!stageList !pipelineStageReadName];
      foundDDCStage := true;
    end if;
  end foreach;

end routine;

routine instructionClassDefinitionForP2A
  ?? @lstring architectureName
  ?? @architectureMap architectureMap
  ?? @instructionClassMap icMap
  ?? @lstring pipelineName
  ?? @stageList stageList
  ?? @boolMap resourceDefined
  ?? @instructionPipelinePathList ippList
  ?? @lstring DDCResourceStage
  ?? @bool foundDDCStage
  ?! @string p2aStr
:
  #then compute other resources
  foreach icMap (@lstring icName @uint id @instructionClass ic) do
    #is the instruction mapping on the current pipeline.
    if isInstructionClassGoingOnPipeline[!ippList !pipelineName !ic] then
      #yes
      @string className := "ic_".[id string];
      p2aStr .= [pipelineName string]." addInstructionClass ".className."\n";
      # add the implicit external resource dedicated to DDC:
      if foundDDCStage then 
        p2aStr .= className." dependResource 1 DDCRes ".[DDCResourceStage string]."\n";
      end if;
      foreach ic (@lstring icPathName @devicePortAccessList devicePortAccessList) do
        foreach devicePortAccessList (@string device @string port *) do
          setResourceAccessInInstClass !architectureName !architectureMap !className !device !port !stageList !resourceDefined !?p2aStr;
        end foreach;
      end foreach;
      p2aStr .= "\n";
    end if;
  end foreach;
end routine;

map @p2aNotificationMap {
  @uint id;      #from 0 to ...
  @bool enter;   #enter or exits
  @string stage; #name of related stage
  @string instClass; #if "" -> all instructions.
  insert insertKey error message "the '%K' in @p2aNotificationMap is already defined in %L" ; 
  search searchKey error message "the '%K' in @p2aNotificationMap is not defined" ;
}

#This structure is used only to generate the .config file
#and respect the order of notification 'id's
#Use the Map instead: @p2aNotificationMap
sortedlist @p2aNotificationSortedList {
  @lstring key;
  @uint id;      #from 0 to ...
  @bool enter;   #enter or exits
  @string stage; #name of related stage
  @string instClass; #if "" -> all instructions.
}{
  id <
}
#return the name (<=> key in NotificationMap), based on data
function getNotificationName
  ?? @bool enter       #enter or exits
  ?? @string stage     #name of related stage
  ?? @string instClass #if "" -> all instructions.
  -> @string name
:
  if enter then name := "enter"; else name := "exits"; end if;
  name .= "_".stage;
  if instClass != "" then
    name .= "_for_".instClass;
  end if;
end function;

#add and take care of redundant notifications.
routine addNotification
  ?? @bool enter       #enter or exits
  ?? @string stage     #name of related stage
  ?? @string instClass #if "" -> all instructions.
  ?! @p2aNotificationMap p2aNotificationMap
:
  @string name := getNotificationName[!enter !stage !instClass];
  if not [p2aNotificationMap hasKey !name] then
    #notification was not already defined
    [!?p2aNotificationMap insertKey ![@lstring new !name !here] 
                                    ![p2aNotificationMap count] !enter !stage !instClass];
  end if;
end routine;

routine initNotificationMap 
  ?? @stageList stageList
  ?! @p2aNotificationMap p2aNotificationMap
:
  #notification for each stages for debugging (pipeline trace)
  #this should be done first because they need to be consecutive.
  if [option gadl_options.pipelineDebug value] then
    foreach stageList (@lstring stageName @stageBodyList stageBodyList) do
      addNotification !true ![stageName string] !"" !?p2aNotificationMap;
    end foreach;
  end if;
  #fetch in the First Stage: mandatory for simulation.
  @lstring firstStageName;
  [stageList first ?firstStageName ?*]; 
  addNotification !true ![firstStageName string] !"" !?p2aNotificationMap;
  #exits of last stage: mandatory to get the real nb of instructions executed.
  @lstring lastStageName;
  [stageList last ?lastStageName ?*]; 
  addNotification !false ![lastStageName string] !"" !?p2aNotificationMap;
end routine;

function searchPipelineStageForDevice
  ?? @stageList stageList
  ?? @lstring deviceSrc
  ?? @lstring portSrc
  -> @string pipelineStage
:
  @bool found := false;
  pipelineStage := "error";
  foreach stageList (@lstring stageName @stageBodyList stageBodyList) while not found do
    foreach stageBodyList (@stageBody stageBody) while not found do
      if [[stageBody device] string] == [deviceSrc string] then
        foreach [stageBody portList] (@lstring portName) while not found do
          if [portSrc string] == [portName string] then
            #matching.
            found := true;
            pipelineStage := [stageName string];
          end if;
        end foreach;
      end if;
    end foreach;
  end foreach;
  if not found then
    @string msg := "The port ".[deviceSrc string].".".[portSrc string]." cannot be found on pipeline ";
    error here: msg;
  end if;
end function;

#notifications related to 'shared port' signals
routine addSharedPortNotifications
  ?? @stageList stageList
  ?! @p2aNotificationMap p2aNotificationMap
  ?? @architectureMap architectureMap
  ?? @lstring architectureName
:
  #message "add addSharedPortNotifications\n";
  @signalConnectPart signalConnectPart;
  [architectureMap searchKey !architectureName ?* ?signalConnectPart];
  foreach [signalConnectPart sharedPortActivationList] (@lstring deviceSrc @lstring portSrc ...) do
    @string pipelineStage := searchPipelineStageForDevice[!stageList !deviceSrc !portSrc];
    #message "add notif for ".pipelineStage."\n";
    addNotification !true !pipelineStage !"" !?p2aNotificationMap;
  end foreach;
end routine;

#add notifications related to DDC and generate keys for arch.cpp.
routine DDCNotifications
  ?? @lstring pipelineName
  ?? @DDCPipelineInfoList DDCPipelineInfoList #DDC related struct.
  ?? @lstring DDCResourceStage
  ?! @p2aNotificationMap p2aNotificationMap
  ?! @TfieldMap templateStruct
:
  #We need 3 notifications:
  @bool first := true; #TODO: we handle only the first struct in DDCPipelineInfoList
  foreach DDCPipelineInfoList (* @lstring pipelineReadName @lstring pipelineStageReadName @lstring pipelineWriteName @lstring pipelineStageWriteName) do
    if first then
      if [pipelineReadName string] == [pipelineName string] then #ok, good pipeline.
        # * in the read stage : require
        addNotification !true ![pipelineStageReadName string] !"" !?p2aNotificationMap;
        addLStringValue !?templateStruct !"DDC_READ_STAGE_PIPELINE" !pipelineName;
        addStringValue !?templateStruct !lstringWith[!"DDC_READ_STAGE"] ![[pipelineStageReadName string] uppercaseString];
        # * in the stage just after : lock <=> DDCResourceStage
        addNotification !true ![DDCResourceStage string] !"" !?p2aNotificationMap;
        addLStringValue !?templateStruct !"DDC_LOCK_STAGE_PIPELINE" !pipelineName;
        addStringValue !?templateStruct !lstringWith[!"DDC_LOCK_STAGE"] ![[DDCResourceStage string] uppercaseString];
      end if;
      if [pipelineWriteName string] == [pipelineName string] then #ok, good pipeline.
        # * in the unlock stage
        addNotification !true ![pipelineStageWriteName string] !"" !?p2aNotificationMap;
        addLStringValue !?templateStruct !"DDC_UNLOCK_STAGE_PIPELINE" !pipelineName;
        addStringValue !?templateStruct !lstringWith[!"DDC_UNLOCK_STAGE"] ![[pipelineStageWriteName string] uppercaseString];
      end if;
    end if;
    first := false;
  end foreach;
end routine;

#translates @p2aNotificationMap to p2a dialect.
routine notificationDefinitionForP2A
  ?? @p2aNotificationMap p2aNotificationMap
  ?! @string p2aStr
:
  @p2aNotificationSortedList p2aNSL [emptySortedList];
  foreach p2aNotificationMap (@lstring key @uint id @bool enter @string stage @string instClass) do
    p2aNSL += !key !id !enter !stage !instClass;
  end foreach;
  
  foreach p2aNSL (@lstring key * @bool enter @string stage @string instClass) do
    p2aStr .= "add notification ".[key string]." when instruction ";
    if instClass != "" then
      p2aStr .= instClass." ";
    end if;
    if enter then p2aStr .= "enters in"; else p2aStr .= "exits"; end if;
    p2aStr .= " stage ".stage."\n";
  end foreach;
  p2aStr .= "\n";
end routine;

routine generateP2AFiles
  ?? @lstring exportDir
  ?? @lstring coreName
  ?? @pipelineMap pipelineMap
  ?? @instructionClassMap icMap
  ?? @architectureMap architectureMap
  ?? @instructionPipelinePathList ippList
  ?? @boolMap devicePortToRemove
  ?? @DDCPipelineInfoList DDCPipelineInfoList #DDC related struct.
  ?! @TfieldMap templateStruct
:
  @boolMap resourceDefined [emptyMap]; #to be sure that a resource is defined only once.
  @stringlist a2aFiles [emptyList];
  foreach pipelineMap (@lstring pipelineName @lstring architectureName @stageList stageList) do
    @lstring DDCResourceStage;
    @bool foundDDCStage;
    getDDCResource !pipelineName !stageList !DDCPipelineInfoList ?DDCResourceStage ?foundDDCStage;

    @string p2aStr := "version 8\n";
    p2aStr .= "model ".[coreName string]."\n\n";
    #define pipeline (with stages)
    pipelineDefinitionForP2A !pipelineName !stageList !?p2aStr;
    #define resources.
    resourcesDefinitionForP2A !pipelineName !stageList !devicePortToRemove !architectureMap !architectureName !foundDDCStage !?resourceDefined !?p2aStr;
    #declare instruction classes.
    instructionClassDefinitionForP2A !architectureName !architectureMap !icMap !pipelineName !stageList !resourceDefined !ippList !DDCResourceStage !foundDDCStage !?p2aStr;
    #declare notifications.
    @p2aNotificationMap p2aNotificationMap [emptyMap];
    initNotificationMap !stageList !?p2aNotificationMap;
    addSharedPortNotifications !stageList !?p2aNotificationMap !architectureMap !architectureName;
    DDCNotifications !pipelineName !DDCPipelineInfoList !DDCResourceStage !?p2aNotificationMap !?templateStruct;
    notificationDefinitionForP2A !p2aNotificationMap !?p2aStr;
    
    createFile ![exportDir string] ![pipelineName string].".config" !p2aStr;
    a2aFiles += ![pipelineName string];
  end foreach;
  updateMakefileForPipelines !pipelineMap !?templateStruct;
end routine;

routine updateMakefileForPipelines
  ?? @pipelineMap pipelineMap
  ?! @TfieldMap templateStruct
:
  @string a2aFileStr := "";
  @string a2cppDepFiles := "";
  @string a2aFileImplementationStr := "";
  @string a2cppFileHeaderStr := "";
  foreach pipelineMap (@lstring pipelineName ...) do
    @string fileName := [pipelineName string];
    a2aFileStr .= fileName.".a2a";
    a2aFileImplementationStr .= fileName.".cpp ".fileName."-1.cpp";
    a2cppFileHeaderStr .= fileName.".h";
    a2cppDepFiles .= fileName.".h : ".fileName.".cpp\n";
    a2cppDepFiles .= fileName."-1.cpp : ".fileName.".cpp\n";
    a2cppDepFiles .= fileName.".cpp : ".fileName.".a2a\n";
    a2cppDepFiles .= "\t$(A2CPP) $<\n";
  between
    a2aFileStr .= " ";
    a2aFileImplementationStr .= " ";
    a2cppFileHeaderStr .= " ";
    a2cppDepFiles .= "\n";
  end foreach;
  addStringValue !?templateStruct !lstringWith[!"A2AFILES"] !a2aFileStr;
  addStringValue !?templateStruct !lstringWith[!"A2CPP_GENERATED"] !a2aFileImplementationStr;
  addStringValue !?templateStruct !lstringWith[!"A2CPP_GENERATED_HEADER"] !a2cppFileHeaderStr;
  addStringValue !?templateStruct !lstringWith[!"A2CPP_RULES"] !a2cppDepFiles;
end routine;

routine setResourceAccessInInstClass
  ?? @lstring architectureName
  ?? @architectureMap architectureMap
  ?? @string className
  ?? @string device 
  ?? @string port
  ?? @stageList stageList
  ?? @boolMap resourceDefined
  ?! @string p2aStr
:
  foreach stageList (@lstring stageName @stageBodyList stageBodyList) do
    foreach stageBodyList (@stageBody stageBody) do
      foreach [stageBody portList] (@lstring portName) do
        @lstring deviceName := [stageBody device];
        @string key := [deviceName string].".".[portName string];
        if [resourceDefined hasKey !key] then #there is a resource.
          if ([deviceName string] == device ) & ([portName string] == port) then      
            #got one \o/
            #'depend' is either for internal or external resources.
            @string resourceName := [deviceName string]."_".[portName string];
            p2aStr .= className." dependResource 1 ".resourceName." ".stageName."\n";
            #'get' and release are only for internal resources
            @bool isShared := isDevicePortShared[!architectureMap !architectureName !deviceName !portName];
            if not isShared then
              p2aStr .= className." getResource 1 ".resourceName." ".stageName."\n";
              cast stageBody
                when == @isRelease isRelease :
                  p2aStr .= className." releaseResource 1 ".resourceName." ".[[isRelease inStage] string]."\n";
                else
                  p2aStr .= className." releaseResource 1 ".resourceName." ".stageName."\n";
              end cast;
            end if;
          end if;
        end if;
      end foreach;
    end foreach;
  end foreach;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
