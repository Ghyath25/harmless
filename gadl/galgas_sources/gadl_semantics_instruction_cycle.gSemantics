semantics gadl_semantics_instruction_cycle :
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
  import "gadl_semantics_implementation.gSemantics" ;
  import "gadl_semantics_memory.gSemantics" ; #for updateTemplateForProgramCounter routine
  import "gadl_semantics_default.gSemantics";
  import "gadl_semantics_format.gSemantics" ; #impMap
  import "gadl_semantics_behavior_data_structures.gSemantics" ; #behaviorChunkList..

#We can find into a instCycle part:
# -> refs
# -> do blocs.
# -> another instCycle call.
#    select blocs... but it is another instCycle call.

abstract class @instCycleChunk
{
}

list @instCycleChunkList {
  @instCycleChunk chunk;
}

class @instCycleImplementation extends @instCycleChunk #'do' bloc.
{
  @instructionList instList;
}

class @instCycleMethodOrRegAccess extends @instCycleChunk #access to a component or a reg -> virtual
{
  @instructionList instList;
}

class @instCycleMethodAccess extends @instCycleMethodOrRegAccess
{
  @lstring componentName;
  @lstring methodName;
}

class @instCycleRegAccess extends @instCycleMethodOrRegAccess
{
  @bool read; #1 -> read, 0-> write.
  @lstring regName;
}

class @idfInstCycle extends @instCycleChunk #another instCycle call. replace idfOrRefInstCycle
{
  @lstring name;
  @lstring postRefName; #string to add in the called instCycle. (suffix)
}

class @refInstCycle extends @instCycleChunk 
{
  @lstring name;
}

list @instCycleChunkListWithSuffix {
  @instCycleChunk chunk;
  @stringlist suffixList;  
}

list @instCycleChunkListWithSuffixList {
  @instCycleChunkListWithSuffix chunkList;
}

########### data storage ##############
#What is contained into a instCycle (agg or alt).

abstract class @instCycleBody {
  @instCycleChunkList chunkList;
}

class @aggInstCycle extends @instCycleBody { #normal instCycle
}

class @altInstCycle extends @instCycleBody { #select construction.
}

map @instCycleMap {
  @instCycleBody instCycleBody;
  insert insertKey error message "the '%K' instCycle is already defined in %L" ; 
  search searchKey error message "the '%K' instCycle is not defined in map" ;
  remove removeKey error message "the '%K' instCycle is not defined and cannot be removed." ;
}


###################################################################################################
### Tree generation related routines.
###################################################################################################

# there may have multiple roots in the instCycle trees. The may root is implicitely declared as being an alternative of
# the roots of the sub-trees.
routine detectRootInstCycles
  ?? @instCycleMap instCycleMap
  !  @instCycleMap rootInstCycleMap
:
  #a root instCycle is a instCycle that is never called by another one.
  rootInstCycleMap := instCycleMap;

  foreach instCycleMap (@lstring instCycleName @instCycleBody instCycleBody) do
    @instCycleChunkList chunkList := [instCycleBody chunkList];
    foreach chunkList (@instCycleChunk chunk) do
      cast chunk
      when == @idfInstCycle chunkIsIdf :
        #ok. This instCycle call another instCycle (instCycleCallName). Consequently, instCycleCallName 
        #is not a root. Remove it from rootInstCycleMap (if it has not been removed before.)
        if [rootInstCycleMap hasKey ![[chunkIsIdf name] string]] then
          [!?rootInstCycleMap removeKey ![chunkIsIdf name] ?*];
        end if;
      else
      end cast;
    end foreach;
  end foreach;
end routine;

##recursive routine.
routine constructInstCycleInstructionTreeRec
  ?? @instCycleMap                     instCycleMap             #instCycle map -> constant
  ?? @instCycleChunkListWithSuffix     instCycleListToCompute   #instCycles not yet taken into account
  ?? @instCycleChunkListWithSuffix     instructionInstCycleList #current instCycle list
  ?! @instCycleChunkListWithSuffixList instructionList       #output list of instCycle list.
:

  if [instCycleListToCompute length] > 0 then
    #something to do..
    @instCycleChunkListWithSuffix newInstCycleListToCompute := instCycleListToCompute;
    @instCycleChunk currentInstCycle;
    @stringlist currentSuffixList;
    [!?newInstCycleListToCompute popFirst ?currentInstCycle ?currentSuffixList];
    @instCycleChunkListWithSuffix newInstructionInstCycleList := instructionInstCycleList;

    #update suffix.
    cast currentInstCycle
    when == @idfInstCycle currentInstCycleIsIdf :
      #get suffix.
      @string suffixStr := [[currentInstCycleIsIdf postRefName] string];
      if [suffixStr length] > 0 then
        currentSuffixList += !suffixStr;
      end if;
    else
    end cast;

    newInstructionInstCycleList += !currentInstCycle !currentSuffixList;

    cast currentInstCycle
    when == @idfInstCycle currentInstCycleIsIdf :
      #idf -> other instCycle (alternative or aggregate)
      @instCycleBody instCycleBody;
      #check that the instCycle is declared for agg and alt.
      [instCycleMap searchKey ![currentInstCycleIsIdf name] ?instCycleBody];
      cast instCycleBody
      when == @aggInstCycle :
        #########    aggregate instCycle    ########## 
        @instCycleChunkList chunkInBodyList := [instCycleBody chunkList];
        @instCycleChunkListWithSuffix instCycleListToComputeUpdated [emptyList];
        foreach chunkInBodyList (@instCycleChunk chunk) do
          instCycleListToComputeUpdated += !chunk !currentSuffixList;
        end foreach;
        instCycleListToComputeUpdated := instCycleListToComputeUpdated . newInstCycleListToCompute;
        #newInstCycleListToCompute := [instCycleBody chunkList] . newInstCycleListToCompute;
        constructInstCycleInstructionTreeRec !instCycleMap !instCycleListToComputeUpdated !newInstructionInstCycleList !?instructionList;
      when == @altInstCycle :
        ##########    alternative instCycle    ##########
        @instCycleChunkList chunkList := [instCycleBody chunkList];
        @uint currentCallToFind := 0;
        loop [chunkList length]:
        while currentCallToFind < [chunkList length] do
          @bool callFound := false;
          @instCycleChunkListWithSuffix tempList [emptyList];
          @uint currentChunkId := 0;
          foreach chunkList (@instCycleChunk chunk) do
            cast chunk
#            when == @refInstCycle :
#              #if currentChunkId == currentCallToFind then break; end if;
#              tempList += !chunk !currentSuffixList;
#            when == @instCycleImplementation :
#              #if currentChunkId == currentCallToFind then break; end if;
#              tempList += !chunk !currentSuffixList;
            when == @idfInstCycle :
              if currentChunkId == currentCallToFind then
                tempList += !chunk !currentSuffixList;
                callFound := true;
              end if;
            else #this is not an idf
              error here: "internal error: instCycle chunk type not allowed here!";
            end cast;
            currentChunkId := currentChunkId + 1;
          end foreach;
          if callFound then
            @instCycleChunkListWithSuffix newInstCycleListToComputeCopy := tempList . newInstCycleListToCompute ;
            constructInstCycleInstructionTreeRec !instCycleMap !newInstCycleListToComputeCopy !newInstructionInstCycleList !?instructionList;
          end if;
          currentCallToFind := currentCallToFind + 1;
        end loop;
      else error here : "internal error: neither aggregate nor alternative instCycle ?!";
      end cast;
    else 
      ##########    reference or implementation chunk ##########    
      constructInstCycleInstructionTreeRec !instCycleMap !newInstCycleListToCompute !newInstructionInstCycleList !?instructionList;
    end cast;
  else #no more chunks in the list. This is a leaf.
    instructionList += !instructionInstCycleList;
  end if;
end routine;

routine constructInstCycleInstructionTree
  ?? @instCycleMap instCycleMap
  !  @instCycleChunkListWithSuffixList decodedInstructionList 
:
  if [option .verbose_output value] then
    message "contructing instCycle tree...";
  end if;

  decodedInstructionList := [@instCycleChunkListWithSuffixList emptyList];
  @instCycleChunkListWithSuffix instCycleList [emptyList];
  @uint nbInstructionAccumulated := 0;

  #get root instCycles. (may have many sub-trees).
  @instCycleMap rootInstCycleMap;
  detectRootInstCycles !instCycleMap ?rootInstCycleMap;

  foreach rootInstCycleMap (@lstring rootInstCycleName *) do
    if [option .verbose_output value] then
      message "\n\tfrom root ".[rootInstCycleName string]."...";
    end if;
    @lstring emptyLString := [@lstring new !"" !here];
    @idfInstCycle startInstCycle := [@idfInstCycle new !rootInstCycleName !emptyLString];
    @instCycleChunkListWithSuffix instCycleListToCompute [emptyList];
    @stringlist emptyStringList [emptyList];
    instCycleListToCompute += !startInstCycle !emptyStringList;
    constructInstCycleInstructionTreeRec !instCycleMap !instCycleListToCompute !instCycleList !?decodedInstructionList;
    if [option .verbose_output value] then
      @uint temp := [decodedInstructionList length] - nbInstructionAccumulated;
      message [temp string]." instruction";
      if temp > 1 then message "s."; else message "."; end if;
      nbInstructionAccumulated := [decodedInstructionList length];
    end if;
  end foreach;
  if [option .verbose_output value] then
    message "\nFound a total of ".[[decodedInstructionList length] string]." instructions instCycles.\n";
  end if;
#  foreach decodedInstructionList(@instCycleChunkListWithSuffix chunkList) do
#    message "instruction:";
#    foreach chunkList (
#  end foreach;
end routine;


routine getSubInstructionIdList
  ?? @instCycleChunkListWithSuffixList decodedInstCycleInstructionList
  !  @stringSetList subInstructionIdList
:
  subInstructionIdList := [@stringSetList emptyList];
  foreach decodedInstCycleInstructionList (@instCycleChunkListWithSuffix chunkList) do
    @stringset subInstructionId [emptySet];
    foreach chunkList (@instCycleChunk chunk @stringlist suffixList) do
      @string suffixInternal;
      getSuffixString !suffixList ?* ?suffixInternal;
      cast chunk
      when == @refInstCycle chunkRef :
        subInstructionId += ![[chunkRef name] string].suffixInternal;
      else
      end cast;
    end foreach;
    subInstructionIdList += ! subInstructionId;
  end foreach;
#  #debug
#  foreach subInstructionIdList(@stringset subInstId) do
#    @string iName;
#    getInstructionName !subInstId !"" ?iName;
#    message "--> ".iName." (size = ".[[subInstId count] string].")\n";
#  end foreach;
end routine;

routine getRefSequence
  ?? @stringset refSeq
  ?! @string msg
:
  foreach refSeq (@string idPart) do
    msg .= "#".idPart." ";
  end foreach;
end routine;

#This function find for each instruction which is the appropriate
# sub instruction list.
# The refs in a subinstruction must be included in the set of the instruction ref.
# When there are more than one possiblities, the one that have the max number of refs
# is prefered (i.e. This should be the more precise).
# example: The instruction: #load #x #offset5 can match:
#          -> (null) subset (default one).
#          -> #load subset
#          -> #load #offset -> This one will be chosen, as it is more precise.
#If there is an ambiguity, an error is generated. Example with the same previous 
#instruction and the possibilities:
#          -> (null) subset (default one).
#          -> #load subset
#          -> #offset subset
#If no possibility is found, an error is generated.
routine getFunctionIDForInstructions
  ?? @instructionImplementationMap impMap
  ?? @stringSetList subInstructionIdList
  !  @uintlist idToMap
:
  idToMap := [@uintlist emptyList];
  foreach impMap (@lstring name * * * @stringset instructionID ...) do
    @uint id := 0;
    @uint currentId := 0;
    #get the corresponding instCycle instruction..
    @uint maxMatch := 0;
    @bool found := false;
    foreach subInstructionIdList (@stringset subInstructionID) do
      @stringset conjunction := instructionID | subInstructionID;
      if conjunction == instructionID then #ok, it matches
        @uint size := [subInstructionID count];
        if found & (maxMatch == size) then #ambiguity
          @string msg := "there is an ambiguity in instCycle analysis".
                         " of instruction with sequence: ";
          getRefSequence ! instructionID !?msg;
          msg .= ".\nIt matches with:\n\t->";
          getRefSequence ! subInstructionID !?msg;
          msg .= "\n\t->";
          @stringset previousSubInstructionID := [subInstructionIdList stringSetAtIndex !currentId];
          getRefSequence ! previousSubInstructionID !?msg;
          error here: msg;
        end if;
        if size >= maxMatch then 
          maxMatch := size;
          currentId := id;
        end if;
        found := true;
      end if;
      id := id+1;
    end foreach;
    if not found then
      error here: "no instCycle definition is matching for instruction ".[name string];
    end if;
    idToMap += !currentId;
  end foreach;
#  foreach impMap (@lstring name ...),
#          idToMap (@uint id) do
#    message "instruction ".[name string]." -> ".[id string]."\n";
#  end foreach;
end routine;

##########################################################################################
# InstCycle code generation.
##########################################################################################

routine generateCodeForMethodOrRegAccess
  ?! @boolMap methodUsedInPreInstCycle
  ?? @string counter
  ?? @instructionList instList
  ?! @string codePre
  ?! @string codePost
:
      #pre axec code.
      if not [methodUsedInPreInstCycle hasKey !counter] then
        [!?methodUsedInPreInstCycle insertKey ![@lstring new !counter !here]];
        codePre .= "\tconst unsigned int ".counter."_temp = _arch->get_".counter."();\n";
      end if;
      #post exec code.
      codePost .= "\tfor (unsigned int __i = ".counter."_temp; __i < _arch->get_".counter."();__i++) {\n";
      codePost .= generateImplementation[!instList !2  !"" !"" ![@codeCtx C]];
      codePost .= "\t}\n";
end routine;

routine generateCodeForOneInstruction
  ?? @instCycleChunkListWithSuffix instCycleChunkList
  !  @string codePre
  !  @string codePost
:
  codePre := "";
  codePost := "";
  @boolMap methodUsedInPreInstCycle [emptyMap];
  foreach instCycleChunkList (@instCycleChunk chunk ...) do
    cast chunk
    when == @instCycleImplementation chunkImplementation :
      @instructionList instList := [chunkImplementation instList];
      codePost .= generateImplementation[!instList !1  !"" !"" ![@codeCtx C]];
    when == @instCycleMethodAccess instCycleMethodAccess :
      @string counter := "counter_".[[instCycleMethodAccess componentName] string]."_".[[instCycleMethodAccess methodName] string];
      @instructionList instList := [instCycleMethodAccess instList];
      generateCodeForMethodOrRegAccess !?methodUsedInPreInstCycle !counter !instList !?codePre !?codePost;
    when == @instCycleRegAccess instCycleRegAccess :
      @string counter := "counter_";
      if [instCycleRegAccess read] then counter .= "read_";
      else counter .= "write_";
      end if;
      counter .= [[instCycleRegAccess regName] string];
      @instructionList instList := [instCycleRegAccess instList];
      generateCodeForMethodOrRegAccess !?methodUsedInPreInstCycle !counter !instList !?codePre !?codePost;
    else
    end cast;
  end foreach;
end routine;

routine generateInstCycleCode
  ?? @decodedInstBehaviorMap decodedInstBehaviorMap
  ?? @uintlist idToMap
  ?? @instCycleChunkListWithSuffixList decodedInstCycleInstructionList
  ?? @instructionImplementationMap impMap #instruction name.
  ?! @TfieldMap templateStruct
:
  @TfieldMapList instCycleTpl [emptyList];
  @string archName := "_arch";
  foreach idToMap (@uint id),
          impMap (@lstring instName ...) do
    @TfieldMap instCycleTplBody [emptyMap];
    if [decodedInstBehaviorMap hasKey ![instName string]] then
      @behaviorChunkListWithSuffix chunkList;
      [decodedInstBehaviorMap searchKey !instName ?chunkList ?*];
      @instCycleChunkListWithSuffix instCycleChunkList := [decodedInstCycleInstructionList chunkListAtIndex !id];

      @string codePre;
      @string codePost;
      generateCodeForOneInstruction !instCycleChunkList ?codePre ?codePost;
      
      addLStringValue !?instCycleTplBody !"name" !instName;
      addStringValue !?instCycleTplBody !lstringWith[!"preInstCycle"] !codePre;
      addStringValue !?instCycleTplBody !lstringWith[!"postInstCycle"] !codePost;
      instCycleTpl += !instCycleTplBody;
    end if;
  end foreach;
  addListValue   !?templateStruct !lstringWith[!"instCycleInstList"] !instCycleTpl;
end routine;

routine instCyclePart
  ?? @decodedInstBehaviorMap decodedInstBehaviorMap
  ?? @instructionImplementationMap impMap
  ?? @instCycleMap instCycleMap
  ?! @TfieldMap templateStruct
:
  if [instCycleMap count] != 0 & not [option gadl_options.noInstCycle value] then
    addBoolValue !?templateStruct !lstringWith[!"useCounters"] !true; #we are using counters here.
    @instCycleChunkListWithSuffixList decodedInstCycleInstructionList;
    constructInstCycleInstructionTree !instCycleMap ?decodedInstCycleInstructionList;
    @stringSetList subInstructionIdList ;
    getSubInstructionIdList !decodedInstCycleInstructionList ?subInstructionIdList;
    @uintlist idToMap;
    getFunctionIDForInstructions !impMap ! subInstructionIdList ? idToMap;
    generateInstCycleCode !decodedInstBehaviorMap !idToMap !decodedInstCycleInstructionList ! impMap !?templateStruct;
  end if;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
