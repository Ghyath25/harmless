semantics gadl_semantics_format :
  import "gadl_options.gOption" ;
  import "gadl_semantics.gSemantics" ;
#  import "gadl_semantics_implementation.gSemantics" ;
#  import "gadl_semantics_memory.gSemantics" ; #for updateTemplateForProgramCounter routine
  import "gadl_expression_functions.gSemantics";# nbBitsToCodeUnsigned
  import "gadl_semantics_default.gSemantics";
  import "gadl_types.gSemantics" ; #@varBaseType
  import "gadl_templates.gSemantics";

list @formatFieldList {
  @uint64 from;
  @uint64 to;
  @location loc;
}

list @sliceList {
  @formatFieldList field;
  @sint      fetchPart; #used for instruction codes of different sizes: relative value, 0 is the current slice, -1 is previous slice, 1 is next slice, ...
}

#ne pas mettre d'instruction, mais un truc qui n'a que les infos qu'il faut:
# * le nom.
# * le field
# * le type final.
# * le type de shift
# * la valeur du shift.
#puis on fera une routine qui fait une instruction cAssign a partir de ca

list @assignSliceList {
  @lstring name;
  @sliceList slice;
  @varBaseType type;
  @uint shiftType; #0 <=> nothing, 1 <=> left shift, 2 <=> right shift, 
  @luint shiftVal;
}


########## Format "is" (left part) #############

abstract class @idfOrRefFormat
{
  @lstring name;
}

class @idfOrRefFormatIsIdf extends @idfOrRefFormat
{
  @lstring postRefName; #string to add in the called format. (suffix)
}

class @idfOrRefFormatIsRef extends @idfOrRefFormat
{
}

########## Format "is" (whole part) #############
list @alternativeIsList
{
  @idfOrRefFormat right;
  @binaryset      left;
}

########## other format call #############

list @idfOrRefFormatList
{
  @idfOrRefFormat format;
}

########## Format #############
#format name is in the map.
#base class for both alternative and aggregate formats.
abstract class @format {
  @sliceList sliceProtoTypeList;
  @assignSliceList asList;
  @idfOrRefFormatList refList; #a format can be associated to references (>=0) .
}

class @aggFormat extends @format
{
  @idfOrRefFormatList formatCallList;
}

class @altFormat extends @format
{
  @alternativeIsList isList;
  #this value is needed to compute the offset for binary sets for instruction codes.
  #see getBinaryFormat routine.
  @uint nbSlicesBeforePlus; 
}

map @formatMap
{
  @format format;
  insert insertKey error message "the '%K' format is already defined in %L" ; 
  search searchKey error message "the '%K' format is not defined" ;
  remove removeKey error message "the '%K' format is not defined and cannot be removed." ;
}

list @binaryCodeList
{
  @binaryset code;
}

########### data for graph generation.

# format name is sufficent to find the format structure, through the formatMap.
list @formatList {
  @idfOrRefFormat name; #may be either an idf or a ref.
}

#the suffix is used when calling a format: ext@src (suffixe is src). The suffix
#is added to references (#ref) and fields.
#Suffix is a list as many suffix can be added (A suffix in applied in the whole branch)
list @formatListWithSuffix {
  @idfOrRefFormat name; #may be either an idf or a ref.
  @stringlist suffixList;
}

#TODO: ajouter le suffixe pour chaque instruction (dans formatList).
list @formatListWithSuffixList {
  @formatListWithSuffix fslist;
#  @stringset instructionId; #id of the instruction.
}

list @instructionCodeOffset {
  @uint offset;
}

list @variableInstructionCodeList {
  @instructionCodeOffset offsetList;
  @uint codeLength;
}

# this structure store all the fields that can be used in behavior and syntax.
# It gets information about name and size.
# This informat is extracted from @assignSliceList and stored in @instructionImplementationMap

#structure that saves all the information about an instruction (format related).
map @instructionImplementationMap
{
  @binaryset code;
  @formatListWithSuffix flist;
  @lstringlist instructionSeq; # including alternative/aggregate (refs include '#')
  @stringset instructionID;   # instruction id: exclude the '#' in references 
  @instructionCodeOffset offsetList;
  #nb of chunks of the instruction. The real instruction length is codeLength*instructionSize bits.
  @uint codeLength;
  @varBaseTypeMap instructionFieldMap;

  insert insertKey error message "the '%K' instruction has the same signature (same references sequence) than another one." ; 
  search searchKey error message "the '%K' instruction is not defined" ;
}

list @conditionDataList
{
  @lstring name;
  @binaryset code;
  @uint codeLength;
}

list @stringSetList
{
  @stringset stringSet;
}

list @lstringListList
{
  @lstringlist lstringList;
}

function getInstructionName
  ?? @stringset instructionId
  ?? @string modelName
  -> @string instName
:
  instName := modelName;
  foreach instructionId (@string idPart) do
    instName .= "_" . idPart;
  end foreach;
end function;

######
# routine used for logs and debug (error code).
######
routine printInstSequence 
  ?? @lstringlist seq 
  ?! @string file
:
  @bool first := true;
  foreach seq (@lstring elt) do
    if not first then file .= " -> "; end if;
    file .= [elt string];
    first := false;
  end foreach;
end routine;


############################################################################
##  Routines to generate instruction names and group instruction data
##  into a big map.
############################################################################

#get suffix string both for logs and internal use.
routine getSuffixString
  ?? @stringlist suffixList
  !  @string suffixLog      #used for logs and debug
  !  @string suffixInternal #internal used (as key in maps).
:
  suffixLog := "";
  suffixInternal := "";
  @bool start := true;
  foreach suffixList (@string str) do
    if not start then suffixLog .= ", "; end if;
    start := false;
    suffixLog .= "@".str;
    suffixInternal .= str;
  end foreach;
  if not start then #at least one
    suffixLog := "(".suffixLog.")";
  end if;
end routine;

#get instruction sequence:
#instructionSeqList must only be used for debug, logs and error messages.
#referenceSeqList is the instruction id.
routine getInstructionSequences
  ?? @formatListWithSuffixList instructionList 
  !  @lstringListList instructionSeqList
  !  @stringSetList  referenceSeqList
:
  instructionSeqList := [@lstringListList emptyList];
  referenceSeqList   := [@stringSetList  emptyList];

  foreach instructionList (@formatListWithSuffix fslist) do
    #one instruction
    @lstringlist instructionSeq [emptyList];
    @stringset referenceSeq [emptySet];
    foreach fslist (@idfOrRefFormat format @stringlist suffixList) do
      @string suffixLog;
      @string suffixInternal;
      getSuffixString !suffixList ?suffixLog ?suffixInternal;
      cast format
      when == @idfOrRefFormatIsIdf :
        @string temp := [[format name] string].suffixLog;
        @lstring name := [@lstring new !temp ![[format name] location]];
        instructionSeq += !name;
      when == @idfOrRefFormatIsRef :
        @string temp := "#" . [[format name] string].suffixLog;
        @lstring name := [@lstring new !temp ![[format name] location]];
        instructionSeq += !name;
        referenceSeq += ![[format name] string].suffixInternal;
      else error here : "internal error: neither ref nor format idf ?!";
      end cast;
    end foreach;
    instructionSeqList += !instructionSeq;
    referenceSeqList += !referenceSeq;
  end foreach;
end routine;

routine getInstructionCodeSize
  ?? @formatListWithSuffixList instructionList 
  ?? @formatMap formatMap
  ! @variableInstructionCodeList variableInstructionCodeList
:
  variableInstructionCodeList := [@variableInstructionCodeList emptyList];
  foreach instructionList (@formatListWithSuffix fslist) do
    #one instruction
    @instructionCodeOffset offsetList := [@instructionCodeOffset emptyList];
    @uint codeLength := 0;
    foreach fslist (@idfOrRefFormat idfOrRefformat *) do
      offsetList += !codeLength; #start at 0
      cast idfOrRefformat
      when == @idfOrRefFormatIsIdf :
        #get the format
        @format format;
        @lstring currentFormatString := [idfOrRefformat name]; #use static format (no suffix reuired)
        [formatMap searchKey !currentFormatString ?format];
        #from the format, get the offset of the last slice. 
        #It is the offset of the next chunk (must be > 0).
        @sliceList sliceProtoTypeList := [format sliceProtoTypeList];
        @sint nextOffset;
        if [sliceProtoTypeList length] == 0 then
          nextOffset := 0s;
        else
          [sliceProtoTypeList last ?* ?nextOffset];
        end if;
        codeLength := codeLength + [nextOffset uint]; #nextOffset must be > 0
      when == @idfOrRefFormatIsRef :
      else error here : "internal error: neither ref nor format idf ?!";
      end cast;
    end foreach;
    codeLength := codeLength + 1; #code length start from 1, offset from 0.
    variableInstructionCodeList += !offsetList !codeLength;
  end foreach;
end routine;

#TODO: a revoir. Ce qui est retourne est utilise dans les behavior et 
#la syntaxe pour verifier les differents champs
#l'information dynamique doit etre contenue dans decodedInstructionList.
routine setInstructionImplementationNames
  ?? @formatMap formatMap
  ?? @binaryCodeList binaryCodeList
  ?? @formatListWithSuffixList instructionList 
  ?? @lstringListList instructionSeqList
  ?? @stringSetList  referenceSeqList
  ?? @string modelName
  ?? @variableInstructionCodeList variableInstructionCodeList
  !  @instructionImplementationMap instructionMap
:
  instructionMap := [@instructionImplementationMap emptyMap];
  foreach binaryCodeList(@binaryset code),
          instructionList (@formatListWithSuffix fslist), # @stringset instructionId),
          instructionSeqList(@lstringlist instructionSeq),
          referenceSeqList(@stringset instructionID),
          variableInstructionCodeList(@instructionCodeOffset offsetList @uint codeLength) do
    @varBaseTypeMap instructionFieldMap [emptyMap];
    #one instruction
    foreach fslist (@idfOrRefFormat idfOrRefFormat @stringlist suffixList) do
      cast idfOrRefFormat 
      when == @idfOrRefFormatIsIdf :
        #idf: used to construct instructionFieldMap for the instruction.
        #needs formatMap;
        @format format;
        @lstring currentFormatString := [idfOrRefFormat name];
        @string suffixStr;
        getSuffixString !suffixList ?* ?suffixStr;
        [formatMap searchKey !currentFormatString ?format];
        @assignSliceList asList := [format asList];
        foreach asList (@lstring ASname * @varBaseType AStype ...) do
          @lstring fieldName := [@lstring new ![ASname string].suffixStr ![ASname location]];
          if [instructionFieldMap hasKey ![fieldName string]] then
            #there is a problem
            [!?instructionFieldMap insertKey ! fieldName !AStype]; #generate the error.
            message "current fields declared:\n";
            foreach instructionFieldMap (@lstring name *) do
              message " -> ".[name string]."\n";
            end foreach;
            @string path := "current path in format tree:";
            printInstSequence !instructionSeq !?path;
            path .= "\n";
            message path;
          else
            [!?instructionFieldMap insertKey !fieldName !AStype];
          end if;
        end foreach;
      else
      end cast;
    end foreach;
    @string instName := getInstructionName[!instructionID !modelName];
    @lstring idf := [@lstring new !instName !here];
    [!?instructionMap insertKey !idf !code !fslist !instructionSeq !instructionID !offsetList !codeLength !instructionFieldMap];
  end foreach;
end routine;

############################################################################
##  Routines to generate logs (text and graphViz dot)
############################################################################

#Ok, checked
#instruction code is stored with Most Significant part (first fetch) at right..
#This is very useful to compare instruction codes of different sizes. 
#However, in the log, and in the generated decoder, code must appear
#with the first fetch at left. This function re-order the instruction code.
routine getRealInstructionCode
  ?? @binaryset codeMSByteLeft
  ?? @uint instructionSize
  ?? @uint codeLength
  !  @binaryset code
:
  code := [@binaryset fullBinarySet];
  @uint currentChunk := 0;
  loop codeLength:
  while currentChunk < codeLength do
    #get the code chunk;
    @binaryset codeChunk := codeMSByteLeft >> (currentChunk*instructionSize);
    codeChunk := [codeChunk existOnBitIndexAndBeyond !instructionSize];
    # add it to the new code.
    code := code & (codeChunk << ((codeLength - currentChunk - 1)*instructionSize));
    currentChunk := currentChunk + 1;
  end loop;
end routine;

routine printInstructionId 
  ?? @stringset instID 
  ?! @string file
:
  @bool first := true;
  foreach instID (@string elt) do
    if not first then file .= ", "; end if;
    file .= "#".elt;
    first := false;
  end foreach;
end routine;

routine outputFormatGraphViz
  ?? @lstring exportDir
  ?? @formatMap formatMap
  ?? @formatListWithSuffixList instructionList
:
  @string file := "digraph behaviorGraph {\n";
  @string fileRef := file;
  #declare nodes.
  foreach formatMap (@lstring name @format format) do
    file .= "\"".[name string]."\" ";
    cast format
    when == @aggFormat :
      file .= "[shape=box];\n";
    when == @altFormat :
      file .= "[shape=diamond];\n";
      else error here : "internal error: neither aggregate nor alternative format ?!";
    end cast;
  end foreach;

  file .= "node [shape=triangle];\n"; #default for references..
  fileRef .= "node [shape=triangle];\n"; #default for references..
  #construct graph.
  foreach instructionList (@formatListWithSuffix fslist) do
    #one instruction
    @bool first := true;
    @bool firstRef := true;
    foreach fslist (@idfOrRefFormat format *) do #TODO: maybe update to add suffix..
      if first == false then file .= " -> "; end if;
      first := false;
      cast format
      when == @idfOrRefFormatIsIdf :
        file .= "\"".[[format name] string]."\"";
      when == @idfOrRefFormatIsRef :
        file .= "\"#" . [[format name] string]."\"";
        if firstRef == false then fileRef .= " -> "; end if;
        firstRef := false;
        fileRef .= "\"#" . [[format name] string]."\"";
      else error here : "internal error: neither ref nor format idf ?!";
      end cast;
    end foreach;
    file .= "\n";
    fileRef .= "\n";
  end foreach;

  file .= "}\n";
  fileRef .= "}\n";
  createFile ![exportDir string] !"format_all.dot" !file;
  createFile ![exportDir string] !"format_ref.dot" !fileRef;
end routine;

############################################################################
##  generate decoder
############################################################################
#check that there is not 2 instructions that matches the same binary format.
#this function is really time consuming :-/
routine checkISOrthogonality 
  ?? @instructionImplementationMap impMap
:
  if [option .verbose_output value] then
    message "checking instruction binary code coherency...";
  end if;
  @bool errorFound := false;
  @uint i1 := 0;
  foreach impMap (@lstring name1 @binaryset code1 * @lstringlist seq1 ...) do
    @uint i2 := 0;
    foreach impMap (@lstring name2 @binaryset code2 * @lstringlist seq2 ...) do
      if i2 > i1 then 
        @binaryset matchCode := code1 & code2;
        if [matchCode isEmpty] == false then 
          @string seq1str := "";
          @string seq2str := "";
          printInstSequence !seq1 !?seq1str;
          printInstSequence !seq2 !?seq2str;
          error here : "instruction ".name1." (sequence is :". seq1str.") and instruction ".
                       name2." (sequence is :". seq2str.") may have the same binary code. ".
                       "Next errors are reporting locations where instruction is described:";
          foreach seq1 (@lstring item) do
            error [item location] : [item string]." for instruction ".name1." is defined here";
          end foreach;
          foreach seq2 (@lstring item) do
            error [item location] : [item string]." for instruction ".name2." is defined here";
          end foreach;
          errorFound := true;
        end if;
      end if;
      i2:=i2+1;
    end foreach;
    i1 := i1+1;
  end foreach;
  if [option .verbose_output value] then
    if errorFound then message "failed\n"; else message "ok\n"; end if;
  end if;
end routine;

routine getHexString 
  ?? @uint64 mask
  !  @string maskStr
:
  @uint64 max32 := 1L << 32;
  if mask < max32 then
    #ok, it can be stored in a 32 bits integer.
    maskStr := [[mask uint] hexString];
  else
    maskStr := [mask hexString];
  end if;
end routine;


#generate instruction code for the code in parameter.
#cut each code into chuncks of 32 bits.
#send one parameter for each code part (codeLength parameters).
routine generateConditionCode 
  ?? @lstring instName
  ?? @binaryset codeMSByteLeft
  ?? @uint codeLength
  ?? @uint instructionSize
  ?? @uint nbBitsEncodedWith32
  ?! @string file
:
  @uint sizeInBits := instructionSize*codeLength;
  #reform code from Most Significant Part First (at left).
  @binaryset code;
  getRealInstructionCode !codeMSByteLeft !instructionSize !codeLength ?code;

  @uint nbChunks := sizeInBits/nbBitsEncodedWith32;
  if sizeInBits mod nbBitsEncodedWith32 != 0 then nbChunks := nbChunks + 1; end if;

  @uint currentChunk := 0;
  @uint shiftInBits := sizeInBits;
  loop nbChunks:
  while currentChunk < nbChunks do
    if currentChunk == 0 then
      file .= "\tif(";
    else
      file .= " &&\n\t   ";
    end if;
    #@binaryset codeChunk := code >> (currentChunk*nbBitsEncodedWith32);     #condition on 32 bits.
    @uint maskChunk;
    if shiftInBits >= nbBitsEncodedWith32 then 
      shiftInBits := shiftInBits-nbBitsEncodedWith32;
      maskChunk := nbBitsEncodedWith32; #Ok, using the 32 bits.
    else
      maskChunk := shiftInBits; #bits after shiftInBits already taken into account.
      shiftInBits := 0;
    end if;
    @binaryset codeChunk := code >> shiftInBits;     #condition on 32 bits.
    codeChunk := [codeChunk existOnBitIndexAndBeyond !maskChunk]; #condition on 32 bits.
    @stringlist strL;
    strL := [codeChunk compressedStringValueList !sizeInBits];
    #open the '(' if there are several conditions (OR operation required).
    if [strL length] > 1 then file .= "("; end if;
    @bool startOr := true;
    foreach strL (@string compressStr) do
      if not startOr then file .= " || "; end if;
      startOr := false;
      ##the OR condition is removed...
      @uint64 mask [uint64MaskWithCompressedBitString !compressStr];
      @uint64 val  [uint64BaseValueWithCompressedBitString !compressStr];
      @string maskStr;
      @string valStr;
      getHexString !mask ?maskStr;
      getHexString !val ?valStr;
      file .= "((chunk_32_".[currentChunk string]." & ". maskStr.") == ".valStr.")";
    end foreach;
    #close the ')' if there are several conditions (OR operation required).
    if [strL length] > 1 then file .= ")"; end if;
    currentChunk := currentChunk + 1;
  end loop;
  file .= ") return new ".[instName string]."(pcBase,";
  #parameters...
  currentChunk := 0;
  @bool first := true;
  loop codeLength:
  while currentChunk < codeLength do
    currentChunk := currentChunk + 1;
    if not first then file .= ", "; end if; 
    first := false;
    file .= "chunk".[currentChunk string];
  end loop;
  file .= ");\n";
end routine;

#this routine gives the number of bits used in a 32 bit condition.
#for instance, with 12 bit instructions, only 24 bits are used for 
#each nbChunks32. But for a 8 bit instruction sizes, the 32 bits are used.
routine giveNbBitsUsedOn32BitsConditions
  ?? @uint instructionSize
  !  @uint nbBitsEncodedWith32
:
  nbBitsEncodedWith32 := 0;
  loop 32:
  while nbBitsEncodedWith32 <= (32-instructionSize) do
    nbBitsEncodedWith32 := nbBitsEncodedWith32 + instructionSize;
  end loop;
end routine;

#compute instruction conditions for all the instructions that matches an entry in the 
#pointer table (i.e. related to a function).
routine computeImplementationConditions 
  ?? @uint instructionSize
  ?? @conditionDataList conditionDataList 
  ?? @string fetchFunctionCondition
  ?! @string file
:
  @string instructionDefaultSizeCString;
  instructionDefaultSizeCString := "u".[getCSize[!instructionSize] string];
  #getCTypeFor !instructionSize ?instructionDefaultSizeCString ?*;
  @uint nbConditionDone := 0;
  @uint currentSize := 0; #nb of chunks.
  @uint nbChunks32 := 0; #nb of chunks of 32 bits (used fo conditions)
  @uint nbBitsEncodedWith32;
  giveNbBitsUsedOn32BitsConditions !instructionSize ?nbBitsEncodedWith32; 
  file .= "\tu32 chunk_32_0 = chunk1;\n";
  if instructionSize > 32 then
    error here : "cannot handle instruction set of default size > 32 bits at this time";
  end if;
  loop 64: #one instruction cannot exceed 64 fetch ;-)
  while nbConditionDone < [conditionDataList length] do
    currentSize := currentSize + 1;
    if currentSize != 1 then 
      #fetch..TODO:improve.
      @string chunkStr := "chunk".[currentSize string];
      file .= "\t".instructionDefaultSizeCString." ".chunkStr." = ".fetchFunctionCondition.";\n";
      @uint chunk32Bits := currentSize*instructionSize - nbChunks32*32;
      if chunk32Bits > 32 then
        nbChunks32 := nbChunks32+1;
        file .= "\tu32 chunk_32_".[nbChunks32 string]." = ".chunkStr.";\n";
        #TODO. -> remove this code if instructionSize = 32, and update condition codes.
      else
        #TODO.
        @string chunk32Str := "chunk_32_".[nbChunks32 string];
        file .= "\t".chunk32Str." = (". chunk32Str." << ".[instructionSize string].") |". chunkStr.";\n";
      end if;
    end if;
    foreach conditionDataList (@lstring instName @binaryset code @uint codeLength) do
      if codeLength == currentSize then
        #ok, size is matching. Print condition(s)
        generateConditionCode !instName !code !codeLength !instructionSize !nbBitsEncodedWith32 !?file;
        nbConditionDone := nbConditionDone + 1;
      end if;
    end foreach;
  end loop;
  #return NULL if no instruction is matching.
  file .= "\treturn NULL;\n";
end routine;

routine generateDecoder
  ?! @TfieldMap templateStruct
  ?? @instructionImplementationMap impMap
  ?? @defaultSection defaultValues
  ?? @string fetchFunctionCondition
:
  #get data related to binary operations.
  @TfieldMapList decoderFunction [emptyList];

  if [option gadl_options.noCheck value] then 
    if [option .verbose_output value] then
      message "do not search for instruction set format ambiguity (option -c)\n";
    end if;
  else
    checkISOrthogonality !impMap;
  end if;
  @uint tabNbBits := 8; #size of the tab for the decoder (in bits)
  @uint shift;
  @uint instructionSize := [[defaultValues instructionSize] uint];
  if instructionSize == 0 then
    error here: "The instruction default size is not defined in the default section, assuming 32 bits";
    instructionSize := 32;
  end if;  
  if instructionSize <= tabNbBits then
    tabNbBits := instructionSize;
    shift := 0;
  else 
    shift := instructionSize - tabNbBits;
  end if;

  @string instructionDefaultSizeCString;
  @uint instructionDefaultSizeC;
  #getCTypeFor !instructionSize ?instructionDefaultSizeCString ?instructionDefaultSizeC;
  instructionDefaultSizeC := getCSize[!instructionSize];
  instructionDefaultSizeCString := "u".[instructionDefaultSizeC string];
  addStringValue !?templateStruct !lstringWith[!"INST_DEFAULT_SIZE_C_STR"] !instructionDefaultSizeCString;
  addUnsignedValue !?templateStruct !lstringWith[!"INST_DEFAULT_SIZE_C"] ![instructionDefaultSizeC uint64];
  @binaryCodeList tabCodeList [emptyList];
  addStringValue !?templateStruct !lstringWith[!"INST_SHIFT"] ![shift string];
  addStringValue !?templateStruct !lstringWith[!"DECODER_FUNC_TABLE_SIZE_IN_BITS"] ![tabNbBits string];
  foreach impMap (* @binaryset code ...) do
    #log code;
    @binaryset tabRelatedCode := code >> shift;
    tabRelatedCode := [tabRelatedCode existOnBitIndexAndBeyond !tabNbBits]; #mask..
    tabCodeList += !tabRelatedCode;
  end foreach;
  #log tabCodeList;
  @uint nbCases := 1 << tabNbBits;
  @uint i := 0; #loop value
  loop nbCases:
  while i < nbCases do
    @TfieldMap decoderFunctionBody [emptyMap];
    @bool found := false; #at last one instruction is matching
    @binaryset binI := [@binaryset binarySetWithEqualToConstant !0 !tabNbBits ![i uint64]];
    @conditionDataList conditionDataList [emptyList];
    foreach impMap (@lstring name  @binaryset code 4* @uint codeLength ...), tabCodeList (@binaryset tabCode) do
      @binaryset equal := binI & tabCode;
      if [equal isEmpty] == false then #found
        found := true;
        conditionDataList += !name !code !codeLength;
      end if;
    end foreach;
    if found then
      @string body := "";
      computeImplementationConditions !instructionSize !conditionDataList !fetchFunctionCondition !?body;
      addUnsignedValue !?decoderFunctionBody !lstringWith[!"id"] ![i uint64];
      addStringValue !?decoderFunctionBody !lstringWith[!"body"] !body;
    end if;
    addBoolValue !?decoderFunctionBody !lstringWith[!"exist"] !found;

    i := i+1;
    decoderFunction += !decoderFunctionBody;
  end loop;
  addListValue !?templateStruct !lstringWith[!"DECODER_FUNCTION_LIST"] !decoderFunction;
end routine;

############################################################################
##  generate instruction constructors.
############################################################################
function getFormatFieldListSize
  ?? @formatFieldList fieldlist
  -> @uint size
:
  size := 0;
  foreach fieldlist(@uint64 from @uint64 to *) do
    size := size + [from uint] - [to uint] + 1;
  end foreach;
end function;

function basicFormatFieldCode
  ?? @string chunkName
  ?? @formatFieldList fieldList
  -> @string code
:
  code := "";
  @uint offset := 0;
  #iterate in the reverse order.
  foreach > fieldList(@uint64 expFrom @uint64 expTo @location loc)
  do
    @uint offsetInc := 0;
    if offset != 0 then code .= "("; end if;  
    if expFrom == expTo then
      code .= "FIELD_ONE_BIT(".chunkName.",".[expFrom string]."U)";
      offsetInc := 1;
    else #general case.
      code .= "FIELD(".chunkName.",(".[expFrom string]."U),(".[expTo string]."U))";
      #should get the size of the increment:
      offsetInc := [expFrom uint]-[expTo uint]+1;
    end if;
    if offset != 0 then code .= "<<" . [offset string] . ")"; end if;
    offset := offset+offsetInc;
  between code .= "|";
  end foreach;
end function;


function getFormatAssignString
  ?? @sliceList sliceList
  ?? @uint globalOffset
  -> @string code
:
  @string expPrefix := "chunk";
  code := "";
  #slice fields (used in instruction format, for constructors.)
  @uint chunkOffset := 0;
  @bool start := true;
  @sliceList tempSliceList := sliceList; #can be modified 
  @uint nbSlices := [sliceList length];
  if nbSlices != 1 then code .= "("; end if;
  loop nbSlices:
  while [tempSliceList length] > 0 do
    @formatFieldList fieldList; 
    @uint fieldSize;
    #take the last slice.
    @sint fetchPart;
    [!?tempSliceList popLast ?fieldList ?fetchPart];
    #field size.
    fieldSize := getFormatFieldListSize[!fieldList];
    if fieldSize > 0 then
      #put the 'or' between fields
      if not start then code .= "|"; end if;
      #get the offset.
      @sint signedOffset := [globalOffset sint] + fetchPart;
      @uint offset := [signedOffset uint] + 1; #must be > 0. chunk idx start at 1.
      #name of idf is prefix concatened with the offset (starting at 1)
      #@varBaseType varType := [@varType new ![@varKind unsigned] !fieldSize !here];
      #@classicVar var := [@classicVar new !varType !false !expPrefix !""];
      #@cIdf idf := [@cIdf new !getTypeListFrom[!varType] ![@lstring new ![offset string] !here] !var];
      #@cBitFieldOp bitFieldOp := [@cBitFieldOp new !getTypeListFrom[!varType] !idf !fieldList];
      #generate slice code.
      if chunkOffset != 0 then code .= "("; end if;
      #code .= [bitFieldOp generateCode !componentPrefix !idfSuffix !cgc];
      code .= basicFormatFieldCode[!"chunk".[offset string] !fieldList];
      #shift field if needed.
      if chunkOffset != 0 then code .= "<<" . [chunkOffset string].")"; end if;
      #compute next shift value.
      chunkOffset := chunkOffset + fieldSize;
      start := false;
    end if;
  end loop;
  if nbSlices != 1 then code .= ")"; end if;  
end function;

routine constructAssign 
  ?? @format format
  ?? @uint globalOffset
  ?? @string suffixStr
  ?! @string instCode
:
  @assignSliceList asList := [format asList];
  foreach asList (@lstring name
                  @sliceList sliceList
                  @varBaseType type
                  @uint shiftType
                  @luint shiftVal) do
    @string nameWithSuffix := [name string].suffixStr;
    @string realTypeString := [type string];
    instCode .= "\t// construct ".nameWithSuffix." (".realTypeString.")\n";
    instCode .= "\t". nameWithSuffix." = ";
    @bool signExtend := false;
    if [type kind] == [@varKind signed] then #signed var.
      @uint CSize := [type getCSize];
      if [type size] != CSize then
        signExtend := true;
        instCode .= "SIGN_EXTEND(";
      end if;
    elsif [type kind] == [@varKind float] then
      error here: "internal error: not yet imlplemented: format constructor";
    end if;
    instCode .= getFormatAssignString[!sliceList !globalOffset];
    #@cSliceFieldOp sliceOp := [@cSliceFieldOp new !getTypeListFrom[!type] !"chunk" !sliceList !globalOffset];
    #instCode .= [sliceOp generateCode !"" !"" ![@codeCtx C]];
    #Shift management.
    #0 <=> nothing, 1 <=> left shift, 2 <=> right shift, 
    if shiftType != 0 then
      if shiftType == 1 then instCode .= "<<";
      elsif shiftType == 2 then instCode .= ">>"; 
      else error here : "internal error: unknown code!";
      end if;
      instCode .= [[shiftVal uint] string];
    end if;
    if signExtend then
      @uint CSize := [type getCSize];
      instCode .= ", ".[[type size] string].", ".[CSize string].")";
    end if;
    instCode .= ";\n";
  end foreach;
end routine;

#construct definition of data members for instruction.h
routine constructDef
  ?? @format format
  ?? @string suffixStr
  ?! @string def
:
  @assignSliceList asList := [format asList];
  foreach asList (@lstring name *
                  @varBaseType type ...) do
    @string nameWithSuffix := [name string].suffixStr;
    @string CTypeString := [type getCType];
    @string realTypeString := [type string];
    def .= "\t".CTypeString." ".nameWithSuffix.";";
    def .= "  /* ".realTypeString." */\n";
  end foreach;
end routine;

#TODO: unused: Should be removed with new templates.
routine generateAllIdDecoratedString 
  ?? @stringset allIdSet 
  ?! @string idMethodsDecorated
:
  foreach allIdSet (@string id) do
    idMethodsDecorated .= "\tvirtual bool hasID_".id."() {return m_inst->hasID_".id."();};\n";
  end foreach;
end routine;

routine generateInstConstructorAndDef
  ?! @TfieldMap templateStruct
  ?? @instructionImplementationMap impMap
  ?? @formatMap formatMap
:
  #get data related to binary operations.
  @TfieldMapList constructorImpl [emptyList];
  @stringset allIdSet [emptySet]; #get all signature ids.
  foreach impMap (@lstring name 
                  @binaryset bin 
                  @formatListWithSuffix fslist 
                  @lstringlist instructionSeq
                  @stringset instructionID 
                  @instructionCodeOffset offsetList 
                  @uint codeLength ...) do
    #one instruction
    @TfieldMap constructorImplBody [emptyMap];
    addLStringValue !?constructorImplBody !"name" !name;
    addUnsignedValue !?constructorImplBody !lstringWith[!"codeLength"] ![codeLength uint64];
    @string constructorBodyStr := "";
    @string constructorDefStr := "";
    #instruction constructor body (field assignation).
    #also used to get structure field names and types.
    foreach fslist (@idfOrRefFormat idfOrRefformat @stringlist suffixList), offsetList(@uint offset) do
      @string suffixStr;
      getSuffixString !suffixList ?* ?suffixStr;
      cast idfOrRefformat
      when == @idfOrRefFormatIsIdf :
        @format format;
        @lstring currentFormatString := [idfOrRefformat name];
        [formatMap searchKey !currentFormatString ?format];
        constructAssign !format !offset !suffixStr !?constructorBodyStr ;
        constructDef    !format !suffixStr !?constructorDefStr;
      when == @idfOrRefFormatIsRef :
      else error here : "internal error: neither ref nor format idf ?!";
      end cast;
    end foreach;
    addStringValue !?constructorImplBody !lstringWith[!"INST_FIELD_DEF"] !constructorDefStr;
    addStringValue !?constructorImplBody !lstringWith[!"INST_CONSTRUCTOR_BODY"] !constructorBodyStr;

    #hasID_REF functions, where 'REF' is a signature id (#...).
    @stringset instIDMethods [emptySet];
    foreach instructionID (@string id) do 
      allIdSet += !id;
      instIDMethods += !id;
    end foreach;

    addListValue !?constructorImplBody !lstringWith[!"ID_LIST"] !stringSetToList[!instIDMethods !"ID"];
    constructorImpl += !constructorImplBody;
  end foreach;
  #store the set in a list.
  addListValue !?templateStruct !lstringWith[!"ALL_ID_LIST"] !stringSetToList[!allIdSet !"ID"];
  addListValue   !?templateStruct !lstringWith[!"INST_CONSTRUCTOR"] !constructorImpl;
end routine;

############################################################################
##  extract binary format for instructions.
############################################################################

# get the correct "right part" in expression like:
#   #AREF is \m11--
# when the left part is known.
routine searchCode 
  ?? @alternativeIsList tempAltList 
  ?? @idfOrRefFormat currentFormat
  !  @binaryset tempCode
:
#  message "CURRENT FORMAT ".[[currentFormat name] string]."\n";
  tempCode := [@binaryset fullBinarySet]; 
  @bool found := false;
  #message "format: ".[[currentFormat name] string]."\n";
  foreach tempAltList (@idfOrRefFormat leftPart @binaryset rightPart) do
    #message "\t -> ".[[leftPart name] string]."\n";
#    message "LEFT PART ".[[leftPart name] string]."\n";
    if currentFormat == leftPart then
      if found == true then
        @lstring tempStr := [currentFormat name];
        error [tempStr location] : "2 possibilities in the alternative ".[tempStr string];
      end if; 
      found := true;
      tempCode := rightPart;
    end if;
  end foreach;
  if not found then
    error here: "internal error: cannot retrieve the alternative entry..";
  end if;
end routine;

routine getBinaryFormat
  ?? @formatListWithSuffixList instructionList 
  ?? @formatMap       formatMap
  ?? @variableInstructionCodeList variableInstructionCodeList
  ?? @uint instructionSize
  ?? @stringSetList referenceSeqList
  !  @binaryCodeList binaryCodeList
:
  @alternativeIsList tempAltList := [@alternativeIsList emptyList]; #init not used
  binaryCodeList := [@binaryCodeList emptyList];
  foreach instructionList (@formatListWithSuffix fslist), 
          variableInstructionCodeList (@instructionCodeOffset offsetList @uint codeLength),
          referenceSeqList(@stringset instructionID) do
    #one instruction
    #in the list of formats, we are looking for alternatives.
    #When we got one, we search for the following format (agg, alt or ref), which indicates
    #which alternative has been taken.
    @bool nextToSearch := false;
    @binaryset code [fullBinarySet];
    @uint previousOffset := 0; # init not used. Offset of the alternative found.
    #check if this is a ref associated to a format  (field refList of @format)...
    @bool nextIsRefAssociatedToAFormat := false;
    @uint nbSlicesBeforePlus := 0; #init not used.
    foreach fslist (@idfOrRefFormat format *), offsetList (@uint offset) do
      #message "loop: ".[[format name] string]." avec offset de l'alt:".[previousOffset string]."\n"; 
      if not nextIsRefAssociatedToAFormat then
        @lstring currentFormatString := [format name];
        #if we have found an alternative in the previous item in the list. 
        #With the current format (alt/agg/ref), we know which path 
        #was chosen in the alternative.
        #NOTE: If the alternative has a reference, nextIsRefAssociatedToAFormat
        #      has been set to true and the reference has not been takent into account.
        if nextToSearch then
          @binaryset tempCode;
          searchCode !tempAltList !format ?tempCode;
          #add one because the current slice in {bla}{bli}+{blo} is 0 (bli).
          #We have to take into account that we are using bla, with a negative offset :-/
          @uint finalOffset := previousOffset+1-nbSlicesBeforePlus;
          if finalOffset != 0 then
            tempCode := tempCode << ((finalOffset)*instructionSize);
          end if;
          #message "offset is ".[previousOffset string]."\n";
          code := code & tempCode;
          nextToSearch := false;
        end if;
        #looks for alternatives.
        cast format
        when == @idfOrRefFormatIsIdf :
          #idf -> other format (alternative or aggregate)
          @format altFormat;
          [formatMap searchKey !currentFormatString ?altFormat];
          cast altFormat
          when == @aggFormat :
          when == @altFormat altFormatIsAlt :
            #ok, get the alternatives :-)
            tempAltList := [altFormatIsAlt isList];
            #message "alternative is: ".currentFormatString."\n";
            #if there is a reference associated to a format, we do not hava to take it into account.
            nextIsRefAssociatedToAFormat := [[altFormatIsAlt refList] length] > 0;
            #store the ofset of the alternative.
            previousOffset := offset;
            #get the number of slices before a '+' n description to compute the whole offset:
            nbSlicesBeforePlus := [altFormatIsAlt nbSlicesBeforePlus];
            #this should not happen.
            if [[altFormatIsAlt refList] length] > 1 then
              error here : "internal error: only one reference can be associated to a format...";
            end if;
            nextToSearch := true;
          else error here : "internal error: neither aggregate nor alternative format ?!";
          end cast;
        when == @idfOrRefFormatIsRef :
        else error here : "internal error: neither ref nor format idf ?!";
        end cast;
      else #nextIsRefAssociatedToAFormat
        nextIsRefAssociatedToAFormat := false; #only one time.
      end if;
    end foreach;
    if [code isEmpty] & [option .verbose_output value] then
      @string instID := "";
      printInstructionId !instructionID !?instID;
      message "-> instruction ".instID." does not have a valid binary format (always false).\n";
    end if;
    binaryCodeList += !code;
  end foreach;
end routine;

#take into account instruction with different code sizes... but not tested with it.
routine getRelativeBinarySet 
  ?? @binaryset val     #base value (set by user)
  ?? @uint sliceSize #size of the slice considered
  ?? @luint defaultInstructionSize
  ?? @sliceList sliceList      #slice list. offset may be <0
  ?? @uint nbSlicesBeforeAPlus #used to get offset start from 0.
  !  @binaryset set  #return set.
:
  # the operation, to get r=01-10, from a=01--- and b=---10 is r=a&b
  # this routine generate the a and b parts (and the followers if any) and then compute the binary set.
  @uint offset := sliceSize;
  set := [@binaryset fullBinarySet];
  foreach sliceList (@formatFieldList field @sint fetchPart) do 
    #one instruction slice.
    foreach field (@uint64 from @uint64 to @location loc) do 
      @uint rangeSize := [from uint]-[to uint]+1;
      if offset < rangeSize then 
        error loc : "slice size is is too small. Cannot fill with the corresponding fields...";
      end if;
      offset := offset - rangeSize;
      @binaryset chunk := val >> offset;
      chunk := [chunk existOnBitIndexAndBeyond !rangeSize]; #mask..
      @sint fetchOffset := fetchPart + [nbSlicesBeforeAPlus sint] - 1s; #start at 0;
      @uint shift :=  [to uint] + ([fetchOffset uint]*[defaultInstructionSize uint]);
      set := set & (chunk << shift);
    end foreach;
  end foreach;
end routine;

############################################################################
##  construct graph routines.
############################################################################

#add the suffix of 'nextFormat' to the suffix list.
#added is true if the suffix list is updated, else false 
routine addToSuffixList
 ?? @idfOrRefFormat nextFormat
 ?! @stringlist nextSuffixList
 !  @bool added
:
  added := false;
  cast nextFormat
  when >= @idfOrRefFormatIsIdf nextFormatIsIdf :
    @string suffixName := [[nextFormatIsIdf postRefName] string];
    if [suffixName length] != 0 then
      nextSuffixList += !suffixName;
      added := true;
    end if;
  else
  end cast;
end routine;

#recursive routine.
routine constructFormatInstructionTreeRec
  ?? @formatMap              formatMap             #format map: constant
  ?? @formatListWithSuffix   formatListToCompute   #format not yet taken into account
#  ?? @idfOrRefFormat         currentFormat    
  ?? @formatListWithSuffix   instructionFormatList #current format list
#  ?? @stringlist             currentSuffixList #current suffix
  ?! @formatListWithSuffixList instructionList     #output list of format list.
:
  if [formatListToCompute length] > 0 then
    #something to do...
    @formatListWithSuffix newFormatListToCompute := formatListToCompute;
    @formatListWithSuffix newInstructionFormatList := instructionFormatList;
    #get the first format to compute.
    @idfOrRefFormat currentFormat;
    @stringlist currentSuffixList;
    [!?newFormatListToCompute popFirst ?currentFormat ?currentSuffixList];

    #update suffix
    cast currentFormat
      when == @idfOrRefFormatIsIdf currentFormatIsIdf :
        #get suffix.
        @string suffixStr := [[currentFormatIsIdf postRefName] string];
        if [suffixStr length] > 0 then
          currentSuffixList += !suffixStr;
        end if;
      else
      end cast;
      newInstructionFormatList += !currentFormat !currentSuffixList;

      cast currentFormat
      when == @idfOrRefFormatIsIdf :
        #idf -> other format (alternative or aggregate)
        @format format;
        @lstring currentFormatString := [currentFormat name];
        #check that the format is declared for agg and alt.
        [formatMap searchKey !currentFormatString ?format];
        cast format
        when == @aggFormat formatIsAgg :
          #########    aggregate format    ##########    
          @idfOrRefFormatList refList := [formatIsAgg refList];
          foreach refList (@idfOrRefFormat aggRef) do #the aggregate is associated to one or more ref.
            newInstructionFormatList += !aggRef !currentSuffixList;
          end foreach;
          @idfOrRefFormatList formatCallList := [formatIsAgg formatCallList];
          @formatListWithSuffix formatListToComputeUpdated [emptyList];
          foreach formatCallList (@idfOrRefFormat formatCall) do
            formatListToComputeUpdated += !formatCall !currentSuffixList;
          end foreach;
          formatListToComputeUpdated := formatListToComputeUpdated . newFormatListToCompute;
          constructFormatInstructionTreeRec !formatMap !formatListToComputeUpdated !newInstructionFormatList !?instructionList;
      when == @altFormat formatIsAlt :
        ##########    alternative format    ##########
        @idfOrRefFormatList refList := [formatIsAlt refList];
          foreach refList (@idfOrRefFormat altRef) do #the alternative is associated to one or more ref.
            newInstructionFormatList += !altRef !currentSuffixList;
          end foreach;

        #altList cannot be empty. This is checked during parsing... but 2 checks are better ;-)
        #TODO:is this a restriction?
        @alternativeIsList isList := [formatIsAlt isList];
        if [isList length] == 0 then
          error [currentFormatString location]: "alternative format should not be empty.";
        end if;
        foreach isList (@idfOrRefFormat nextFormat *) do
          #there may be a suffix for the next format (only if this is an idf)
          @stringlist nextSuffixList := currentSuffixList; #copy required not to modify next alternatives.
          @formatListWithSuffix newFormatListToComputeAlt := newFormatListToCompute; #idem
          addToSuffixList !nextFormat !?nextSuffixList ?*;
          [!?newFormatListToComputeAlt insertAtIndex !nextFormat !nextSuffixList !0];
          #recursive call.
          constructFormatInstructionTreeRec !formatMap !newFormatListToComputeAlt !newInstructionFormatList !?instructionList;
        end foreach;
      else error here : "internal error: neither aggregate nor alternative format ?!";
      end cast;
    when == @idfOrRefFormatIsRef :
      ##########    reference or declaration ref   ##########    
      constructFormatInstructionTreeRec !formatMap !newFormatListToCompute !newInstructionFormatList !?instructionList;
    else error here : "internal error: neither ref nor format idf ?!";
    end cast;
  else #nothing to compute. This is a leaf.
    instructionList += !instructionFormatList;
  end if;
end routine;

#This routine is used to detect roots in the format tree. 
#There may have multiple roots.
routine detectRootFormats
  ?? @formatMap formatMap
  !  @formatMap rootFormatMap
#  !  @idfOrRefFormatIsIdf rootFormat #no map, as there is only one
:
  #the root format map is used to store only root formats.
  rootFormatMap := formatMap;
  foreach formatMap (@lstring formatName @format format) do
    cast format
    #for aggregates, remove all the formats that are called (they cannot be root).
    when == @aggFormat aggFormat :
      @idfOrRefFormatList formatCallList := [aggFormat formatCallList];
      foreach formatCallList (@idfOrRefFormat formatCalled) do
        #remove only if it has not be removed before (format called more than one time).
        if [rootFormatMap hasKey ![ [formatCalled name] string]] then
          [!? rootFormatMap removeKey ![formatCalled name] ?*];
        end if;
      end foreach;
    when == @altFormat isFormat :
      @alternativeIsList isList := [isFormat isList];
      foreach isList (@idfOrRefFormat formatCalled *) do
        #remove only if it has not be removed before (format called more than one time).
        if [rootFormatMap hasKey ![ [formatCalled name] string]] then
          [!? rootFormatMap removeKey ![formatCalled name] ?*];
        end if;
      end foreach;
    else
    end cast;
  end foreach;
end routine;

routine constructFormatInstructionTree
  ?? @formatMap formatMap
  !  @formatListWithSuffixList instructionList 
:
  instructionList := [@formatListWithSuffixList emptyList];
  @formatMap rootFormatMap;
  if [option .verbose_output value] then
    message "contructing format tree...";
  end if;
  detectRootFormats !formatMap ?rootFormatMap;
  @uint nbInstructionAccumulated := 0;

  foreach rootFormatMap (@lstring formatName *) do
    if [option .verbose_output value] then
      message "\n\tfrom root ".[formatName string]."...";
    end if;

    @formatListWithSuffix formatListToCompute   := [@formatListWithSuffix emptyList];
    @formatListWithSuffix instructionFormatList := [@formatListWithSuffix emptyList];

    @lstring emptyLString := [@lstring new !"" !here];
    @idfOrRefFormatIsIdf rootFormat := [@idfOrRefFormatIsIdf new !formatName !emptyLString];
    @stringlist emptyStringList [emptyList];
    formatListToCompute += !rootFormat !emptyStringList;
    constructFormatInstructionTreeRec !formatMap !formatListToCompute !instructionFormatList !?instructionList;

    if [option .verbose_output value] then
      @uint temp := [instructionList length] - nbInstructionAccumulated;
      message [temp string]." instruction";
      if temp > 1 then message "s."; else message "."; end if;
      nbInstructionAccumulated := [instructionList length];
    end if;

  end foreach;
  if [option .verbose_output value] then
    message "\nFound a total of ".[[instructionList length] string]." instructions formats.\n";
  end if;
end routine;

#$PC_C_TYPE$ should be replaced in the template files.
#$MODELNAME$ should be replaced in the template files.
#TODO: supprimer modelName
routine instructionFormatPart
  ?? @string modelName
  ?? @defaultSection defaultValues
  ?! @TfieldMap templateStruct
  ?? @formatMap formatMap
  ?? @lstring exportDir
  !  @instructionImplementationMap impMap
:
  @formatListWithSuffixList instructionList;
  @binaryCodeList binaryCodeList;
  @lstringListList instructionSeqList;
  @variableInstructionCodeList variableInstructionCodeList;

  #default size of instructions
  @uint instructionSize := [[defaultValues instructionSize] uint];
  if instructionSize == 0 then
    error here: "The instruction default size is not defined in the default section, assuming 32 bits";
    instructionSize := 32;
  end if;
  @string instructionDefaultSizeCString;
  #getCTypeFor !instructionSize ?instructionDefaultSizeCString ?*;
  instructionDefaultSizeCString := "u".[getCSize[!instructionSize] string];
  @uint instructionSizeInBytes := instructionSize/8;
  if (instructionSize & 7) != 0 then
    instructionSizeInBytes := instructionSizeInBytes + 1;
  end if;

  #define fetch function.
  @string fetchFunctionCondition;
  @string multipleFetchFunctionConditionInCache;
  @bool hasUserFetch := isThereAUserFetch[!defaultValues] ;
  @string fetchImplementationName;
  getUserFetchFunction !defaultValues ?fetchImplementationName;
  if hasUserFetch then 
    fetchFunctionCondition := "defaultFetch ? _core->defaultFetch(pc) : _core->".fetchImplementationName."()";
    multipleFetchFunctionConditionInCache := "if(defaultFetch) {\n\t\t\tfor(int _i=0; _i<chunks; _i++) _core->defaultFetch(codeAddr);";
    multipleFetchFunctionConditionInCache .= "\n\t\t\t}else{";
    multipleFetchFunctionConditionInCache .= "\n\t\t\t\tfor(int _i=0; _i<chunks; _i++) _core->".fetchImplementationName."();";
    multipleFetchFunctionConditionInCache .= "\n\t\t\t}";
  else
    fetchFunctionCondition := "_core->defaultFetch(pc)";
    @uint tmp := instructionSizeInBytes-1;
    @uint nbBits := nbBitsToCodeUnsigned[![tmp uint64]];
    if instructionSizeInBytes == (1 << nbBits) then #power  of 2?
      multipleFetchFunctionConditionInCache := "codeAddr += chunks<<".[nbBits string].";";
    else
      multipleFetchFunctionConditionInCache := "codeAddr += chunks * ".[instructionSizeInBytes string].";";
    end if;
  end if;
  @uint tmp := instructionSizeInBytes-1;
  @uint fetchAlignement := nbBitsToCodeUnsigned[![tmp uint64]];
  addStringValue !?templateStruct !lstringWith[!"FETCH_ALIGNMENT_IN_BITS"] ![fetchAlignement string];
  addStringValue !?templateStruct !lstringWith[!"FETCH_FUNCTION_CONDITION"] ! fetchFunctionCondition;
  addStringValue !?templateStruct !lstringWith[!"MULTIPLE_FETCH_FUNCTION_CONDITION_IN_CACHE"] ! multipleFetchFunctionConditionInCache;
  addBoolValue !?templateStruct !lstringWith[!"HAS_USER_FETCH"] !hasUserFetch;

  constructFormatInstructionTree !formatMap ?instructionList;
  getInstructionCodeSize !instructionList !formatMap ?variableInstructionCodeList;
  @stringSetList  referenceSeqList;
  getInstructionSequences !instructionList ?instructionSeqList ?referenceSeqList;
  getBinaryFormat !instructionList !formatMap ! variableInstructionCodeList !instructionSize !referenceSeqList ?binaryCodeList;
  setInstructionImplementationNames !formatMap !binaryCodeList !instructionList !instructionSeqList !referenceSeqList !modelName !variableInstructionCodeList ?impMap;
  outputFormatGraphViz !exportDir !formatMap !instructionList;
  generateDecoder !?templateStruct !impMap !defaultValues !fetchFunctionCondition;
#  generateInstConstructorAndDef !templateDecoderMap !modelName !impMap !formatMap !instructionSize !hasAnArchitectureDefined;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
