semantics gadl_semantics_timingSection:
  import "gadl_semantics_timingSimulationStep.gSemantics" ;
  import "gadl_semantics_expression_extract_idf.gSemantics" ;

#in fact, not only setInTemplate -> do most of the job.
method @timingMap setInTemplate
  ?? @string exportDir
  ?! @TfieldMap templateStruct
:
  @TfieldMapList timingTpl [emptyList];
  @stringset signalSet [emptySet];
  foreach selfcopy do
    @TfieldMap timingTplBody [emptyMap];
    foreach signalIn  (@lstring sigName) do signalSet += ![sigName string]; end foreach;
    foreach signalOut (@lstring sigName) do signalSet += ![sigName string]; end foreach;

    addBoolMap !signalIn  !"name" !"signalWait" !?timingTplBody;
    addBoolMap !signalOut !"name" !"signalEmit" !?timingTplBody;

    @adjMat harmlessAutomata := computeMatAdj[!instList !externalActivation !false];
    @adjMat uppaalAutomata   := computeMatAdj[!instList !externalActivation !true];
    
    @pointList stateCoordinateList;
    getAutomataCoordinates !exportDir !uppaalAutomata !lkey ?stateCoordinateList;
    #add name
    addLStringValue !?timingTplBody !"name" !lkey;
    #add local vars
    addListValue !?timingTplBody !lstringWith[!"localVarUppaal"] ![instList getDeclarationList ![@codeCtx Uppaal]];
    addListValue !?timingTplBody !lstringWith[!"localVar"]  ![instList getDeclarationList ![@codeCtx C]];
    #add automata (Uppaal and simulation ones).
    adjacencyMatrixTemplate !uppaalAutomata   !?timingTplBody !true !stateCoordinateList;  #Uppaal
    adjacencyMatrixTemplate !harmlessAutomata !?timingTplBody !false !stateCoordinateList; #sim

    addBoolValue !?timingTplBody !lstringWith[!"onActivation"] !externalActivation;
    getSimulationSteps !harmlessAutomata !?timingTplBody !externalActivation;
    #expEnable
    addStringValue !?timingTplBody !lstringWith[!"expEnable"] ![expEnable generateCode ![@codeCtx C]];
    #end
    timingTpl += !timingTplBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"timingList"] !timingTpl;
  addListValue !?templateStruct !lstringWith[!"signalDefinedInTiming"] !stringSetToList[!signalSet !"name"];
  #enable condition.
  @boolMapMap timerCondMap := [selfcopy getEnableConditionIdf];
  @TfieldMapList timingEnableTpl [emptyList];  
  foreach timerCondMap do
    @TfieldMap timingEnableTplBody [emptyMap];
    addLStringValue !?timingEnableTplBody !"name" !lkey;    
    addBoolMap !boolMap  !"name" !"timing" !?timingEnableTplBody;
    timingEnableTpl += !timingEnableTplBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"timingEnableList"] !timingEnableTpl;
  #testCopy;
end method;

#return a map where:
# * the key is the register name (or field)
# * the value is a map of timing names.
reader @timingMap getEnableConditionIdf
  -> @boolMapMap timerCondMap
:
  timerCondMap := [@boolMapMap emptyMap];
  foreach selfcopy do #each timing
    #we get the list of identifiers in the 'enable' expression
    @lstring timingName := lkey;
    @expIdfList idfList := [expEnable getIdf ![@expIdfList emptyList]];
    foreach idfList do #with each identifier found in the 'enable' expression:
      switch [idf detectedType] #check correct type
        when unknown, structMember, localVar, tabularAccess, componentCall, periphCall, memoryAccess:
          error [lkey location]: "The condition to enable the timing should not have an identifier with ".
                                  [[idf detectedType] string].". Only registers are allowed";
        when registerAccess, registerBitField :
          #then get the registers to update:
          #for reg.slice => we keep only the 'reg', because the method to access the 
          #slice call the full reg accessor
          #store the result in 'regName'
          @lstring lregName := [[idf idfList] idfAtIndex !0];#get identifier name of the first item.
          @string regName := [lregName string];
          #ok: we are here with the correct 'regName'.
          #The boolMapMap works as follow:
          #the first Key is the register -> we get a boolMap
          #In that boolMap, all the timing names that are dependant of this register are listed.
          if [timerCondMap hasKey !regName] then
            #already an entry -> the register is used
            [timerCondMap searchKey !lregName ?@boolMap timingNameMap];
            if not [timingNameMap hasKey ![timingName string]] then
              #it is used for another 'timing'. Update
              [!?timingNameMap insertKey !timingName];
              #remove the old one and set the new one.
              [!?timerCondMap removeKey !lregName ?*];
              [!?timerCondMap insertKey !lregName !timingNameMap];
            end if;
          else
            @boolMap timingNameMap [emptyMap];
            [!?timingNameMap insertKey !timingName];
            [!?timerCondMap insertKey !lregName !timingNameMap];
          end if;
      end switch;
    end foreach;
  end foreach;
  #debug.
  foreach timerCondMap do
    @lstring reg := lkey;
    message "register ".[reg string].":\n";
    foreach boolMap do
      message "\ttiming ".[lkey string]."\n";
    end foreach;
  end foreach;
end reader;


reader @timingInstructionList getDeclarationList
  ?? @codeCtx cgc              ## generation code context (C, Uppaal, ..)
  -> @TfieldMapList varMapTplList
:
  varMapTplList := [@TfieldMapList emptyList];
  foreach selfcopy do
    if (inst is >=  @tDeclaration) then
      @TfieldMap varMapTplBody [emptyMap];  
      #Ok, get a declaration inst.
      const @tDeclaration tDecInst := (cast inst: @tDeclaration);
      foreach [tDecInst instList] do
        if (inst is >= @instDeclaration) then #inst is a @instruction here.
        const @instDeclaration instDec := (cast inst: @instDeclaration);
         addLStringValue !?varMapTplBody !"name" ![instDec name];     
          #OK, generate code.
          @string declare := [inst generateCode !1 !cgc];
          addStringValue !?varMapTplBody !lstringWith[!"declare"] !declare;      
        end if;
      end foreach;
      #end
      varMapTplList += !varMapTplBody;    
    end if;
  end foreach;
end reader;

routine addBoolMap
  ?? @boolMap boolmap
  ?? @string key
  ?? @string mapName
  ?! @TfieldMap templateStruct
:
  @TfieldMapList itemList [emptyList];
  foreach boolmap (@lstring val) do
    @TfieldMap itemBody [emptyMap];  
    addLStringValue !?itemBody !key !val;
    itemList += !itemBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!mapName] !itemList;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
