semantics gadl_semantics_timingSection:
  import "gadl_semantics_timingSimulationStep.gSemantics" ;

#in fact, not only setInTemplate -> do most of the job.
method @timingMap setInTemplate
  ?? @string exportDir
  ?! @TfieldMap templateStruct
:
  @TfieldMapList timingTpl [emptyList];
  @stringset signalSet [emptySet];
  foreach selfcopy (@lstring name 
                     @bool externalActivation
                     @boolMap SignalIn
                     @boolMap SignalOut
                     @timingInstructionList instList) do

    @TfieldMap timingTplBody [emptyMap];
    foreach SignalIn  (@lstring sigName) do signalSet += ![sigName string]; end foreach;
    foreach SignalOut (@lstring sigName) do signalSet += ![sigName string]; end foreach;

    addBoolMap !SignalIn  !"name" !"signalWait" !?timingTplBody;
    addBoolMap !SignalOut !"name" !"signalEmit" !?timingTplBody;

    @adjMat harmlessAutomata := computeMatAdj[!instList !externalActivation !false];
    @adjMat uppaalAutomata   := computeMatAdj[!instList !externalActivation !true];
    
    @pointList stateCoordinateList;
    getAutomataCoordinates !exportDir !uppaalAutomata !name ?stateCoordinateList;
    #add name
    addLStringValue !?timingTplBody !"name" !name;
    #add local vars
    addListValue !?timingTplBody !lstringWith[!"localVarUppaal"] ![instList getDeclarationList ![@codeCtx Uppaal]];
    addListValue !?timingTplBody !lstringWith[!"localVar"]  ![instList getDeclarationList ![@codeCtx C]];
    #add automata (Uppaal and simulation ones).
    adjacencyMatrixTemplate !uppaalAutomata   !?timingTplBody !true !stateCoordinateList;  #Uppaal
    adjacencyMatrixTemplate !harmlessAutomata !?timingTplBody !false !stateCoordinateList; #sim

    addBoolValue !?timingTplBody !lstringWith[!"onActivation"] !externalActivation;
    getSimulationSteps !harmlessAutomata !?timingTplBody !externalActivation;
    timingTpl += !timingTplBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!"timingList"] !timingTpl;
  addListValue !?templateStruct !lstringWith[!"signalDefinedInTiming"] !stringSetToList[!signalSet !"name"];;
  #testCopy;
end method;

reader @timingInstructionList getDeclarationList
  ?? @codeCtx cgc              ## generation code context (C, Uppaal, ..)
  -> @TfieldMapList varMapTplList
:
  varMapTplList := [@TfieldMapList emptyList];
  foreach selfcopy do
    if (inst is >=  @tDeclaration) then
      @TfieldMap varMapTplBody [emptyMap];  
      #Ok, get a declaration inst.
      const @tDeclaration tDecInst := (cast inst: @tDeclaration);
      foreach [tDecInst instList] do
        if (inst is >= @instDeclaration) then #inst is a @instruction here.
        const @instDeclaration instDec := (cast inst: @instDeclaration);
         addLStringValue !?varMapTplBody !"name" ![instDec name];     
          #OK, generate code.
          @string declare := [inst generateCode !1 !cgc];
          addStringValue !?varMapTplBody !lstringWith[!"declare"] !declare;      
        end if;
      end foreach;
      #end
      varMapTplList += !varMapTplBody;    
    end if;
  end foreach;
end reader;

routine addBoolMap
  ?? @boolMap boolmap
  ?? @string key
  ?? @string mapName
  ?! @TfieldMap templateStruct
:
  @TfieldMapList itemList [emptyList];
  foreach boolmap (@lstring val) do
    @TfieldMap itemBody [emptyMap];  
    addLStringValue !?itemBody !key !val;
    itemList += !itemBody;
  end foreach;
  addListValue !?templateStruct !lstringWith[!mapName] !itemList;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
