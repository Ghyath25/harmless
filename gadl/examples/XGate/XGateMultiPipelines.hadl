-------------------------------------------------------------------------------
-- Constraints :
--    - if statements contain no operation calls
--    - single assignment of local variables
-------------------------------------------------------------------------------

model XGate {

default {
  instruction := 16;             -- default instruction size
--  fetch := Fetcher.fetchCode(); -- fetcher function
  big endian;
}
-- no more default operator as all types are known ?

-------------------------------------------------------------------------------
-- Hardware : variables & interfaces
-------------------------------------------------------------------------------

-- ALU ----------------------------------------------------

component ALU {
  -- status register included in the ALU.
  register u4 CCR {
    C := slice{0} -- carry flag
    V := slice{1} -- overflow flag
    Z := slice{2} -- zero flag
    N := slice{3} -- neg flag
  };

  -- Addition operation --
  void arithAdd16UpdateCCR(u16 a, u16 b, u16 result) {
    CCR.N := result{15};
    CCR.Z := result = 0;
    CCR.V := (a{15} & b{15} & (~result{15})) | ((~a{15}) & (~b{15}) & result{15});
    CCR.C := (a{15} & b{15})  | (a{15} & (~result{15})) | (b{15} & (~result{15}));
  }

  u16 addOp(u16 a,u16 b) {
    u16 result;
    result := (u16)(a + b);
    return result;
  }

  u16 add16OpUpdateCCR(u16 a,u16 b) {
    u16 result;
    result := (u16)(a + b);
    arithAdd16UpdateCCR(a, b, result);
    return result;
  }
  u16 add16OpWithCarryUpdateCCR(u16 a,u16 b) {
    u16 result;
    result := (u16)(a + b + CCR.C);
    arithAdd16UpdateCCR(a, b, result);
    return result;
  }
  
  -- Subtration operation --

  void arithSub16UpdateCCR(u16 a, u16 b, u16 result) {
    CCR.N := result{15};
    CCR.Z := result = 0;
    CCR.V := (a{15} & (~b{15}) & (~result{15})) | ((~a{15}) & b{15} & result{15});
    CCR.C := ((~a{15}) & b{15})  | ((~a{15}) & result{15}) | (b{15} & result{15});
  }

  void arithSub8UpdateCCR(u8 a, u8 b, u8 result) {
    CCR.N := result{7};
    CCR.Z := result = 0;
    CCR.V := (a{7} & (~b{7}) & (~result{7})) | ((~a{7}) & b{7} & result{7});
    CCR.C := ((~a{7}) & b{7})  | ((~a{7}) & result{7}) | (b{7} & result{7});
  }

  u16 sub16OpUpdateCCR(u16 a,u16 b) {
    u16 result;
    result := a - b;
    arithSub16UpdateCCR(a, b, result);
    return result;
  }

  u16 sub16OpWithCarryUpdateCCR(u16 a,u16 b) {
    u16 result;
    result := a - b - CCR.C;
    arithSub16UpdateCCR(a, b, result);
    return result;
  }

  u8 sub8OpUpdateCCR(u8 a,u8  b) {
    u8 result;
    result := a - b;
    arithSub8UpdateCCR(a, b, result);
    return result;
  }

  u8 sub8OpWithCarryUpdateCCR(u8 a,u8 b) {
    u8 result;
    result := a - b - CCR.C;
    arithSub8UpdateCCR(a, b, result);
    return result;
  }

  -- Logical | operation --
  void logicalUpdateCCR(u16 result) {
    CCR.N := result{15}; -- MSB set.
    CCR.Z := result = 0;
    CCR.V := 0;
  }

  u16 orOpUpdateCCR(u16 a,u16  b) {
    u16 result;
    result := a | b;
    logicalUpdateCCR(result);
    return result;
  }

  u16 andOpUpdateCCR(u16 a,u16  b) {
    u16 result;
    result := a & b;
    logicalUpdateCCR(result);
    return result;
  }

  u16 xnorOpUpdateCCR(u16 a,u16  b) {
    u16 result;
    result := ~ (a ^ b);
    logicalUpdateCCR(result);
    return result;
  }

  -- bitfield operations.
  u16 FindFirstOne(u16 source) { -- really ugly function :'(
    u16 result;
    if     source{15} then result := 15;
    elseif source{14} then result := 14; 
    elseif source{13} then result := 13; 
    elseif source{12} then result := 12; 
    elseif source{11} then result := 11; 
    elseif source{10} then result := 10; 
    elseif source{09} then result :=  9; 
    elseif source{08} then result :=  8; 
    elseif source{07} then result :=  7; 
    elseif source{06} then result :=  6; 
    elseif source{05} then result :=  5; 
    elseif source{04} then result :=  4; 
    elseif source{03} then result :=  3; 
    elseif source{02} then result :=  2; 
    elseif source{01} then result :=  1; 
    elseif source{00} then result :=  0; 
    end if;
    CCR := 0 cat result = 0 cat 0 cat source = 0;
    return result;
  }

  void shiftOpUpdateCCR(u16 result, u16 val) { --do not take carry into account.
    CCR.N := result{15};
    CCR.Z := result = 0;
    CCR.V := result{15} ^ val{15};
  }

  s16 arithShiftRight(s16 val, u16 n) {
    s16 result;
    result := val >> n; -- result is signed: sign is preserved.
    if n>0 then 
      CCR.C := val{n-1}; -- (u1)((val >> (n-1)) & 1);  -- eq val{n-1}
    end if;
    shiftOpUpdateCCR(result, val);
    return result;
  }
  
  u16 CSL(u16 val, u16 n) { -- TODO:check!!
    u1 carry;
    u16 result;
    u16 mask;
    if n > 0 then 
      carry := (u1)((val >> (16-n)) & 1) ; -- eq val{16-n}
      result := val << n;
      if carry then
        mask := (1 << n) - 1; -- peut etre un operateur qui renvoi un champ directement??
        result := result | mask;
      end if; -- else already set to 0;
      CCR.C := carry;
    end if;
    shiftOpUpdateCCR(result, val);
    return result;
  }

  u16 CSR(u16 val, u16 n) { -- TODO:check!!
    u1 carry;
    u16 result;
    u16 mask;
    if n > 0 then 
      carry := (u1)((val >> (n-1)) & 1); 
      result := val >> n;
      if carry then
        mask := (1 << n) - 1;
        mask := mask << (16-n);
        result := result | mask;
      end if; -- else already set to 0;
      CCR.C := carry;
    end if;
    shiftOpUpdateCCR(result, val);
    return result;
  }

  u16 LSL(u16 val, u16 n) {
    u16 result;
    if n > 0 then 
      result := val << n;
      CCR.C := (u1)(val{16-n}); --(u1)((val >> (16-n)) & 1);
    end if;
    shiftOpUpdateCCR(result, val);
    return result;
  }

  u16 LSR(u16 val, u16 n) {
    u16 result;
    if n > 0 then 
      result := val >> n;
      CCR.C := val{n-1}; --(u1)((val >> (n-1)) & 1);
    end if;
    shiftOpUpdateCCR(result, val);
    return result;
  }
  void rotationOpUpdateCCR(u16 result)
  {
    CCR.N := result{15};
    CCR.Z := result = 0;
    CCR.V := 0;
  }
  u16 ROR(u16 val, u16 n) {
    u16 result;
    result := val ror n;
    rotationOpUpdateCCR(result);
    return result;
  }
  u16 ROL(u16 val, u16 n) {
    u16 result;
    result := val rol n;
    rotationOpUpdateCCR(result);
    return result;
  }
}

-- Memory -------------------------------------------------

component mem {
  program memory internalRam {
    width   := 16; -- get 16 bits / access
    address := \x0..\xFFFF;
    type    := RAM;
  }
  
  -- access
  -- mem.read16()
  -- mem.internalRam.read16();
}

component GPR
{
  memory {
    width   := 16; -- get 16 bits / access
    address := 0..15;
    stride  := 2;
    type    := register;
    
    register R0 maps to 0 is read 0;
  }
}

-- Fetch unit ---------------------------------------------

component Fetcher {
  program counter u16 pc;
-- generate get and set methods.

  void reset() {
    pc := 0;
  }

  void branch(s16 offset, u1 cond) {
   if cond then
    pc := (u16)((s16)(pc) + offset);
    stall 1 cycle;
   end if
  }

  u16 fetchCode() {
    u16 val := mem.read16(pc);
    pc := (u16)(pc+2);
    return val;
  }
}

-------------------------------------------------------------------------------
-- Hardware : architectures
-------------------------------------------------------------------------------

architecture Generic {
  device gpr : GPR {
      read is read8 | read16
      write is write8 | write16
      port rs : read (3);
      port rd : write (2);
    }

  device alu : ALU {
      port all;
    }

  device MEM : mem {
      read is read8 | read16
      write is write8 | write16
      shared port fetch : read;
      shared port loadStore : read or write;
    }

  device fetcher : Fetcher {
      port branch : branch;
    }
}

-------------------------------------------------------------------------------
-- Hardware : pipelines
-------------------------------------------------------------------------------

--pipeline pFE maps to Generic {
----  run Fetcher.next() as Instruction
--
--  stage Fetch {
----      fetcher : next;
--      mem : read;
--    }
--
--  stage Execute {
--      Fetcher : branch;
--      ALU : *;
----      ccr : c_r, c_w, n_r, n_w, v_r, v_w, z_r, z_w;
--      GPR : read, write;
--      mem : read, write;
--    }
--}

machine all {
  init {
    Fetcher.reset();
  }
  
--  p1 fetch1 | p1 fetch2,(p2|p3),p4 finish3 | p4 finish4
--  pFD,(pE1|pE2),pMR 
--  pFDEAMR
  pF,pD,pEA,pM,pR 
}

pipeline pF maps to Generic {
  stage Fetch {
--      fetchPort : next;
      mem : read;
    }
   
--  stage Decode maps to BPU { --For Branch Processing Unit
--      Fetcher : branch;
--      GPR : read;
--    }
}

pipeline pD maps to Generic {
   
  stage Decode{ --For Branch Processing Unit
      Fetcher : branch;
      GPR : read;
    }
}

--pipeline pEAMR maps to Generic {
--  stage Execute1 {
--      ALU release in <Execute2> : *;
--    }
--
--  stage Execute2 {
--    }
--
--  stage Memory {
--      mem : read, write;
--      GPR : read;
--    }
--
--  stage Register {
--      GPR bypass in <Execute2, Memory> : write;
--    }
--}


pipeline pEA maps to Generic {
--  stage Decode maps to BPU { --For Branch Processing Unit
--      Fetcher : branch;
--      GPR : read;
--    }

  stage Execute1 {
      ALU release in <Execute2> : *;
    }

  stage Execute2 {
    }    
}

pipeline pM maps to Generic {
  stage Memory {
      mem : read, write;
      GPR : read;
    }

--  stage Register {
--      GPR bypass in <Memory> :write;
--    }
}


pipeline pR maps to Generic {

  stage Register {
      GPR :write;
    }
}


--pipeline pE1 maps to Generic {
--   stage Execute1 {
--      ALU release in <Execute2> : *;
--    }
--
--   stage Execute2 {
--    }
--}
--
--pipeline pE2 maps to Generic {
--  stage Execute {
--    }
--}
--
--pipeline pMR maps to Generic {
--  stage Memory {
--      mem : read, write;
--      GPR : read;
--    }
--
--  stage Register {
--      GPR bypass in <Memory> : write;
--    }
--}


--pipeline pFDEAMR maps to Generic {
--
--  stage Fetch {
--      mem : read;
--    }
--
--  stage Decode maps to BPU{ --For Branch Processing Unit
--      Fetcher : branch;
--      GPR : read;
--    }
--
--  stage Execute1 {
--      ALU release in <Execute2> : *;
--    }
--
--  stage Execute2 {
--    }
--
--  stage Memory {
--      mem : read, write;
--      GPR : read;
--    }
--
--  stage Register {
--      GPR bypass in <Execute2, Memory> : write;
--    }
--}

------------------------------------------------------------------------------
--Instruction set : format view
------------------------------------------------------------------------------
format Instruction
  select slice{15..11}
    case \b00000 is xGateSpecialInstructions
    case \b00001 is shiftInstruction
    case \m0001- is triadicInstruction
    case \m001-- is branchInstruction
    case \m01--- is loadStoreAndBitFieldInstruction
    case \m1---- is logicImmAndArithImmInstruction
  end select
end format

-- Logic and artighmetic instruction with immediat.
format logicImmAndArithImmInstruction #LogArithImm 
  rdIndex   := slice{10..8}
  imm8 := slice{7..0}
  select slice{13..12}
    case \b01 is logicImmAndArithImmUpdateNoReg
    others    is logicImmAndArithImmUpdateReg
  end select
end format

format logicImmAndArithImmUpdateNoReg
  select slice{14..11}
    case \b0010 is #BITL
    case \b0011 is #BITH
    case \b1010 is #CMPL
    case \b1011 is #CPCH
  end select
end format

format logicImmAndArithImmUpdateReg
  select slice{14..11}
    case \b0000 is #ANDL
    case \b0001 is #ANDH   
    case \b0100 is #ORL    
    case \b0101 is #ORH    
    case \b0110 is #XNORL  
    case \b0111 is #XNORH  
    case \b1000 is #SUBL   
    case \b1001 is #SUBH   
    case \b1100 is #ADDL   
    case \b1101 is #ADDH   
    case \b1110 is #LDL    
    case \b1111 is #LDH    
  end select
end format

-- load store and bit fields
format loadStoreAndBitFieldInstruction #LSAndBF
  regIndex := slice{10..8}
  rbIndex := slice{7..5}
  select slice{13}
    case 0 is loadStoreWithOffset
    others is loadStoreIndirectAndBitFieldInstruction
  end select
end format

format loadStoreIndirectAndBitFieldInstruction #LSIAndBF
  riIndex := slice{4..2}
  select slice{1..0}
    case \b11 is bitField
    others    is 
      loadStoreSize 
      loadStoreAddressingMode 
      loadStoreType
  end select
end format

format bitField
  select slice{12..11}
    case \b00 is #BFEXT  
    case \b01 is #BFINS  
    case \b10 is #BFINSI 
    case \b11 is #BFINSX 
  end select
end format

format loadStoreWithOffset #LSOFF5
  off5 := slice{4..0}
  loadStoreSize
  loadStoreType
end format

format loadStoreAddressingMode
  select slice{1..0}
    case \b00 is #PLAIN    -- register indirect
    case \b01 is #POSTINC  -- post incremented
    case \b10 is #PREDEC   -- pre decremented
  end select
end format

format loadStoreSize
  select slice{11}
    case \b0 is #BYTE 
    case \b1 is #WORD 
  end select
end format

format loadStoreType
  select slice{12}
    case \b0 is #LOAD  
    case \b1 is #STORE 
  end select
end format

-- branch instructions
format branchInstruction
  select slice{12..10}
    case \b111 is #UncondBranch
      rel11 := signed slice{9..0} << 1
    others is conditionalBranchInstruction
  end select
end format

format conditionalBranchInstruction #CondBranch
  rel10 := signed slice{8..0} << 1
  select slice{12..9}
    case \b0000 is #BCC 
    case \b0001 is #BCS 
    case \b0010 is #BNE 
    case \b0011 is #BEQ 
    case \b0100 is #BPL 
    case \b0101 is #BMI 
    case \b0110 is #BVC 
    case \b0111 is #BVS 
    case \b1000 is #BHI 
    case \b1001 is #BLS 
    case \b1010 is #BGE 
    case \b1011 is #BLT 
    case \b1100 is #BGT 
    case \b1101 is #BLE 
  end select
end format

-- triadic
format triadicInstruction #TriadicInst
  rs1Index := slice{7..5}
  rs2Index := slice{4..2}
  rdIndex  := slice{10..8}
  select slice{11,1..0}
    case \b000 is #AND  
    case \b010 is #OR   
    case \b011 is #XNOR 
    case \b100 is #SUB  
    case \b101 is #SBC  
    case \b110 is #ADD  
    case \b111 is #ADC  
  end select
end format

-- shift instructions --
format shiftInstruction #SHIFT
  rdIndex := slice{10..8}
  select slice{3}
    case \b0 is shiftInstructionDyadic 
    case \b1 is #IMM4 
      imm4 := slice{7..4} 
      shiftInstructionType
  end select
end format

format shiftInstructionDyadic #ShiftReg
  rsIndex := slice{7..5}
  select slice{2..0}
    case \b000   is #BFFO
    others       is shiftInstructionType
  end select
end format

format shiftInstructionType
  select slice{2..0}
    case \b001 is #ASR 
    case \b010 is #CSL 
    case \b011 is #CSR 
    case \b100 is #LSL 
    case \b101 is #LSR 
    case \b110 is #ROL 
    case \b111 is #ROR 
  end select
end format

-- XGate special instructions --

format xGateSpecialInstructions
  select slice{10..0}
    case \b000_0000_0000 is #BRK
    case \b001_0000_0000 is #NOP
    case \b010_0000_0000 is #RTS
    case \b011_0000_0000 is #SIF_NO_REG
    case \m---_1111_00-- is xGateSpecialInstructionsSemaphore
    case \m---_1111_01-- is singleRegisterInstruction
    case \m---_1111_10-- is specialMoveInstruction
  end select
end format

format specialMoveInstruction
  regIndex := slice{10..8}
  select slice{1..0}
    case \b00 is #TFR1  -- TFR RD, CCR
    case \b01 is #TFR2  -- TFR CCR, RS
    case \b10 is #TFR3  -- TFR RD, PC
  end select
end format

format singleRegisterInstruction
  regIndex := slice{10..8}
  select slice{1..0}
    case \b00 is #SEX
    case \b01 is #PAR
    case \b10 is #JAL
    case \b11 is #SIF_REG
  end select
end format

format xGateSpecialInstructionsSemaphore
  select slice{0}
    case \b0 is xGateSpecialInstructionsSemaphoreImm
    case \b1 is xGateSpecialInstructionsSemaphoreReg
  end select
end format

format xGateSpecialInstructionsSemaphoreImm #SemImm
  imm := slice{10..8}
  select slice{1}
    case \b0 is #CSEM 
    case \b1 is #SSEM 
  end select
end format

format xGateSpecialInstructionsSemaphoreReg #SemReg
  regIndex := slice{10..8}
  select slice{1}
    case \b0 is #CSEM
    case \b1 is #SSEM
  end select
end format

------------------------------------------------------------------------------
--Instruction set : semantic view
-----------------------------------------------------------------------------

behavior unCondBranch #UncondBranch
  field s11 rel11;
  do Fetcher.branch(rel11, 1); end do
end behavior

behavior logicImmAndArithImmInstruction() #LogArithImm
  field u3 rdIndex;
  field u8 imm8;
--  u16 rdValue;
--  do rdValue:= GPR.read16(rdIndex); end do;
  select
    case logicImmAndArithImmUpdateNoReg(imm8, rdIndex)
    case logicImmAndArithImmUpdateReg(imm8, rdIndex)
    case logicImmAndArithImmUpdateRegNoReadReg(imm8, rdIndex)
  end select;
end behavior

behavior logicImmAndArithImmUpdateNoReg(u8 imm8, u3 rdIndex)
  u16 rdValue;
  do rdValue:= GPR.read16(rdIndex); end do;
  select
    case #BITL do ALU.andOpUpdateCCR(rdValue{7..0} ,imm8); end do
    case #BITH do ALU.andOpUpdateCCR(rdValue{15..8},imm8); end do
    case #CMPL do ALU.sub8OpUpdateCCR(rdValue{7..0},imm8); end do
    case #CPCH do ALU.sub8OpWithCarryUpdateCCR(rdValue{15..8},imm8);end do
  end select
end behavior

behavior logicImmAndArithImmUpdateReg(u8 imm8, u3 rdIndex)
  u16 rdValue;
  u16 result;
  do rdValue:= GPR.read16(rdIndex); end do;
  do result := rdValue; end do
  select
    case #ANDL  do result{7..0}  := (u8)(ALU.andOpUpdateCCR(rdValue{7..0} ,imm8));  end do
    case #ANDH  do result{15..8} := (u8)(ALU.andOpUpdateCCR(rdValue{15..8},imm8));  end do
    case #ORL   do result{7..0}  := (u8)(ALU.orOpUpdateCCR(rdValue{7..0} , imm8));  end do
    case #ORH   do result{15..8} := (u8)(ALU.orOpUpdateCCR(rdValue{15..8}, imm8));  end do
    case #XNORL do result{7..0}  := (u8)(ALU.xnorOpUpdateCCR(rdValue{7..0} , imm8));end do
    case #XNORH do result{15..8} := (u8)(ALU.xnorOpUpdateCCR(rdValue{15..8}, imm8));end do
    case #SUBL  do result := ALU.sub16OpUpdateCCR(rdValue,imm8); end do
    case #SUBH  do result := ALU.sub16OpUpdateCCR(rdValue,imm8 cat (u8)(0));  end do
    case #ADDL  do result := ALU.add16OpUpdateCCR(rdValue,imm8); end do
    case #ADDH  do result := ALU.add16OpUpdateCCR(rdValue,imm8 cat (u8)(0));  end do
--    case #LDL   do result := imm8;        end do -- high byte is set to 0 . Is it in the ALU?
--    case #LDH   do result{15..8} := imm8; end do -- low byte remains unchanged .Is it in the ALU?
  end select
  do GPR.write16(rdIndex, result); end do
end behavior

behavior logicImmAndArithImmUpdateRegNoReadReg(u8 imm8, u3 rdIndex)
  u16 result;
  select
    case #LDL   do result := imm8;        end do -- high byte is set to 0 . Is it in the ALU?
    case #LDH   do result{15..8} := imm8; end do -- low byte remains unchanged .Is it in the ALU?
  end select
  do GPR.write16(rdIndex, result); end do
end behavior

-- bitfield
behavior bitField() #LSAndBF #LSIAndBF 
  field u3 regIndex;
  field u3 rbIndex;
  field u3 riIndex;
  u16 rdValue;
  u16 rs1Value;
  u16 rs2Value;
  u4 _width;
  u4 offset;
  u5 sum;
  do 
    rs1Value := GPR.read16(rbIndex);
    rs2Value := GPR.read16(riIndex);
    _width  := rs2Value{7..4};
    offset := rs2Value{3..0};
    sum := _width + offset;
    -- max 15 bits extracted
    if sum > 15 then sum := 15; end if; 
    -- offset = 0, right most position
    -- width = 0 denotes 1 bit.
  end do
  select
    -- case rs1Value{sum..offset} not supported yet :'(
    case #BFEXT   -- rdValue := rs1Value{sum..offset}; 
    case #BFINS   -- rdValue{sum..offset} := rs1Value{width..0}; 
    case #BFINSI  -- rdValue{sum..offset} := ~rs1Value{width..0}; 
    case #BFINSX  -- rdValue{sum..offset} := ~(rdValue{sum..offset} ^ rs1Value{width..0}); 
  end select
  do 
    ALU.logicalUpdateCCR(rdValue);
    GPR.write16(regIndex,rdValue);
  end do
end behavior

-- load store
behavior loadStore() #LSAndBF #LSIAndBF 
  field u3 regIndex;
  field u3 rbIndex;
  field u3 riIndex;
  u2 inc;
  u16 ri;
  u16 addr;
  u1 accessType; -- 0 for Byte, 1 for Word.
  loadStoreSize(accessType)
  loadStoreGetAddress(accessType, rbIndex, riIndex, addr, inc, ri)
  loadStoreType(accessType, addr, regIndex)
  loadStoreAddressingMode(inc, ri, riIndex)
end behavior

behavior loadStoreGetAddress(u1 accessType, u3 rbIndex, u3 riIndex, out u16 addr, out u2 inc, out u16 ri)
  do 
    u16 rb;
    rb := GPR.read16(rbIndex);
    ri := GPR.read16(riIndex);
    addr := ALU.addOp(rb,ri);
    -- increment (if needed)
    inc := 1 << accessType;
  end do
  select
    case #PLAIN   
    case #POSTINC 
    case #PREDEC  do addr := addr-inc; end do
  end select
end behavior

behavior loadStoreAddressingMode(u2 inc, u16 ri, u3 riIndex)
  select
    case #PLAIN
    case #POSTINC do GPR.write16(riIndex,(u16)(ri + inc)); end do
    case #PREDEC  do GPR.write16(riIndex,ri-inc);end do
  end select
end behavior

-- load store with offset..
behavior loadStoreWithOffset() #LSAndBF #LSOFF5
  field u3 regIndex;
  field u3 rbIndex;
  field u5 off5;
  u16 addr;
  u1 accessType; -- 0 for Byte, 1 for Word.
  do 
    u16 rb := GPR.read16(rbIndex);
    addr := ALU.addOp(rb,off5);
  end do
  loadStoreSize(accessType)
  loadStoreType(accessType, addr, regIndex)
end behavior

behavior loadStoreSize(out u1 accessType) 
  -- ou field...
  select
    case #BYTE do accessType := 0;end do
    case #WORD do accessType := 1;end do
  end select
end behavior

behavior loadStoreType(u1 accessType, u16 addr, u3 regIndex)
  select
    case #LOAD
      do
         if accessType = 0 then
           u8 val := mem.read8(addr);
           GPR.write8(regIndex, val);
         else
           u16 val := mem.read16(addr);
           GPR.write16(regIndex, val);
         end if;
      end do
    case #STORE 
      do
         if accessType = 0 then
           u8 val := GPR.read8(regIndex);
           mem.write8(addr, val);
         else
           u16 val := GPR.read16(regIndex);
           mem.write16(addr, val);
         end if;
      end do
  end select
end behavior

-- conditional branch
behavior conditionalBranchInstruction() #CondBranch 
  field s10 rel10;
  u1 jumptaken;
  select
    case #BCC do jumptaken := CCR.C = 0;end do
    case #BCS do jumptaken := CCR.C = 1;end do
    case #BNE do jumptaken := CCR.Z = 0;end do
    case #BEQ do jumptaken := CCR.Z = 1; end do
    case #BPL do jumptaken := CCR.N = 0; end do
    case #BMI do jumptaken := CCR.N = 1; end do
    case #BVC do jumptaken := CCR.V = 0; end do
    case #BVS do jumptaken := CCR.V = 1; end do
    case #BHI do jumptaken := (CCR.C | CCR.Z) = 0;end do
    case #BLS do jumptaken := (CCR.C | CCR.Z) = 1;end do
    case #BGE do jumptaken := CCR.N ^ CCR.V = 0;end do
    case #BLT do jumptaken := CCR.N ^ CCR.V = 1;end do
    case #BGT do jumptaken := ((CCR.N ^ CCR.V) | CCR.Z) = 0;end do
    case #BLE do jumptaken := ((CCR.N ^ CCR.V) | CCR.Z) = 1;end do
  end select
  do 
--    if jumptaken then
    Fetcher.branch(rel10, jumptaken);
--    end if; 
  end do
end behavior

-- triadic instruction
behavior triadicInstruction() #TriadicInst
  field u3 rs1Index;
  field u3 rs2Index;
  field u3 rdIndex;
  u16 rs1Value;
  u16 rs2Value;
  u16 rdValue;
  do 
    rs1Value := GPR.read16(rs1Index);
    rs2Value := GPR.read16(rs2Index);
  end do
  select 
    case #AND  do rdValue := ALU.andOpUpdateCCR(rs1Value, rs2Value);end do
    case #OR   do rdValue := ALU.orOpUpdateCCR(rs1Value, rs2Value); end do
    case #XNOR do rdValue := ALU.xnorOpUpdateCCR(rs1Value, rs2Value);end do
    case #SUB  do rdValue := ALU.sub16OpUpdateCCR(rs1Value, rs2Value);end do
    case #SBC  do rdValue := ALU.sub16OpWithCarryUpdateCCR(rs1Value, rs2Value);end do
    case #ADD  do rdValue := ALU.add16OpUpdateCCR(rs1Value, rs2Value);end do
    case #ADC  do rdValue := ALU.add16OpWithCarryUpdateCCR(rs1Value, rs2Value);end do
  end select
  do GPR.write16(rdIndex,rdValue); end do
end behavior

-- BFFO
behavior BFFOInstruction() #SHIFT #ShiftReg #BFFO
  field u3 rdIndex;
  field u3 rsIndex;
  u16 rdValue;
  u16 rsValue;
  do
    rsValue := GPR.read16(rsIndex);
    rdValue := ALU.FindFirstOne(rsValue); 
    GPR.write16(rdIndex, rdValue);
  end do
end behavior

-- rotation instructions
behavior rotationInstruction() #SHIFT 
  field u3 rdIndex;
  u16 rdValue;
  u16 source;
  select
    case #ShiftReg field u3 rsIndex; do source := GPR.read16(rsIndex) & \xF;end do
    case #IMM4     field u4 imm4;    do source := imm4;end do
  end select
  select
    case #ROL do rdValue := ALU.ROL(rdValue, source);end do
    case #ROR do rdValue := ALU.ROR(rdValue, source);end do
  end select
  do GPR.write16(rdIndex,rdValue); end do
end behavior

-- Shift instructions.
behavior shiftInstruction() #SHIFT
  field u3 rdIndex;
  u16 rdValue;
  u16 source;
  shiftInstructionType(source)
  shiftInstructionBehavior(rdValue, source)
  do GPR.write16(rdIndex,rdValue); end do
end behavior

behavior shiftInstructionBehavior(out u16 rdValue, u16 source) 
  select
    case #ASR do rdValue := (u16)(ALU.arithShiftRight((s16)(rdValue), source));end do
    case #CSL do rdValue := ALU.CSL(rdValue, source);end do
    case #CSR do rdValue := ALU.CSR(rdValue, source);end do
    case #LSL do rdValue := ALU.LSL(rdValue, source);end do
    case #LSR do rdValue := ALU.LSR(rdValue, source);end do
  end select
end behavior

behavior shiftInstructionType(out u16 source)
  select
    case #ShiftReg 
      do
         field u3 rsIndex; 
         u16 tempVal;
         tempVal := GPR.read16(rsIndex);
         if tempVal > 16 then -- saturation at 16. TODO need a SAT operator??
           source := 16;
         else
           source := tempVal;
         end if;
      end do
    case #IMM4 
      do
         field u4 imm4;
         if imm4 = 0 then 
           source := 16;
         else
           source := imm4; 
         end if;
      end do
  end select
end behavior

behavior specialMoveInstruction()
  field u3 regIndex;
  select
    case #TFR1 do GPR.write16(regIndex,CCR); end do              -- RD <- CCR
    case #TFR2 do CCR := (u4)(GPR.read16(regIndex) & \xF); end do-- CCR <- RD[3..0]
    case #TFR3 do GPR.write16(regIndex,pc); end do               -- RD <- PC
  end select
end behavior
 
behavior singleRegistersInstructions()
  field u3 regIndex;
  u16 reg;
  do reg := GPR.read16(regIndex); end do
  select
    case #SEX  -- sign extend byte to word
    case #PAR  -- parity
    case #JAL  -- Jump and Link
  end select
end behavior

-- semaphores
behavior semaphoreInstructions()
  u3 semId;
  select
    case #SemImm field u3 imm; do semId := imm;end do
    case #SemReg field u3 regIndex; do semId := (u3)(GPR.read16(regIndex) & \x3);end do
  end select
  select
    case #CSEM --unlock semaphore
    case #SSEM --lock semaphore
  end select
end behavior


-- SIF
behavior SIFInstruction() 
  u7 channelId;
  select
    case #SIF_REG field u3 regIndex; do channelId := (u7)(GPR.read16(regIndex ) & \x7F); end do
    -- TODO XGCHID not defined yet.
    case #SIF_NO_REG -- channelId := XGCHID{6..0};}
  end select
end behavior

-- return to scheduler and other system instructions.
behavior returnToSchedulerAndOthers() 
  select
    case #BRK
    case #NOP
    case #RTS
  end select
end behavior

------------------------------------------------------------------------------
--Instruction set : syntax view
-----------------------------------------------------------------------------
number syntax binary prefix "0b"
number syntax octal prefix "0"
number syntax hexadecimal prefix "0x"

-- triadic

syntax triadicInstruction #TriadicInst 
  field u3 rs1Index
  field u3 rs2Index
  field u3 rdIndex
  triadicOperation
  " R\d, R\d, R\d", rdIndex, rs1Index, rs2Index
end syntax

syntax orOperation #TriadicInst #OR
  field u3 rs1Index
  field u3 rs2Index
  field u3 rdIndex
  if rs1Index = rs2Index then
    "MOV R\d, R\d", rdIndex, rs1Index
  else
    "OR R\d, R\d, R\d", rdIndex, rs1Index, rs2Index
  end if;
end syntax

syntax subOperation #TriadicInst #SUB
  field u3 rs1Index
  field u3 rs2Index
  field u3 rdIndex
  if rdIndex = 0 then
    "CMP R\d, R\d",rs1Index, rs2Index
  else
    "SUB R\d, R\d, R\d", rdIndex, rs1Index, rs2Index
  end if;
end syntax

syntax triadicOperation 
  select
    case #AND  "AND"
    case #XNOR "XNOR"
    case #SBC  "SBC"
    case #ADD  "ADD"
    case #ADC  "ADC"
  end select
end syntax

-- Logic and artighmetic instructions with immediat

syntax logicImmAndArithImmInstruction #LogArithImm 
  field u3 rdIndex
  field u8 imm8 
  logicImmAndArithImmOperation
  " R\d, #\x", rdIndex, imm8  
end syntax

syntax logicImmAndArithImmOperation 
  select
    case #BITL  "BITL"
    case #BITH  "BITH"
    case #CMPL  "CMPL"
    case #CPCH  "CPCH"
    case #ANDL  "ANDL"
    case #ANDH  "ANDH"
    case #ORL   "ORL"
    case #ORH   "ORH"
    case #XNORL "XNORL"
    case #XNORH "XNORH"
    case #SUBL  "SUBL"
    case #SUBH  "SUBH"
    case #ADDL  "ADDL"
    case #ADDH  "ADDH"
    case #LDL   "LDL"
    case #LDH   "LDH"
  end select
end syntax

-- branch instructions

syntax conditionalBranchOperation  #CondBranch 
  field s10 rel10
  select
    case #BCC "BCC"
    case #BCS "BCS"
    case #BNE "BNE"
    case #BEQ "BEQ"
    case #BPL "BPL"
    case #BMI "BMI"
    case #BVC "BVC"
    case #BVS "BVS"
    case #BHI "BHI"
    case #BLS "BLS"
    case #BGE "BGE"
    case #BLT "BLT"
    case #BGT "BGT"
    case #BLE "BLE"
  end select
  " #\d", rel10>>1
end syntax

syntax unConditionalBranchInstruction #UncondBranch 
  field s11 rel11 
  "BRA #\d", rel11>>1
end syntax

-- load store and bit fields

syntax loadStoreIndirectAndBitFieldInstruction #LSAndBF #LSIAndBF 
  field u3 regIndex
  field u3 rbIndex
  field u3 riIndex 
  select
    case #BFEXT  "BFEXT"
    case #BFINS  "BFINS"
    case #BFINSI "BFINSI"
    case #BFINSX "BFINSX"
  end select
  " R\d, R\d, R\d", regIndex, rbIndex, riIndex 
end syntax

syntax loadStoreWithOffsetInstruction #LSAndBF #LSOFF5 
  field u3 regIndex
  field u3 rbIndex
  field u5 off5
  loadStoreType
  loadStoreSize
  " R\d, R\d, #\x", regIndex, rbIndex, off5
end syntax

syntax loadStoreIndirect #LSAndBF 
  field u3 regIndex
  field u3 rbIndex
  loadStoreType
  loadStoreSize
  " R\d,(R\d, ", regIndex, rbIndex
  loadStoreAddressingMode
end syntax

syntax loadStoreAddressingMode #LSIAndBF 
  field u3 riIndex
  select
    case #PLAIN   "R\d)",riIndex
    case #POSTINC "R\d+)",riIndex
    case #PREDEC  "-R\d)",riIndex
  end select
end syntax

syntax loadStoreSize 
  select
    case #BYTE "B"
    case #WORD "W"
  end select
end syntax

syntax loadStoreType 
  select
    case #LOAD  "LD"
    case #STORE "ST"
  end select
end syntax


-- shift instructions 

syntax shiftInstructionDyadic #SHIFT #ShiftReg 
  field u3 rdIndex
  field u3 rsIndex 
  select
    case #BFFO "BFFO"
    case shiftInstructionImmOperation
  end select
  " R\d, R\d", rdIndex, rsIndex 
end syntax

syntax shiftInstructionImm #SHIFT #IMM4 
  field u3 rdIndex
  field u4 imm4 
  shiftInstructionImmOperation
  " R\d, #\x", rdIndex, imm4
end syntax

syntax shiftInstructionImmOperation 
  select
    case #ASR  "ASR"
    case #CSL  "CSL"
    case #CSR  "CSR"
    case #LSL  "LSL"
    case #LSR  "LSR"
    case #ROL  "ROL"
    case #ROR  "ROR"
  end select
end syntax

-- XGate special instructions

syntax specialMoveInstruction 
  field u3 regIndex
  select
    case #TFR1 "TFR R\d, CCR", regIndex
    case #TFR2 "TFR CCR, R\d", regIndex
    case #TFR3 "TFR R\d, PC", regIndex
  end select
end syntax

syntax singleRegisterInstructions 
  field u3 regIndex 
  select
    case #SEX      "SEX"
    case #PAR      "PAR"
    case #JAL      "JAL"
    case #SIF_REG  "SIF"
  end select
  " R\d", regIndex
end syntax

syntax xGateSpecialInstructionsSemaphoreImm #SemImm 
  field u3 imm
  xGateSpecialSemaphoreOperation
  " #\x", imm
end syntax

syntax xGateSpecialInstructionsSemaphoreReg #SemReg 
  field u3 regIndex 
  xGateSpecialSemaphoreOperation
  " R\d", regIndex
end syntax

syntax xGateSpecialOperation 
  select
    case #BRK         "BRK"
    case #NOP         "NOP"
    case #RTS         "RTS"
    case #SIF_NO_REG  "SIF"
  end select
end syntax

syntax xGateSpecialSemaphoreOperation 
  select
    case #CSEM "CSEM"
    case #SSEM "SSEM"
  end select
end syntax

} -- model XGate2

-- vim:ft=hadl:ts=2:sw=2
