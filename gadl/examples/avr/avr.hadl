model AT90CAN128 {

-- model AT90CAN128 (PC on 16bit in the real CPU, but 17 bits in the description (to use implicit fetch))

default {
    instruction := 16              -- default instruction size
    little endian
    debug := avrgdb
    interrupt := it.hardInterruptHandler
}

include "avrInstructionSet.hadl"



-- Memory -------------------------------------------------

component sram {
  memory ram {
    width   := 16  -- get 16 bits / access
--    address := \x0..\x10FF
    address := \x0..\xFFFF
    type    := RAM

    GPR {
      width   := 16  -- get 16 bits / access
      address := 0..31
      stride  := 1
      type    := register
    }
    register u16 X maps to \x1a
    register u16 Y maps to \x1c
    register u16 Z maps to \x1e

    sfr { -- can be accessed by IN/OUT instructions.
      address := 0..\x3F
      type    := register
    } maps to \x20

--    register u8 EIND  -- not available on the AT90CAN128.
    register u8 RAMPZ maps to \x5b  -- for indirect call.
    register u8  SPH  maps to \x5e  -- stack (high byte)
    register u8  SPL  maps to \x5d  -- stack (low byte)
    register u16 SP   maps to \x5d  -- stack (16 bits)
    register u8  CCR  maps to \x5f{ -- <=> SREG
      C := slice{0} -- carry flag
      Z := slice{1} -- zero flag
      N := slice{2} -- neg flag
      V := slice{3} -- overflow flag
      S := slice{4} -- sign bit
      H := slice{5} -- half carry flag
      T := slice{6} -- Bit copy storage
      I := slice{7} -- global interrupt flag
    }
    register u8 UDR0   maps to \xC6   -- USART0, data byte.
    register u8 UCSR0A maps to \xC0 { -- USART0, control and status
      UDRE0 := slice{5} --empty flag
    }
    -- IO port A.
    register u8 PINA  maps to \x20
    register u8 DDRA  maps to \x21
    register u8 PORTA maps to \x22
    
    -- timer 2
    register u8  TCCR2A maps to \xB0 {
      CS2 := slice{2..0} -- Clock select bits
    }
    register u8 TCNT2 maps to \xB2
    register u8 TIMSK2 maps to \x70 {
      TOIE2 := slice{0}  -- interrupt enable.
    }
  }

  void push(u8 val) {     -- post decrement
    sram.write8(SP, val)
    SP := SP-1
  }

  u8 pop() {
    u8 result
    SP := (u16)(SP+1)
    result := sram.read8(SP)
    return result
  }

--  memory ramExt {
--    width   := 16  -- get 16 bits / access
--    address := \x1500..\xffff
--    type    := RAM
--  }
}

component rom {
  -- access
  program memory flash {
    width   := 16  -- get 16 bits / access
    address := 0..128kb  -- 128k
    type    := ROM
  }
}

component uart {
  void reset() {
    UCSR0A.UDRE0 := 1 -- transmission complete.
  }

  when write on UDR0 do
    print UDR0
    UCSR0A.UDRE0 := 1 -- transmission complete.
  end when
}

component io_portA {
  void reset() {
    PINA  := 0
  PORTA := 0
  DDRA  := 0
  }

  when write on PORTA do
  print "port A: ",(u16)(PORTA),"\n"
  end when
}

-- Timer ----------------------------------------------
component timer2 {
  u16 getPresaler() {
    u16 prescaler
    if     TCCR2A.CS2 = 1 then prescaler := 1
    elseif TCCR2A.CS2 = 2 then prescaler := 8
    elseif TCCR2A.CS2 = 3 then prescaler := 32
    elseif TCCR2A.CS2 = 4 then prescaler := 64
    elseif TCCR2A.CS2 = 5 then prescaler := 128
    elseif TCCR2A.CS2 = 6 then prescaler := 256
    elseif TCCR2A.CS2 = 7 then prescaler := 1024
    end if
    return prescaler
  }

--   every timer2.getPresaler() cycle if (TCCR2A.CS2 != 0) do
--  -> et le prescaler serait relu 
--     * a chaque changement de variable? (pb de detection)
--     * a chaque fois que ca pte? (prise en compte si different).
  every 1024 cycle if (TCCR2A.CS2 != 0) do
    TCNT2 := (u8)(TCNT2 + 1) -- FF to 0 is ok (u8)
    if TCNT2 = 0 then      -- overflow
      if TIMSK2.TOIE2 then   -- local interrupt overflow mask
        interrupt \x14
      end if
    end if
  end every
}

component ALU {

  void updateCCRArithSubWord(u16 rd, u16 rr, u16 result) {
    u1 Rdh7 := rd{15}
    u1 R15  := result{15}
    u1 V  u1 N u1 Z u1 C u1 S
    V := Rdh7 & ~R15
    N := R15
    Z := result{15..0} = 0
    C := R15 & ~Rdh7
    S := N^V
    CCR{4..0} := S cat V cat N cat Z cat C  --TODO: is that more efficent?
  }

  void updateCCRArithWord(u16 rd, u16 rr, u16 result) {
    u1 Rdh7 := rd{15}
    u1 R15  := result{15}
    u1 V  u1 N u1 Z u1 C u1 S
    V := ~Rdh7 & R15
    N := R15
    Z := result{15..0} = 0
    C := ~R15 & Rdh7
    S := N^V
    CCR{4..0} := S cat V cat N cat Z cat C  --TODO: is that more efficent?
  }


  void updateCCRArith(u8 rd, u8 rr, u9 result) {
    u1 Rd3 := rd{3}
    u1 Rr3 := rr{3}
    u1 R3  := result{3}
    u1 Rd7 := rd{7}
    u1 Rr7 := rr{7}
    u1 R7  := result{7}
    u1 H  u1 V  u1 N u1 Z u1 C u1 S
    H := (Rd3 & Rr3) | (Rr3 & ~R3) | (~R3 & Rd3)  --Set if there was a carry from bit 3  cleared otherwise
    V := (Rd7 & Rr7 & ~R7) | (~Rd7 & ~Rr7 & R7)
    N := R7
    Z := result{7..0} = 0
    C := result{8}
    S := N^V
    CCR{5..0} := H cat S cat V cat N cat Z cat C  --TODO: is that more efficent?
  }

  void updateCCRArithSub(u8 rd, u8 rr, u9 result) {
    u1 Rd3 := rd{3}
    u1 Rr3 := rr{3}
    u1 R3  := result{3}
    u1 Rd7 := rd{7}
    u1 Rr7 := rr{7}
    u1 R7  := result{7}
    u1 H  u1 V  u1 N u1 Z u1 C u1 S
    H := (~Rd3 & Rr3) | (Rr3 & R3) | (R3 & ~Rd3)  --Set if there was a carry from bit 3  cleared otherwise
    V := (Rd7 & ~Rr7 & ~R7) | (~Rd7 & Rr7 & R7)
    N := R7
    Z := result{7..0} = 0
    C := result{8}
    S := N^V
    CCR{5..0} := H cat S cat V cat N cat Z cat C  --TODO: is that more efficent?
  }

  void updateCCRArithCpc(u8 rd, u8 rr, u9 result) {
    u1 Rd3 := rd{3}
    u1 Rr3 := rr{3}
    u1 R3  := result{3}
    u1 Rd7 := rd{7}
    u1 Rr7 := rr{7}
    u1 R7  := result{7}
    u1 H  u1 V  u1 N u1 Z u1 C u1 S
    H := (~Rd3 & Rr3) | (Rr3 & R3) | (R3 & ~Rd3)  --Set if there was a carry from bit 3  cleared otherwise
    V := (Rd7 & ~Rr7 & ~R7) | (~Rd7 & Rr7 & R7)
    N := R7
    -- previous value remains unchanged when the result is 0, cleared otherwise.
    Z := (result{7..0} = 0) & CCR.Z
    C := result{8}
    S := N^V
    CCR{5..0} := H cat S cat V cat N cat Z cat C  --TODO: is that more efficent?
  }


  void updateCCRLogic(u8 result) {
    u1 N := result{7}
    CCR{4..1} := N cat 0 cat N cat (result = 0)  --S=N^V, and V=0
  }

  u8 adc(u8 rd, u8 rr) {
    u9 result := (u9)(rd + rr + CCR.C)
    ALU.updateCCRArith(rd, rr, result)
    return result{7..0}
  }

  u8 addition(u8 rd, u8 rr) {
    u9 result
    result := rd + rr
    ALU.updateCCRArith(rd, rr, result)
    return result{7..0}
  }
  u8 sbc(u8 rd, u8 rr) {
    u9 result
    result := rd - rr - CCR.C
    ALU.updateCCRArithCpc(rd, rr, result)
    return result{7..0}
  }
  u8 sub(u8 rd, u8 rr) {
    u9 result
    result := rd - rr
    ALU.updateCCRArithSub(rd, rr, result)
    return result{7..0}
  }
  void cp(u8 rd, u8 rr) { --compare
    u9 result
    result := rd - rr
    ALU.updateCCRArithSub(rd, rr, result)
  }

  void cpc(u8 rd, u8 rr) { --compare with carry
    u9 result
    result := rd - rr - CCR.C
    ALU.updateCCRArithCpc(rd, rr, result)
  }

  u16 adiw(u16 rdValue, u6 imm) {
    u17 result
    result := rdValue+imm
    ALU.updateCCRArithWord(rdValue, imm, result)
    return result{15..0}
  }

  u16 sbiw(u16 rdValue, u6 imm) {
    u17 result
    result := rdValue-imm
    ALU.updateCCRArithSubWord(rdValue, imm, result)
    return result{15..0}
  }

  u8 and(u8 rd, u8 rr) {
    u8 result := (rd & rr)
    ALU.updateCCRLogic(result)
    return result
  }
  u8 eor(u8 rd, u8 rr) { --exclusive or
    u8 result := (rd ^ rr)
    ALU.updateCCRLogic(result)
    return result
  }
  u8 ior(u8 rd, u8 rr) { --inclusive or
    u8 result := (rd | rr)
    ALU.updateCCRLogic(result)
    return result
  }
  u8 asr(u8 rd) { -- arithmetic shift right
    u8 result
    u1 C  u1 Z  u1 N  u1 V  u1 S
    result := (u8)((s8)(rd) >> 1)  --arith shift (should preserve sign)
    C := rd{0}
    Z := result = 0
    N := result {7}
    V := N^C  S:= N^V
    CCR{4..0} := S cat V cat N cat Z cat C
    return result
  }

  u8 com(u8 rd) { -- complement
    u8 result
    u1 Z  u1 N  u1 S
    result := ~rd
    Z := result = 0
    N := result {7}
    S:= N^0
    CCR{4..0} := S cat 0 cat N cat Z cat 1
    return result
  }
  u8 inc(u8 rd) { -- increment.. does not affect CCR.C
    u8 result
    u1 Z  u1 N  u1 V  u1 S
    result := (u8)(rd+1)
    Z := result = 0
    N := result {7}
    V := rd = \x80  --error in instruction set manual equation.
    S:= N^V
    CCR{4..1} := S cat V cat N cat Z
    return result
  }

  u8 dec(u8 rd) { -- decrement.. does not affect CCR.C
    u8 result
    u1 Z  u1 N  u1 V  u1 S
    result := rd-1
    Z := result = 0
    N := result {7}
    V := rd = \x80  --error in instruction set manual equation.
    S:= N^V
    CCR{4..1} := S cat V cat N cat Z
    return result
  }
  u8 lsr(u8 rd) { -- logical shift right
    u8 result
    u1 C  u1 Z  u1 N  u1 V  u1 S
    result := rd >> 1  --arith shift (should preserve sign)
    C := rd{0}
    Z := result = 0
    N := 0
    V := N^C  S:= N^V
    CCR{4..0} := S cat V cat N cat Z cat C
    return result
  }
  u8 neg(u8 rd) { -- 2 complements
    u8 result
    u1 C  u1 Z  u1 N  u1 V  u1 S  u1 H
    if rd != \x80 then result := (u8)(0s-(s8)(rd)) end if
    C := result != 0
    Z := result = 0
    N := result{7}
    V := result = \x80
    S := N^V
    H := result{3} ^ rd{3}
    CCR{5..0} := H cat S cat V cat N cat Z cat C
    return result
  }
  u8 swap(u8 rd) {  --swap nibbles.
    return rd{3..0} cat rd{7..4}
  }
  u8 rorc(u8 rd) { -- ror through carry
    u8 result := rd >> 1
    u1 C  u1 Z  u1 N  u1 V  u1 S
    result{7} := CCR.C
    C := rd{0}
    Z := result = 0
    N := result{7}
    V := N^C
    S := N^V
    CCR{4..0} := S cat V cat N cat Z cat C
    return result
  }

  void updateCCRFMul(u17 result)
  {
    u1 C  u1 Z
    C := result{16}
    Z := result{15..0} = 0
    CCR{1..0} := Z cat C
  }

  u16 fmul(u8 rd, u8 rr) { -- multiplication (unsigned by unsigned)
    u17 result := (rd * rr) << 1
    ALU.updateCCRFMul(result)
    return result{15..0}
  }
  u16 fmuls(u8 rd, u8 rr) { -- multiplication (signed by signed)
    s17 result := ((s8)(rd) * (s8)(rr)) << 1
    ALU.updateCCRFMul(result)
    return result{15..0}
  }

  u16 fmulsu(u8 rd, u8 rr) { -- multiplication (unsigned by signed)
    s17 result := (rd * (s8)(rr)) << 1
    ALU.updateCCRFMul(result)
    return result{15..0}
  }

  void updateCCRMul(u16 result)
  {
    u1 C  u1 Z
    C := result{15}
    Z := result = 0
    CCR{1..0} := Z cat C
  }

  u16 mul(u8 rd, u8 rr) { -- multiplication (unsigned by unsigned)
    u16 result := rd * rr
    ALU.updateCCRMul(result)
    return result
  }

  u16 muls(u8 rd, u8 rr) { -- multiplication (signed by signed)
    s16 result := (s8)(rd) * (s8)(rr)
    ALU.updateCCRMul(result)
    return (u16)(result)
  }

  u16 mulsu(u8 rd, u8 rr) { -- multiplication (unsigned by signed)
    s16 result := rd * (s8)(rr)
    ALU.updateCCRMul(result)
    return (u16)(result)
  }

}

-- Fetch unit ---------------------------------------------

component Fetcher {
  program counter u17 PC

  void reset() {

    u32 val :=0
    u8 test := 4
    u32 mask := \xF000_0000 >> (4*val)
    val{test,0}:=\xFFFFFFFF;

    PC := 0
  }

  -- update the offset and branch.
  void absBranch(s16 offset) {
    PC := (u17)(offset<<1)
  }
  
  void delayInstruction(u16 nb) {
    nop nb instruction
  }
}

--
-- Component for the GDB interface
--
component avrgdb {

 -- Returns the value at the virtual address v_addr.
 -- >= 0x800000 : RAM
 -- <  0x800000 : flash
  u8 read8(u32 v_addr) {
    u8 result
    if v_addr >= \x800000 then
      result := sram.ram.read8(v_addr - \x800000)
    else
      result := rom.flash.read8(v_addr)
    end if
    return result
  }

 -- Writes the value at the virtual address
 -- >= 0x800000 : RAM
 -- <  0x800000 : flash
  void write8(u32 v_addr, u8 val) {
    if v_addr >= \x800000 then
      sram.ram.write8(v_addr - \x800000, val)
    else
      error "Gdb tries to update flash memory!"
    end if
  }

 -- Returns the number of registers required by GDB client
 -- Look the avr-tdep.c file in GDB sources
  u8 getNBRegister() {
    return 35
  }

 -- returns the value and the size (in the GDB protocol) of the register id
 -- Registers id are taken from gdb command info all-registers and gdb sources
  u32 getRegister(u8 id, out u8 sizeInBits) {
    u32 result
    if(id < 32) then
      sizeInBits := 8
      result := sram.ram.GPR.read8(id)
    elseif (id = 32) then
      sizeInBits := 8
      result := CCR
    elseif (id = 33) then
      sizeInBits := 16
      result := SPL << 8 | SPH
    elseif (id = 34) then
      sizeInBits := 32
      -- gdb requires a PC on 32 bits -> points to a byte, like the PC on 17 bits here.
      result := PC{7..0} << 24 | PC{15..8} << 16 | PC{16} << 8
    end if
    return result
  }

 -- Write value in the register id (in the GDB protocol order)
  void setRegister(u8 id, u32 value) {
    if(id < 32)      then sram.ram.GPR.write8(id, value)
    elseif (id = 32) then CCR := value
    elseif (id = 33) then SPH := value{7..0} SPL := value{15..8}
    elseif (id = 34) then PC := value{31..24} | value{23..16} << 8 | value{8} << 16
    end if
  }
}
------------------------------------------------------------------------------
--Temporaire
------------------------------------------------------------------------------

component test {
  register u32 toto
  register u32 XER {
     CA := slice{7..0}
  }
  void my_add(out u32 rd, u32 ra, u32 rb) {
    u33 result
    result := ra + rb
    rd := result{31..0}
  }
  void test2() {
    u10 val1 := 1000
    u32 val2 := (u32)(val1)
    s4  sval := -2s
    u33 val3 := val2 + (u32)(sval)
    val3 := val3 + 1
  }
}

-- Interrupt ----------------------------------------------
component it {
  void hardInterruptHandler(u32 trapId) {
    if CCR.I then -- global mask    
      -- push current PC: no information about the way PC is stored (same as CALL)
      sram.push(PC{8..1})  --as PC is on 17 bits
      sram.push(PC{16..9})
      -- then branch.
      Fetcher.absBranch((s16)(trapId))
--      print "interrupt :",trapId
    end if
  }
}


------------- timing approach (without any pipeline).

cycle allInstruction
  do add 1 cycle end do
end cycle 

cycle adiw #ADIW do add 2 cycle end do end cycle
cycle sbiw #SBIW do add 2 cycle end do end cycle
-- fmul, fmuls, fmulsu, mulsu, mul, muls
cycle mul  #MUL  do add 2 cycle end do end cycle
cycle ijmp #IJMP do add 2 cycle end do end cycle
cycle rjmp #RJMP do add 2 cycle end do end cycle
cycle jmp  #JMP    do add 3 cycle end do end cycle
cycle rcall #RCALL do add 3 cycle end do end cycle
cycle icall #ICALL do add 3 cycle end do end cycle
cycle call #CALL do add 4 cycle end do end cycle
cycle ret  #RET  do add 4 cycle end do end cycle
cycle reti #RETI do add 4 cycle end do end cycle
cycle cpse #CPSE 
  do add 1 cycle end do
  if use Fetcher.delayInstruction then
  -- does not take into account if next instruction is 16 bits
  -- in that last case, an extra cycle is required.
    add 1 cycle
  end if
end cycle
--cycle load
--  #load
--  do add 2 cycle end do
--  select
--  case #preDec do add 1 cycle end do
--  case
--  end select
--end cycle
--
--cycle longCall
--  #LONGCALL
--
--  if use sram.pop then
--      add 100 cycle
--  end if
--
--  if read X do
--    add 100 cycle
--  end if
--
--  do
----  if sram.pop then
--  if jumpTaken then
--    add 100 cycle
--  end if
--  if instruction size = 2 then
--    add 100 cycle
--  end if
--  end do
--end cycle



} -- model avr
-- vim:ft=hadl:ts=2:sw=2
