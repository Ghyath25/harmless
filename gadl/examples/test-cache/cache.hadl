model cache {
-- les composants 'fonctionnels' ne sont dans aucun bloc?
default {
  instruction := 32
  big endian
}
-- composant mem issu de la description du PPC.
component mem {
  -- access
  program memory  ram{
    width   := 32  -- get 32 bits / access
    address := 0..32mb
    type    := RAM
  }
}

-- coprocessor CP15
component cp15 {
  register u32 CP15_R0 -- ID code register
  register u32 CP15_R1 { --control register
    iA := slice{31}  -- Asynchronous clock select
    nF := slice{30}  -- notFastBus select
    RR := slice{14}  -- Round robin replacement
    V  := slice{13}  -- base location of exception registers
    I  := slice{12}  -- ICache enable
    R  := slice{9}   -- ROM protection
    S  := slice{8}   -- System protection
    B  := slice{7}   -- Endianess
    C  := slice{2}   -- DCache enable
    A  := slice{1}   -- Alignment fault enable
    M  := slice{0}   -- MMU enable
  }
  register u32 CP15_R9 -- cache lockdown register.
  void reset()
  {
    CP15_R0 := \x0 -- constant to calculate :-)
    CP15_R1 := 0
    CP15_R9 := 0
  }  
}

component fetcher {
  program counter u32 PC
   
  void reset() {
    PC := 0
  }
}


-- instruction cache of the ARM920T processor:
-- * 16Kb composed of 512 lines of 32 bytes (8 words), 
--   arranged in a 64-way associative cache.
-- * allocate-on-read miss.
-- * Random or Round-robin replacement policy (using RR bit).
-- * instruction locking (granularity of 1/64th of the cache (64 words - 256 bytes)
-- * address is the MVA (Modified Virtual Address, using R13 of coproc CP15)

-- address is split in
-- xxxx xxxx xxxx xxxx xxxx xxxx            tag (24 bits)
--                               xxx        seg  (3 bits) -> choose segment
--                                  x xx    word (3 bits) -> choose word in line
--                                      xx  byte (2 bits)
component ICacheARM920T
{
  -- cache line models 32 bytes (8 words)
  typedef cacheLine {
    u24  tag
    u1   valid
    -- no dirty bits (instruction cache)
    -- no data (not usefull in simulation)
  }
  -- cache segment has 64 lines -> 2048 bytes
  typedef cacheSegment {
    type cacheLine[64] lines
    -- one victim pointer for each segment, for round-robin replacement policy
    -- used for cache locking too.
    u6 victimPointer
  }
  -- cache buffer has 8 segments -> 16384 bytes=16kb
  type cacheSegment[8] cacheBuffer

  register u32 segLock

  -- RAZ all cache buffer.
  void reset()
  {
    u32 seg := 0
    u32 line := 0
    loop 8
    while seg < 8 do
      cacheBuffer[seg].victimPointer := 0
      loop 64
      while line < 64 do
        --cacheBuffer[seg].lines[line] := {0, 0} -- tag et valid.
        cacheBuffer[seg].lines[line].tag := 0
        cacheBuffer[seg].lines[line].valid := 0
        line := line + 1
      end loop
      seg := seg + 1
    end loop
    segLock := 0
  }

  --no write access, this is an instruction cache.
  -- search in a segment: 64 way-associative
  u1 isInCache(u24 tag,u3 seg)
  {
    u6 index := 0 -- current line
    u1 found := false
    type cacheSegment currentCacheSegment := cacheBuffer[seg]
    loop 64
    while index < 64 && !found do
      type cacheLine line := currentCacheSegment.lines[index]
      found := line.valid & (line.tag = tag)
      index := index + 1
    end loop
    return found
  }
  
  void insertInCache(u24 tag,u3 segId)
  {
    if CP15_R1.RR then -- round robin
      type cacheSegment seg := cacheBuffer[segId]
      --seg.lines[seg.victimPointer] := {tag, 1}
      seg.lines[seg.victimPointer].tag   := tag
      seg.lines[seg.victimPointer].valid := true
      -- update victim pointer.
      seg.victimPointer := (seg.victimPointer + 1) & \x3F 
      if seg.victimPointer = 0 then
        seg.victimPointer := segLock
      end if
    else -- random
      -- no explanation of how it works :-/
      -- try with only a global victim pointer.
      type cacheSegment seg := cacheBuffer[segId]
      --seg.lines[cacheBuffer[0].victimPointer] := {tag, 1}
      seg.lines[cacheBuffer[0].victimPointer].tag := tag
      seg.lines[cacheBuffer[0].victimPointer].valid := true

      -- update victim pointer.
      cacheBuffer[0].victimPointer := (cacheBuffer[0].victimPointer + 1) & \x3F 
      if cacheBuffer[0].victimPointer = 0 then
        cacheBuffer[0].victimPointer := segLock
      end if
    end if
  }
  
  u1 readAccess(u32 addr)
  {
    u24 tag  := addr{31..8}
    u3  seg  := addr{7..5}
    u1 hit := ICacheARM920T.isInCache(tag, seg)
    if !hit then
      ICacheARM920T.insertInCache(tag, seg)
    end if
    return hit
  }
}

timing mem
  signal in : memStart
  signal out: memEnd, memVal
{
  u3 nb
  wait for signal memStart
  wait 10 cycle
  emit signal memVal
  nb := 0
  loop 3
  while nb < 3 do
    wait 3 cycle
    emit signal memVal
    nb := nb+1
  end loop
  emit signal memEnd
}

timing ICacheARM920T on activation
  signal in : memEnd
  signal out: memStart
{
  u1 hit
  wait 1 cycle
  hit := ICacheARM920T.readAccess(PC) 
  if !hit then -- miss
      emit signal memStart   -- read 4 bytes
      wait for signal memEnd -- done.
      emit signal memStart   -- read 4 others bytes (to get 1 line).
      wait for signal memEnd -- ok, got the 8 bytes.
  end if
}

architecture Generic 
{
  device DevICacheARM920T : ICacheARM920T {}

  device MemDev : mem {
    read is ram_read8 | ram_read16 | ram_read32 
    write is ram_write8 | ram_write16 | ram_write32
    shared port fetch : read
    shared port loadStore : read or write
  }

  signal {
    -- connection des signaux
    -- signalEmis(out) -> signalRecu(in).
  
    --connect cache to main memory
    MemDev.memEnd              -> DevICacheARM920T.memEnd
    MemDev.memVal              -> *                       --not connected
    DevICacheARM920T.memStart  -> MemDev.memStart
 
    -- connect main memory access to cache.
    -- device.port access -> signalRecu(in)
    -- device.port access -> signalRecu(in) until signalEmis(out)
    -- il faut mettre que c'est le fetch, car suivant le port (et pas l'accès au component)
    -- on ne fait pas référence au même cache (instruction, data).
    -- le port doit être 'shared' (génération du contrôleur) -> ressource externe.
    shared port MemDev.fetch -> DevICacheARM920T
  }
}

} -- model
-- errorformat=%f:%l:%c:%m
-- makeprg=gadl\ \%
-- vim:ft=hadl:ts=2:sw=2:tw=0
