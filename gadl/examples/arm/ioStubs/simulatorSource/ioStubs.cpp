/**
 * generated by HARMLESS : "Hardware ARchitecture Modeling Language
 *                          for Embedded Software Simulation"
 * model : arm_dbg.
 */

#include <iostream>
#include <string>
using namespace std;
#include <stdio.h>

//#define DEBUG_IO_STUBS

#include "ioStubs.h"
#include "arch.h"

bool ioStubOpen::trigger(arch *a)
{
	const u32 arg1 = a->SRU_GPR_read32(0); //depends on the ABI.
	const u32 arg2 = a->SRU_GPR_read32(1);
	const u32 arg3 = a->SRU_GPR_read32(2);
	string name = "";
	int index = 0;
	bool end = false;
	while(!end) //arg1 is a pointer to the file name.
	{
		char val = (char)(a->mem_read8(arg1+(index++))); //depends on the model.
		if(val) name += val;
		else end = true;
	}
	#ifdef DEBUG_IO_STUBS
	cerr << "opening file:" << endl;
	cerr << "file name  : " << name << endl;
	cerr << "flags      : " << hex << arg2 << endl;
	cerr << "mode (oct) : " << oct << arg3 << dec << endl;
	#endif

	//reverse engineering on some basic arguments..
	string fopen_arg = "";
	if(arg2 & 0x600) fopen_arg = "w";
	else if(arg2 & 0x200) fopen_arg = "a";
	else fopen_arg = "r";

	FILE *f = fopen(name.c_str(), fopen_arg.c_str());
	if(f)
	{
		const int fd = fileno(f); //file descriptor.
		//store opened file.
		m_openedFiles[fd] = f;
		//return value is file descriptor.
		a->SRU_GPR_write32(0, (u32)(fd)); //depends on the ABI.
	} else cerr << "cannot open file " << name << endl;
	return false; //do not remove action
}

FILE *ioStubOpen::fileFor(int fd)
{
	map<int , FILE *>::const_iterator itFind = m_openedFiles.find(fd);
	if(itFind != m_openedFiles.end())
	{
		return (*itFind).second;
	} else {
		//not found
		return false;
	}
}

bool ioStubRead::trigger(arch *a)
{
	const u32 arg1 = a->SRU_GPR_read32(0); //file descriptor.
	const u32 arg2 = a->SRU_GPR_read32(1); //ptr
	const u32 arg3 = a->SRU_GPR_read32(2); //len
	
	FILE *f = m_iso->fileFor(arg1);
	if(f)
	{
		//first, read file;
		char *buf = new char[arg3];
		size_t nbVal = fread(buf, 1, arg3, f); //max len values.
		//then copy the value
		for(unsigned int i=0; i<nbVal; i++)
			a->mem_write8(arg2+i, buf[i]);
		#ifdef DEBUG_IO_STUBS
			cerr << "reading " << dec << nbVal << " bytes: " << endl;
		#endif
		delete buf;
		//the return value is the number of bytes read.
		a->SRU_GPR_write32(0, (u32)(nbVal)); //depends on the ABI.
	} else {
		cerr << "File descriptor does not match:" << arg1 << endl;
	}
	return false; //do not remove action
}

//int _writeToFile (int file, char *buf, int len)
bool ioStubWrite::trigger(arch *a)
{
	const u32 arg1 = a->SRU_GPR_read32(0); //file descriptor.
	const u32 arg2 = a->SRU_GPR_read32(1); //buf
	const u32 arg3 = a->SRU_GPR_read32(2); //len
	
	FILE *f = m_iso->fileFor(arg1);
	if(f)
	{
		//first, read the buf in parameter;
		char *buf = new char[arg3];
		for(unsigned int i=0; i<arg3; i++)
			buf[i] = a->mem_read8(arg2+i);
		//then write
		size_t ret = fwrite(buf, 1, arg3, f);
		delete buf;
		//the return value is the number of bytes read.
		a->SRU_GPR_write32(0, (u32)(ret)); //depends on the ABI.
	} else {
		cerr << "File descriptor does not match: " << arg1 << endl;
	}
	return false; //do not remove action
}

//void writechar(char val)
bool ioStubPrintStdout::trigger(arch *a)
{
	const u32 arg1 = a->SRU_GPR_read32(0); //char to write.
	std::cerr << (char)(arg1 & 0xFF) << std::flush;
	return false; //do not remove action
}

