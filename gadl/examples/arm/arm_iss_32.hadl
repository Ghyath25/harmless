--####################################################
--## NOTES :
--## ARMv6 instructions (and linked functions) 
--## are NOT tested or finished yet 
--## because they are not handle in gdb 6.6.
--####################################################

--##==================================================
--## Component description
--##==================================================

model arm_dbg {
-- model arm_opt {

default {
    instruction := 32 -- default instruction size
    little endian
}

component mem {
  -- access
  program memory  ram_ext{
    width   := 32  -- get 32 bits / access
    address := \x81000000 .. \x81afffff -- 10Mb (1Mb in the real target).
    type    := RAM
  }
  
  program memory  ram_int{
    width   := 32  -- get 32 bits / access
    address := \x40000000 .. \x40003fff
    type    := RAM
  }
  
  program memory vector_table {
    width := 32
    address := \x00000000 .. \x0000003f
    type := RAM
  }
  
  program memory registers_control1 {
    width := 32
--    address := \xe0000000 .. \xffffffff -- 536 Mb!!!!
    address := \xE0028000 .. \xE0028013 -- port0 only a dummy serial line.
    type := RAM
    register u32 PORT0PIN maps to \xE0028000
    register u32 PORT0SET maps to \xE0028004
    register u32 PORT0DIR maps to \xE0028008
    register u32 PORT0CLR maps to \xE002800C
    register u32 SERIAL0  maps to \xE0028010
  }
  
  program memory ethernet_control {
    width := 32
    address := \x82000000 .. \x8200000f
    type := RAM
  }
  
  program memory external_flash {
    width := 32
    address := \x80000000 .. \x801fffff
    type := RAM
  }
  
  program memory boot_block1 {
    width := 32
    address := \x7fffe000 .. \x7fffffff
    type := RAM
  }
  
  program memory registers_control2 {
    width := 32
    address := \x3fffc000 .. \x3fffffff
    type := RAM
  }

  program memory extra_space {
    width := 32
    address := \x00040000 .. \x009fffff
    type := RAM
  }

  program memory boot_block2 {
    width := 32
    address := \x0003e000 .. \x0003ffff
    type := RAM
  }
  
  program memory internal_flash {
    width := 32
    address := \x00000040 .. \x0003dfff
    type := RAM
  }
}

-- dummy serial line, debugging purpose.
component SERIAL
{
  when write on SERIAL0 do
    print (s8)(SERIAL0{7..0})
  end when
}

component PORT0
{
  void reset() {
     PORT0PIN  := 0
     PORT0SET  := 0
     PORT0DIR  := 0
     PORT0CLR  := 0
  }

  when write on PORT0SET do
     PORT0PIN := PORT0PIN | PORT0SET
     print "port 0: ",(u32)(PORT0PIN),"\n"
  end when
  
  when write on PORT0CLR do
     PORT0PIN := PORT0PIN & (~PORT0CLR)
     print "port 0: ",(u32)(PORT0PIN),"\n"
  end when

}

-- System Register Unit
component SRU {  

  program counter u32 PC 

  memory GPR {
    width := 32
    address := 0..143
    stride := 4
    type := register
    
--    register u32 SR maps to 13
    register u32 SP maps to 13 -- stack check requirement.
--    register u32 LR maps to 14
    
    -- Fast interrupt request registers maps r8_fiq to 16 and spsr_fiq to 23
    register u32 SPSR_FIQ maps to 23
    -- Interrupt request registers maps r13_irq to 24 and spsr_irq to 26
    register u32 SPSR_IRQ maps to 26
    -- Supervisor registers maps r13_svc to 27 and spsr_svc to 29
    register u32 SPSR_SVC maps to 29
    -- Undefined registers maps r13_undef to 30 and spsr_undef to 32
    register u32 SPSR_UNDEF maps to 32
    -- Abort registers maps r13_abt to 33 and spsr_abt to 35
    register u32 SPSR_ABT maps to 35
  }
    
  register u32 CPSR {
    N := slice{31}
    Z := slice{30}
    C := slice{29}
    V := slice{28}
    Q := slice{27}
    J := slice{24}
    GE := slice{19..16}
    E := slice{9}
    A := slice{8}
    I := slice{7}
    F := slice{6}
    T := slice{5}
    Mode := slice{4..0}
  }
  
  u32 PC_read32() {
    return (u32)(PC + 4)
  }
  
  void PC_write32(u32 value) {
    PC := value
  }
  
  void reset()
  {
    u8 i := 0
    loop 36
    while i < 36 do
      SRU.GPR.write32(i,0)
      i := i+1
    end loop
    PC := 0
    -- mode is supervisor at reset
    CPSR.Mode := \b10011
  }

  -- read a register in bank reg,taking into account the CPSR.Mode
  u32 readR32(u4 regIndex) {
    u5 shift
    u32 ret
    shift := 0
    
    if(regIndex > 12) && (regIndex < 15) then -- R13(SP) and R14(LR)
      if (CPSR.Mode = \b10011) then
        -- Supervisor
        shift := 14
      elseif (CPSR.Mode = \b10001) then
        -- Fast interrupt request
        shift := 8
      elseif (CPSR.Mode = \b10010) then
        -- Interrupt request
        shift := 11
      elseif (CPSR.Mode = \b11011) then
        -- Undefined
        shift := 17
      elseif (CPSR.Mode = \b10111) then
        -- Abort
        shift := 20
      end if
    end if
    
    if regIndex = 15 then
      -- read PC
      ret := SRU.PC_read32()
    else
      ret := SRU.GPR.read32((u6)(regIndex+shift))
    end if
    
    return ret
  }
  
  -- write a register in bank reg,taking into account the CPSR.Mode
  void writeR32(u4 regIndex, u32 value) {
   u5 shift
    
    shift := 0
    
    if (CPSR.Mode = \b10011) then
      -- Supervisor
      if(regIndex > 12) && (regIndex < 15) then
        shift := 14
      end if 
    elseif (CPSR.Mode = \b10001) then
      -- Fast interrupt request
      if(regIndex > 12) && (regIndex < 15) then
        shift := 8
      end if 
    elseif (CPSR.Mode = \b10010) then
      -- Interrupt request
      if(regIndex > 12) && (regIndex < 15) then
        shift := 11
      end if 
    elseif (CPSR.Mode = \b11011) then
      -- Undefined
      if(regIndex > 12) && (regIndex < 15) then
        shift := 17
      end if 
    elseif (CPSR.Mode = \b10111) then
      -- Abort
      if(regIndex > 12) && (regIndex < 15) then
        shift := 20
      end if 
    end if
    
        
    if regIndex = 15 then
      -- write PC
      SRU.PC_write32(value)
    else
      SRU.GPR.write32((u6)(regIndex+shift), value)
    end if
  }
  
  -- read a CPSR taking into account the CPSR.Mode
  u32 CPSR_read32() {
     return CPSR
  }
  
  void CPSR_write32(u32 value) {
    CPSR := value
  }
  
  u1 currentModeHasSPSR() {
    
    return CPSR.Mode != \b11111 && CPSR.Mode != \b10000
  }
  
  u1 inAPrivilegedMode() {
    
    return CPSR.Mode != \b10000
  }
  
  u32 SPSR() {
    u32 spsr
    
    if (CPSR.Mode = \b10011) then
      -- Supervisor
      spsr := SPSR_SVC
    elseif (CPSR.Mode = \b10001) then
      -- Fast interrupt request
      spsr := SPSR_FIQ
    elseif (CPSR.Mode = \b10010) then
      -- Interrupt request
      spsr := SPSR_IRQ
    elseif (CPSR.Mode = \b11011) then
      -- Undefined
      spsr := SPSR_UNDEF
    elseif (CPSR.Mode = \b10111) then
      -- Abort 
      spsr := SPSR_ABT
    end if
    
    return spsr
  }
  
  void setSPSR(u32 value) {

    if (CPSR.Mode = \b10011) then
      -- Supervisor
      SPSR_SVC := value
    elseif (CPSR.Mode = \b10001) then
      -- Fast interrupt request
      SPSR_FIQ := value
    elseif (CPSR.Mode = \b10010) then
      -- Interrupt request
      SPSR_IRQ := value
    elseif (CPSR.Mode = \b11011) then
      -- Undefined
      SPSR_UNDEF := value
    elseif (CPSR.Mode = \b10111) then
      -- Abort 
      SPSR_ABT := value
    end if
  }
  
  -- modify a PC taking into account that ARM_PC = PC + 4
  void PC_addOffset(s24 offset) {
     PC := (u32)(PC+4 + (u32)((s30)(offset) << 2))
  }
  
  void PC_addOffsetHalf(s24 offset, u1 half) {
     PC := (u32)(PC+4 + (u32)((s30)(offset) << 2) + (u2)(half) << 1)
  }
  
  void PC_andOperation(u32 op1, u32 op2) {
     PC := (u32)(op1 & op2)
  }
}

component alu {
  
  u5 numberOfSetBitsIn(u16 value) {
    
    u5 num
    num := 0
    
    num := (u5)(num + (value{0} = 1))
    num := (u5)(num + (value{1} = 1))
    num := (u5)(num + (value{2} = 1))
    num := (u5)(num + (value{3} = 1))
    num := (u5)(num + (value{4} = 1))
    num := (u5)(num + (value{5} = 1))
    num := (u5)(num + (value{6} = 1))
    num := (u5)(num + (value{7} = 1))
    num := (u5)(num + (value{8} = 1))
    num := (u5)(num + (value{9} = 1))
    num := (u5)(num + (value{10} = 1))
    num := (u5)(num + (value{11} = 1))
    num := (u5)(num + (value{12} = 1))
    num := (u5)(num + (value{13} = 1))
    num := (u5)(num + (value{14} = 1))
    num := (u5)(num + (value{15} = 1))
    
    return num
  }
  
  u6 clz(u32 value)
  {
    u1 found := false
    u6 currentBit := 32
    loop 32 
    while (!found && currentBit != 0) do
      if value{currentBit-1} then 
        found := true
      else
        currentBit := currentBit - 1
      end if
    end loop
    return 32 - currentBit
  }
  
  u1 carryFrom(u33 value) {
    return value{32}
  }

  u1 borrowFrom(u32 op1, u32 op2) {
    u34 r := (u34)(op1 + ~op2 + 1)
    return !(r{33}|r{32})
  }
  
  u1 borrowWithCarryFrom(u32 op1, u32 op2, u1 c) {
    u34 r := (u34)(op1 + ~op2 + 1 + ~c)
    return !(r{33}|r{32})
  }
  
  u1 overflowFrom(u32 op1, u32 op2, u32 res) {
    return (op1{31} = op2{31} && res{31} != op1{31})
  }
  
  u1 signedDoesSat(s33 op, u5 sat) {
    
    u1 res
    
    -- min = -2^(n-1)
    s32 min := -(s32)(\x00000001 << (sat-1))
    -- max = 2^(n-1) - 1
    s32 max := (s32)((\x00000001 << (sat-1))-1)
  
    if op < (s33)(min) then
      res := 1  
    elseif op > (s33)(max) then
      res := 1
    else
      res := 0
    end if
  
    return res
  }
  
  s32 signedSat(s33 op, u5 sat) {
    
    s32 res
    
    -- min = -2^(n-1)
    s32 min := -(s32)(\x00000001 << (sat-1))
    -- max = 2^(n-1) - 1
    s32 max := (s32)((\x00000001 << (sat-1))-1)
  
    if op < (s33)(min) then
      res := min  
    elseif op > (s33)(max) then
      res := max
    else
      res := (s32)(op)
    end if
  
    return res
  }
  
  u1 unsignedDoesSat(s33 op, u5 sat) {
    u1 res
    
    -- min = 0
    s32 min := (s32)(0)
    -- max = 2^n - 1
    s32 max := (s32)((\x00000001 << sat)-1)
  
    if op < (s33)(min) then
      res := 1  
    elseif op > (s33)(max) then
      res := 1
    else
      res := 0
    end if
  
    return res
  }
  
  u32 unsignedSat(s33 op, u5 sat) {
    
    u32 res
    
    -- min = 0
    s32 min := (s32)(0)
    -- max = 2^n - 1
    s32 max := (s32)((\x00000001 << sat)-1)
  
    if op < (s33)(min) then
      res := (u32)(min)  
    elseif op > (s33)(max) then
      res := (u32)(max)
    else
      res := (u32)(op)
    end if
  
    return res
  }
  
  -- operations 
  
  u32 adc(u32 rnVal, u32 shifter_operand, u1 c) {
    return (u32)(rnVal + shifter_operand + c)
  }
  
  u32 addition(u32 rnVal, u32 shifter_operand) {
    return (u32)(rnVal + shifter_operand)
  }
  
  u32 and(u32 rnVal, u32 shifter_operand) {
    return rnVal & shifter_operand
  }
  
  u32 bic(u32 rnVal, u32 shifter_operand) {
    return rnVal & ~shifter_operand
  }

  u32 eor(u32 rnVal, u32 shifter_operand) {
    return rnVal ^ shifter_operand
  }
  
  u32 orr(u32 rnVal, u32 shifter_operand) {
    return rnVal | shifter_operand
  }
  
  u32 mov(u32 shifter_operand) {
    return shifter_operand
  }
  
  u32 mvn(u32 shifter_operand) {
    return ~shifter_operand
  }
  
  u32 rsb(u32 shifter_operand, u32 rnVal) {
    return shifter_operand - rnVal
  }
  
  u32 rsc(u32 shifter_operand, u32 rnVal, u1 c) {
    return (shifter_operand - rnVal) - (u1)(~c)
  }
  
  
  u32 sbc(u32 rnVal, u32 shifter_operand, u1 c) {
    return rnVal - shifter_operand - ~CPSR.C
  }
  
  u32 sub(u32 rnVal, u32 shifter_operand) {
    return rnVal - shifter_operand
  }
  
  u32 cmn(u32 rnVal, u32 shifter_operand) {
    return (u32)(rnVal + shifter_operand) 
  }
  
  u32 cmp(u32 rnVal, u32 shifter_operand) {
    return rnVal - shifter_operand
  }
  
  u32 teq(u32 rnVal, u32 shifter_operand) {
    return rnVal ^ shifter_operand
  }
  
  u32 tst(u32 rnVal, u32 shifter_operand) {
    return  rnVal & shifter_operand
  }
  
  u32 usad8(u32 diff1, u32 diff2, u32 diff3, u32 diff4) {
    return (u32)(diff1 + diff2 + diff3 + diff4)
  }
  
  u32 usada8(u32 rnVal, u32 diff1, u32 diff2, u32 diff3, u32 diff4) {
    return (u32)(rnVal + diff1 + diff2 + diff3 + diff4)
  }
   
}

-- mac

component mac {

  u32 mla(u32 rmVal, u32 rsVal, u32 rnVal) {
    return ((rmVal * rsVal) + rnVal){31..0} 
  }
  
  
  u32 mul(u32 rmVal, u32 rsVal) {
    return (rmVal * rsVal){31..0}
  }

  u32 smmla1(u32 rnVal, u64 value) {
    return ((u64)(rnVal)<<32 + value + \x80000000){63..32}
  }
  
  u32 smmla2(u32 rnVal, u64 value) {
    return ((u64)(rnVal)<<32 + value){63..32}
  }
  
  u32 smmls1(u32 rnVal, u64 value) {
    return ((u64)(rnVal)<<32 - value + \x80000000){63..32}
  }
  
  u32 smmls2(u32 rnVal, u64 value) {
    return ((u64)(rnVal)<<32 - value){63..32}
  }
  
  u32 smmul1(u32 rmVal, u32 rsVal) {
    return ((rmVal*rsVal) + \x80000000){63..32}
  }
  
  u32 smmul2(u32 rmVal, u32 rsVal) {
    return (rmVal*rsVal){63..32}
  }
  
  u64 umull(u32 rmVal, u32 rsVal) {
    return (rmVal * rsVal)
  }
  
  u33 umlal(u32 rmVal, u32 rsVal, u32 rdLoVal) {
    return ((rmVal * rsVal){31..0} + rdLoVal)
  }
  
  u64 umall(u32 rmVal, u32 rsVal, u32 rdLoVal, u32 rdHiVal) {
    return (u64)((rmVal * rsVal) + rdLoVal + rdHiVal) 
  }
  
  u64 smull(u32 rmVal, u32 rsVal) {
    return (u64)((s32)(rmVal) * (s32)(rsVal))
  }
  
  u33 smlal(u32 rmVal, u32 rsVal, u32 rdLoVal) {
    return (((s32)(rmVal) * (s32)(rsVal)){31..0} + rdLoVal)
  }
  
  u33 smlalxy(u32 rdLoVal, s32 operand1, s32 operand2) {
    return (rdLoVal + (u32)(operand1 * operand2))
  }
  
  u64 smlald(u64 accvalue, u64 product1, u64 product2) {
    return (u64)(accvalue + product1 + product2) 
  }
  
  u64 smlsld(u64 accvalue, u64 product1, u64 product2) {
    return (u64)(accvalue + product1 - product2) 
  }
  
  u32 smulw(u32 rmVal, u32 operand2) {
    return ((s32)(rmVal) * (s32)(operand2)){47..16}
  }
  
  u32 smlaw(u32 rmVal, u32 operand2, u32 rnVal) {
    return (u32)(((s32)(rmVal) * (s32)(operand2)){47..16} + rnVal)
  }
  
  u32 smulxy(u32 operand1, u32 operand2) {
    return (u32)((s32)(operand1)*(s32)(operand2))
  }
  
  u32 smlaxy(u32 operand1, u32 operand2, u32 rnVal) {
    return (u32)((u64)((s32)(operand1) * (s32)(operand2)) + rnVal)
  }
  
  u32 smu_d(u33 product) {
    return (u32)(product)
  }
  
  u32 sml_d(u33 product, u32 rnVal) {
    return (u32)(product + rnVal)
  }
  
}

-- coprocessor 15
component CP15 {
  
  memory GPR {
    width := 32
    address := 0..64
    stride := 4
    type := register
    
    register u32 CP15_reg0 maps to 0
    register u32 CP15_reg1 maps to 1 {
      M := slice{0}
      A := slice{1}
      W := slice{3}
      S := slice{8}
      R := slice{9}
      U := slice{22}
      XP := slice{23}
      EE := slice{25}
    }
    
    register u32 CP15_reg2 maps to 2
    register u32 CP15_reg3 maps to 3
    register u32 CP15_reg4 maps to 4
    register u32 CP15_reg5 maps to 5
    register u32 CP15_reg6 maps to 6
    register u32 CP15_reg7 maps to 7
    register u32 CP15_reg8 maps to 8
    register u32 CP15_reg9 maps to 9
    register u32 CP15_reg10 maps to 10
    register u32 CP15_reg11 maps to 11
    register u32 CP15_reg12 maps to 12
    register u32 CP15_reg13 maps to 13
    register u32 CP15_reg14 maps to 14
    register u32 CP15_reg15 maps to 15
  }
  
  void reset () {
    CP15_reg1.U := 1
  }
}

--##==================================================
--## Behavior description
--##==================================================

-- conditional instruction
in arm_dbg {
behavior cond_inst (out u1 condPassed)
 
 field u4 condition
 do 
 condPassed := 0 
 
  if condition = 14 then 
    condPassed := 1
  elseif condition = 0 then 
    if CPSR.Z then
      condPassed := 1
    end if
  elseif condition = 1 then 
    if !CPSR.Z then
      condPassed := 1
    end if
  elseif condition = 2 then 
    if CPSR.C then
      condPassed := 1
    end if
  elseif condition = 3 then 
    if !CPSR.C then
      condPassed := 1
    end if
  elseif condition = 4 then 
    if CPSR.N then
      condPassed := 1
    end if
  elseif condition = 5 then 
    if !CPSR.N then
      condPassed := 1
    end if
  elseif condition = 6 then 
    if CPSR.V then
      condPassed := 1
    end if
  elseif condition = 7 then 
    if !CPSR.V then
      condPassed := 1
    end if
  elseif condition = 8 then 
    if CPSR.C && !CPSR.Z then
      condPassed := 1
    end if
  elseif condition = 9 then 
    if !(CPSR.C && !CPSR.Z) then
      condPassed := 1
    end if
  elseif condition = 10 then 
    if CPSR.N = CPSR.V  then
      condPassed := 1
    end if
  elseif condition = 11 then 
    if CPSR.N != CPSR.V then
      condPassed := 1
    end if
  elseif condition = 12 then 
    if !CPSR.Z && CPSR.N = CPSR.V then
      condPassed := 1
    end if
  elseif condition = 13 then 
    if CPSR.Z || CPSR.N != CPSR.V then
      condPassed := 1
    end if
  end if
 end do
end behavior
}

in arm_opt {

behavior cond_inst (out u1 condPassed)

 do 
   condPassed := 0 
 end do 
 
 select
   case #EQ
     do
       if CPSR.Z then
         condPassed := 1
       end if
     end do
   case #NE
     do
       if !CPSR.Z then
         condPassed := 1
       end if
     end do
   case #CS
     do
       if CPSR.C then
         condPassed := 1
       end if
     end do
   case #CC
     do
       if !CPSR.C then
         condPassed := 1
       end if
     end do
   case #MI
     do
       if CPSR.N then
         condPassed := 1
       end if
     end do
   case #PL
     do
       if !CPSR.N then
         condPassed := 1
       end if
     end do
   case #VS
     do
       if CPSR.V then
         condPassed := 1
       end if
     end do
   case #VC
     do
       if !CPSR.V then
         condPassed := 1
       end if
     end do
   case #HI
     do
       if CPSR.C && !CPSR.Z then
         condPassed := 1
       end if
     end do
   case #LS
     do
       if !(CPSR.C && !CPSR.Z) then
         condPassed := 1
       end if
     end do
   case #GE
     do
       if CPSR.N = CPSR.V  then
         condPassed := 1
       end if
     end do
   case #LT
     do
       if CPSR.N != CPSR.V then
         condPassed := 1
       end if
     end do
   case #GT
     do
       if !CPSR.Z && CPSR.N = CPSR.V then
         condPassed := 1
       end if
     end do
   case #LE
     do
       if CPSR.Z || CPSR.N != CPSR.V then
         condPassed := 1
       end if
     end do
   case #AL
     do
       condPassed := 1
     end do
 end select 
 
end behavior 
}

-- Data processing
behavior dataProcessing
  u1 condPassed
  cond_inst(condPassed)
 
  u32 cpsrResult
  u32 shifter_operand
  u1 shifter_carry_out
   
  select
    case #imm32 
      dataProcessingImm32(shifter_operand, shifter_carry_out)
    case #immShift
      dataProcessingImmShift(shifter_operand, shifter_carry_out)
    case #regShift
      dataProcessingRegShift(shifter_operand, shifter_carry_out)
  end select
  
  dataProcessingOperation(condPassed, cpsrResult, shifter_operand, shifter_carry_out)
        
  select
    case #updateCCR
      updateCCR(condPassed, cpsrResult)
    case #noUpdateCCR -- nothing
  end select
     
end behavior

-- Data Processing no dest
behavior dataProcessingNoDest
  u1 condPassed
  cond_inst(condPassed)
 
  u32 cpsrResult
  u32 shifter_operand
  u1 shifter_carry_out
  
  select
    case #imm32 
      dataProcessingImm32(shifter_operand, shifter_carry_out)
    case #immShift
      dataProcessingImmShift(shifter_operand, shifter_carry_out)
    case #regShift
      dataProcessingRegShift(shifter_operand, shifter_carry_out)
  end select
  
  dataProcessingOperationNoDest(condPassed, cpsrResult, shifter_operand, shifter_carry_out)
  
  -- Update obligatoire    
  updateCCR(condPassed, cpsrResult)
     
end behavior

-- Data processing with imm32
behavior dataProcessingImm32(out u32 shifter_operand, out u1 shifter_carry_out)

  field u8 immed_8
  field u4 rotate_imm
 
  do 
    shifter_operand := (u32)(immed_8) ror (rotate_imm*2)
    
    if rotate_imm = 0 then
      shifter_carry_out := CPSR.C
    else
      shifter_carry_out := shifter_operand{31} 
    end if
  end do

end behavior

-- Data processing with immShift
behavior dataProcessingImmShift(out u32 shifter_operand, out u1 shifter_carry_out)

  field u5 shift_imm
  field u2 shift
  field u4 Rm
  
  u32 rmVal
  
  do
    rmVal := SRU.readR32(Rm)
  
    if shift = 0 then
      -- Logical Shift Left
      if shift_imm = 0 then 
        shifter_operand := rmVal
        shifter_carry_out := CPSR.C
      else 
        shifter_operand := rmVal << shift_imm
        shifter_carry_out := rmVal{32 - shift_imm}
      end if
    
    elseif shift = 1 then
      -- Logical Shift Right
      if shift_imm = 0 then
        shifter_operand := 0 
        shifter_carry_out := rmVal{31}
      else
        shifter_operand := rmVal >> shift_imm 
        shifter_carry_out := rmVal{shift_imm - 1}
      end if
      
    elseif shift = 2 then
      -- Arithmetic Shift Right
      if shift_imm = 0 then 
        if rmVal{31} = 0 then
          shifter_operand := 0
          shifter_carry_out := rmVal{31} 
        else
          -- Rm{31} = 1
          shifter_operand := \xFFFFFFFF
          shifter_carry_out := rmVal{31}
        end if 
      else 
        -- shift_imm > 0
        shifter_operand := (u32)((s32)(rmVal) >> shift_imm)
        shifter_carry_out := rmVal{shift_imm - 1}
      end if
      
    else
      -- (shift = 3) Rotate Right
      if shift_imm = 0 then 
        shifter_operand := ((u32)(CPSR.C) << 31) | (rmVal >> 1) 
        shifter_carry_out := rmVal{0}
      else
        shifter_operand := rmVal ror shift_imm 
        shifter_carry_out := rmVal{shift_imm - 1}
      end if
    end if
  end do
  
end behavior

-- Data processing with regShift
behavior dataProcessingRegShift(out u32 shifter_operand, out u1 shifter_carry_out)

  field u4 Rs
  field u2 shift
  field u4 Rm
  
  u32 rmVal
  u32 rsVal
  
  do
    rmVal := SRU.readR32(Rm)
    rsVal := SRU.readR32(Rs)
    
    if shift = 0 then
      -- Logical Shift Left
      if rsVal{7..0} = 0 then 
        shifter_operand := rmVal 
        shifter_carry_out := CPSR.C
      elseif rsVal{7..0} < 32 then 
        shifter_operand := rmVal << rsVal{7..0} 
        shifter_carry_out := rmVal{32 - rsVal{7..0}}
      elseif rsVal{7..0} = 32 then 
        shifter_operand := 0 
        shifter_carry_out := rmVal{0}
      else
        shifter_operand := 0
        shifter_carry_out := 0
      end if
      
    elseif shift = 1 then 
      -- Logical Shift Right
      if rsVal{7..0} = 0 then 
        shifter_operand := rmVal 
        shifter_carry_out := CPSR.C
      elseif rsVal{7..0} < 32 then 
        shifter_operand := rmVal >> rsVal{7..0} 
        shifter_carry_out := rmVal{rsVal{7..0} - 1}
      elseif rsVal{7..0} = 32 then 
        shifter_operand := 0 
        shifter_carry_out := rmVal{31}
      else 
        shifter_operand := 0 
        shifter_carry_out := 0
      end if
      
    elseif shift = 2 then 
      -- Arithmetic Shift Right
      if rsVal{7..0} = 0 then 
        shifter_operand := rmVal 
        shifter_carry_out := CPSR.C
      elseif rsVal{7..0} < 32 then 
        shifter_operand := (u32)((s32)(rmVal) >> rsVal{7..0}) 
        shifter_carry_out := rmVal{rsVal{7..0} - 1}
      else
        if rmVal{31} = 0 then
          shifter_operand := 0
          shifter_carry_out := rmVal{31}
        else
          shifter_operand := \xFFFFFFFF
          shifter_carry_out := rmVal{31}
        end if
      end if
    else
      -- (shift = 3) Rotate Right
      if rsVal{7..0} = 0 then 
        shifter_operand := rmVal 
        shifter_carry_out := CPSR.C
      elseif rsVal{4..0} = 0 then 
        shifter_operand := rmVal 
        shifter_carry_out := rmVal{31}
      else 
        shifter_operand := rmVal ror rsVal{4..0} 
        shifter_carry_out := rmVal{rsVal{4..0} - 1}
      end if
    end if
  end do

end behavior

-- Data processing operation
behavior dataProcessingOperation(u1 condPassed, out u32 cpsrResult, u32 shifter_operand, u1 shifter_carry_out)
  field u4 Rd 
  field u4 Rn 
  u32 result
  u32 rnVal
  
  do
    cpsrResult := CPSR
    rnVal := SRU.readR32(Rn)
  end do
  
  select
    case #ADC
      do
        result := alu.adc(rnVal, shifter_operand, CPSR.C)
          
        if Rd != 15 then
          cpsrResult{29} := alu.carryFrom((u33)(rnVal + shifter_operand + CPSR.C))
          cpsrResult{28} := alu.overflowFrom(rnVal, shifter_operand, result)
        end if
      end do
    case #ADD
      do
        result := alu.addition(rnVal, shifter_operand) 

        if Rd != 15 then
          cpsrResult{29} := alu.carryFrom((u33)(rnVal + shifter_operand))
          cpsrResult{28} := alu.overflowFrom(rnVal, shifter_operand, result)
        end if
      end do
    case #AND
      do
        result := alu.and(rnVal, shifter_operand)
          
        if Rd != 15 then
          cpsrResult{29} := shifter_carry_out -- C
        end if
       end do
    case #BIC
      do    
        result := alu.bic(rnVal, shifter_operand)

        if Rd != 15 then
          cpsrResult{29} := shifter_carry_out -- C
        end if
      end do
    case #EOR
      do    
        result := alu.eor(rnVal, shifter_operand)
          
        if Rd != 15 then
          cpsrResult{29} := shifter_carry_out -- C
        end if
      end do
    case #ORR
      do    
        result := alu.orr(rnVal, shifter_operand)
          
        if Rd != 15 then
          cpsrResult{29} := shifter_carry_out -- C
        end if
      end do
     case #MOV
      do    
        result := alu.mov(shifter_operand)
          
        if Rd != 15 then
          cpsrResult{29} := shifter_carry_out -- C
        end if
      end do
    case #MVN
      do    
        result := alu.mvn(shifter_operand)  
          
        if Rd != 15 then
          cpsrResult{29} := shifter_carry_out -- C
        end if
      end do
    case #RSB
      do    
        result := alu.rsb(shifter_operand, rnVal)
          
        if Rd != 15 then
          cpsrResult{29} := ~alu.borrowFrom(shifter_operand, rnVal) 
          cpsrResult{28} := alu.overflowFrom(shifter_operand, ~rnVal, result)
        end if
      end do
      case #RSC
      do    
        result := alu.rsc(shifter_operand, rnVal, CPSR.C)

        if Rd != 15 then
          cpsrResult{29} := ~alu.borrowWithCarryFrom(shifter_operand, rnVal, ~CPSR.C) 
          cpsrResult{28} := alu.overflowFrom(shifter_operand, ~rnVal, result)
        end if
      end do
    case #SBC
      do    
        result := alu.sbc(rnVal, shifter_operand, CPSR.C)
          
        if Rd != 15 then
          cpsrResult{29} := ~alu.borrowWithCarryFrom(rnVal, shifter_operand, ~(CPSR.C)) 
          cpsrResult{28} := alu.overflowFrom(rnVal, ~shifter_operand, result)
        end if
      end do
    case #SUB
      do    
        result := alu.sub(rnVal, shifter_operand)
          
        if Rd != 15 then
          cpsrResult{29} := ~alu.borrowFrom(rnVal, shifter_operand) 
          cpsrResult{28} := alu.overflowFrom(rnVal, ~shifter_operand, result)
        end if
      end do
  end select
    
  do    
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
    
    if Rd = 15 then
      if SRU.currentModeHasSPSR() then 
        cpsrResult := SRU.SPSR()
--      else 
--        warning "UNPREDICTABLE"
      end if 
    else 
      cpsrResult{31} := result{31} -- N
      cpsrResult{30} := (result=0) -- Z
    end if
  end do
end behavior

-- Data processing operation no dest
behavior dataProcessingOperationNoDest(u1 condPassed, out u32 cpsrResult, u32 shifter_operand, u1 shifter_carry_out)

  field u4 Rn 
  u32 result
  
  u32 rnVal
  
  do
    rnVal := SRU.readR32(Rn)
    cpsrResult := CPSR
  end do
 
  select
     case #CMN
      do    
        result := alu.cmn(rnVal, shifter_operand)
          
        cpsrResult{29} := alu.carryFrom((u33)(rnVal + shifter_operand))
        cpsrResult{28} := alu.overflowFrom(rnVal, shifter_operand, result)     
      end do
    case #CMP
      do    
        result := alu.cmp(rnVal, shifter_operand)
          
        cpsrResult{29} := ~alu.borrowFrom(rnVal, shifter_operand)
        cpsrResult{28} := alu.overflowFrom(rnVal, ~shifter_operand, result)     
      end do
    case #TEQ
      do    
        result := alu.teq(rnVal, shifter_operand)
          
        cpsrResult{29} := shifter_carry_out   
      end do
    case #TST
      do    
        result := alu.tst(rnVal, shifter_operand)
          
        cpsrResult{29} := shifter_carry_out   
      end do
  end select
  
  
  do
    cpsrResult{31} := result{31} -- N       
    cpsrResult{30} := (result = 0) -- Z
  end do
end behavior

-- Branch
behavior branchInst #branch
  field s24 offset
  u1 condPassed
  cond_inst(condPassed)

  select
    case #withLink  #SP_Check
      do
        if condPassed then
          SRU.writeR32(14, (u32)(instruction address + 4)) -- address after current instruction
          SRU.PC_addOffset(offset)
        end if
      end do
    case #noLink
      do
        if condPassed then
          SRU.PC_addOffset(offset)
        end if
      end do
  end select
 
end behavior

-- Branch and exchange
behavior branchLinkExchangeInst #branch  

  select
    case #abs #withLink #Thumb
      -- BLX(1)
      field u1 half
      field s24 offset
      do
        SRU.writeR32(14, (u32)(instruction address + 4)) 
        CPSR.T := 1 
        SRU.PC_addOffsetHalf(offset, half)
      end do
    case #rel
      -- BLX(2)
      field u4 Rm
      u1 condPassed
      cond_inst(condPassed)
      u32 rmVal
      select
        case #Thumb
        case #Jazelle
      end select
      do
        rmVal := SRU.readR32(Rm)
        if condPassed then
          CPSR.T := rmVal{0}
          SRU.PC_andOperation(rmVal, \xFFFFFFFE)
        end if
      end do
      select
        case #withLink do
            if condPassed then
              SRU.writeR32(14, (u32)(instruction address + 4))
            end if
          end do
        case #noLink
      end select
  end select

end behavior

-- Update PCSR 
behavior updateCCR(u1 condPassed, u32 cpsrResult)
  do
    if condPassed then
      CPSR := cpsrResult
    end if
  end do
end behavior

-- LoadStore instructions
behavior loadStore
  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rn
  u32 addressLS
  u32 adr
  
  select
   case #immediatOffset
     loadStoreImmediatOffset(adr, Rn)
   case #scaledRegisterOffset
     loadStoreScaledRegisterOffset(adr, Rn)
   case #noImm
     loadStoreMiscellaneousNoImm(adr, Rn)
   case #Imm
     loadStoreMiscellaneousImm(adr, Rn)
  end select
  
  select
    case #W #P
      -- pre
      do
        addressLS := adr
        if condPassed then
          SRU.writeR32(Rn, adr)
        end if
      end do
      
      loadStoreOperation(condPassed, addressLS)
    case #noW #noP
      -- post
      do        
        addressLS := SRU.readR32(Rn)
        if condPassed then
          SRU.writeR32(Rn, adr)
        end if
      end do
      
      
      loadStoreOperation(condPassed, addressLS)
    case #noW #P 
      do
        addressLS := adr
      end do
      
      
      loadStoreOperation(condPassed, addressLS)
    case #W #noP
      -- post but only supported by LDRBT, LDRT, STRBT, and STRT
      do        
        addressLS := SRU.readR32(Rn)
        if condPassed then
          SRU.writeR32(Rn, adr)
        end if
      end do
      
      loadStoreOperationTranslation(condPassed, addressLS)
  end select
  
end behavior

-- LoadStore with immediat offset
behavior loadStoreImmediatOffset (out u32 addressLS, u4 Rn)

  field u12 offset_12
  
  select
    case #addOffset 
      do
        addressLS := (u32)(SRU.readR32(Rn) + offset_12)
      end do
    case #subOffset 
      do
        addressLS := SRU.readR32(Rn) - offset_12
      end do
  end select
  
end behavior

-- LoadStore with scaled register offset
behavior loadStoreScaledRegisterOffset (out u32 addressLS, u4 Rn)

  field u4 Rm
  field u5 shift_imm
  field u2 shift
  
  u32 rmVal
  u32 index
  
  do
    rmVal := SRU.readR32(Rm)
    
    if shift = 0 then 
      -- LSL
      index := rmVal << shift_imm 
    elseif shift = 1 then
      -- LSR
      if shift_imm = 0 then 
        -- LSR #32 
        index := 0
      else 
        index := rmVal >> shift_imm
      end if
    elseif shift = 2 then 
      -- ASR 
      if shift_imm = 0 then 
        -- ASR #32
        if rmVal{31} = 1 then 
          index := \xFFFFFFFF
        else 
          index := 0
        end if
      else 
        index := (u32)((s32)(rmVal) >> shift_imm)
      end if
    elseif shift = 3 then
      -- ROR or RRX 
      if shift_imm = 0 then 
        -- RRX
        index := (CPSR.C << 31) | (rmVal >> 1)
      else 
        -- ROR
        index := rmVal ror shift_imm
      end if
    end if
  end do

  select
    case #addOffset
      do
        addressLS := (u32)(SRU.readR32(Rn) + index) 
      end do
    case #subOffset
      do
        addressLS := SRU.readR32(Rn) - index
      end do
  end select
end behavior

-- LoadStore miscellaneous with immediat
behavior loadStoreMiscellaneousImm(out u32 addressLS, u4 Rn)

  field u8 imm
  
  u4 immedH
  u4 immedL
  u8 offset_8
  
  do
    immedH := imm{7..4}
    immedL := imm{3..0}
    
    offset_8 := (immedH << 4) | immedL  
  end do
  
  select
    case #addOffset
      do
        addressLS := (u32)(SRU.readR32(Rn) + offset_8) 
      end do
    case #subOffset
      do
        addressLS := SRU.readR32(Rn) - offset_8
      end do
  end select


end behavior

-- LoadStore miscellaneous with register
behavior loadStoreMiscellaneousNoImm(out u32 addressLS, u4 Rn)

  field u4 Rm
 
  select
    case #addOffset
      do
        addressLS := (u32)(SRU.readR32(Rn) + SRU.readR32(Rm)) 
      end do
    case #subOffset
      do
        addressLS := SRU.readR32(Rn) - SRU.readR32(Rm)
      end do
  end select


end behavior

-- LoadStore operation
behavior loadStoreOperation(u1 condPassed, u32 addressLS)

  field u4 Rd
  
  select
    case #Word #Load
      -- LDR
      u32 data
      do
        if condPassed then
          
          if (CP15_reg1.U = 0) then 
            data := mem.read32(addressLS) ror (8 * addressLS{1..0})
          else
            data := mem.read32(addressLS)
          end if
          
          if (Rd = 15) then 
            --if (ARMv5 or above) then
              PC := data & \xFFFFFFFE
              CPSR.T := data{0} 
            --else
              --PC := data & \xFFFFFFFC 
          else 
             SRU.writeR32(Rd, data)
          end if
        end if
      end do
    case #Byte #Load
      -- LDRB
      do
        if condPassed then
          SRU.writeR32(Rd, (u32)(mem.read8(addressLS)))
        end if
      end do
    case #Word #Store
      -- STR
      do
        if condPassed then
          mem.write32(addressLS, SRU.readR32(Rd)) 
        end if
      end do
    case #Byte #Store
      -- STRB
      do
        if condPassed then
          mem.write8(addressLS, SRU.GPR.read8(Rd)) 
        end if
      end do
    case #doubleword #Load
      -- LDRD
      do
        if condPassed then 
          if (Rd%2 =0) && (Rd != 14) && (addressLS{1..0} = \b00) && ((CP15_reg1.U = 1) || (addressLS = 0)) then 
            SRU.writeR32(Rd, mem.read32(addressLS))
            SRU.writeR32((u4)(Rd+1), mem.read32((u32)(addressLS+4))) 
--          else
--            warning "UNPREDICTABLE"
          end if
        end if
      end do
    case #halfword #Load #unsigned #priviledge
      -- LDRH
      u16 data
      do
        if condPassed then
          if (CP15_reg1.U = 0) then 
            if addressLS{0} = 0 then
              data := mem.read16(addressLS) 
--            else
--              warning "UNPREDICTABLE" 
            end if
          else
            data := mem.read16(addressLS) 
          end if
          
          SRU.writeR32(Rd, (u32)(data{15..0}))
       end if
     end do
    case #Byte #signed #Load #priviledge
      -- LDRSB
      u8 data
      do
        if condPassed then
          data := mem.read8(addressLS) 
          SRU.writeR32(Rd, (u32)((s32)(data)))
        end if
      end do
    case #signed #halfword #Load #priviledge
      -- LDRSH
      u16 data
      do
        if condPassed then
          if (CP15_reg1.U = 0) then 
            if addressLS{0} = 0 then
              data := mem.read16(addressLS) 
--            else
--              warning "UNPREDICTABLE"
            end if
          else
            data := mem.read16(addressLS) 
          end if
          
          SRU.writeR32(Rd, (u32)((s32)(data)))
        end if
      end do
    case #doubleword #Store
      -- STRD
      do
        if condPassed then
          if (Rd%2 = 0) && (Rd != 14) && (addressLS{1..0} = \b00) && ((CP15_reg1.U = 1) || (addressLS{2} = 0)) then 
            mem.write32(addressLS, SRU.readR32(Rd)) 
            mem.write32((u32)(addressLS+4), SRU.readR32((u4)(Rd+1)))
--          else 
--            warning "UNPREDICTABLE"
          end if
        end if
      end do
    case #halfword #priviledge #Store
      -- STRH
      do
        if condPassed then
          if (CP15_reg1.U = 0) then 
            if addressLS{0} = 0 then
              mem.write16(addressLS, SRU.GPR.read16(Rd))
--            else
--              warning "UNPREDICTABLE"
            end if
          else
            mem.write16(addressLS, SRU.GPR.read16(Rd))
          end if
        end if
      end do
  end select

end behavior

-- LoadStore operation with translation
behavior loadStoreOperationTranslation(u1 condPassed, u32 addressLS)

  field u4 Rd
  field u4 Rn
  
  select
    case #Word #Load
      -- LDRT
      do
        if condPassed then
          if (CP15_reg1.U = 0) then 
            SRU.writeR32(Rd, mem.read32(addressLS) ror (8 * addressLS{1..0}))
          else
            SRU.writeR32(Rd, mem.read32(addressLS))
          end if
        end if
      end do
    case #Byte #Load
      -- LDRBT
      do
        if condPassed then 
          SRU.writeR32(Rd, (u32)(mem.read8(addressLS)))
          --SRU.writeR32(Rn, addressLS)
        end if
      end do
    case #Word #Store
      -- STRT
      do
        if condPassed then
          mem.write32(addressLS, SRU.readR32(Rd)) 
        end if
      end do
    case #Byte #Store
      -- STRBT
      do
        if condPassed then
          mem.write8(addressLS, SRU.readR32(Rd){7..0})
        end if
      end do
  end select

end behavior

--load/store exclusive
format LoadStoreExclusive
  condition
  Rn := slice{19..16}
  Rd := slice{15..12}
  select slice {27..21,11..8,7..4}
    case \b0001100_1111_1001 is #EX
      select slice {20}
        case 0 is #Store
          Rm := slice{3..0}
        case 1 is #Load
          select slice {3..0} -- Rm not used and set to SBO
            case \b1111 is
          end select
      end select
  end select
end format

behavior loadStoreExclusive #EX
  u1 condPassed
  cond_inst(condPassed)
 
  field u4 Rn
  field u4 Rd

  select
    case #Store
      -- STREX
      field u4 Rm
      do
        if condPassed then
          mem.write32(SRU.readR32(Rn), SRU.readR32(Rm)) 
          SRU.writeR32(Rd, 0)    
        end if
      end do
    case #Load
      -- LDREX
      do
        if condPassed then
          SRU.writeR32(Rd, mem.read32(SRU.readR32(Rn)))
        end if
      end do
  end select
end behavior

-- LoadStore multiple
behavior loadStoreMultiple
  u1 condPassed
  cond_inst(condPassed)
  
  field u16 regList
   
  u32 start_address
  u32 end_address

  select
    case #noP #addOffset
      -- IA
      loadStoreMultipleIA(condPassed, regList, start_address, end_address)
    case #P #addOffset
      -- IB
      loadStoreMultipleIB(condPassed, regList, start_address, end_address)
    case #noP #subOffset
      -- DA
      loadStoreMultipleDA(condPassed, regList, start_address, end_address)
    case #P #subOffset
      -- DB
      loadStoreMultipleDB(condPassed, regList, start_address, end_address)
  end select
  
  select
    case #Load
      select
        case #noS
          -- LDM(1)
          u32 addressLS
          u32 value
          
          loadMultipleRegs(condPassed, start_address, regList, 0, addressLS)
          do
            if condPassed then
              
              if regList{15} = 1 then 
                value := mem.read32(addressLS) 
                --if (architecture version 5 or above) then
                  PC := value & \xFFFFFFFE
                  CPSR.T := value{0} 
                --else
                  --PC := value & \xFFFFFFFC 
              end if
            end if
          end do
        case #S
          -- LDM(2)(3)
          u32 addressLS
          u32 value
          
          loadMultipleRegs(condPassed, start_address, regList, 1, addressLS)
          
          do
            if regList{15} = 1 then
              -- LDM(3)
              if condPassed then
                if SRU.currentModeHasSPSR() then 
                  CPSR := SRU.SPSR()
--                else 
--                  warning "UNPREDICTABLE"
                end if
                
                value := mem.read32(addressLS) 
                PC := value 
              end if
            end if
          end do
      end select
    case #Store
      select
        case #noS
          -- STM(1)
          storeMultipleRegs(condPassed, start_address, regList, 0)
        case #S
          -- STM(2)
          storeMultipleRegs(condPassed, start_address, regList, 1)
      end select
  end select
end behavior

-- load multiple regs
behavior loadMultipleRegs(u1 condPassed, u32 addressP, u16 regList, u1 r_usr, out u32 addressEnd)
  
  u32 addressLS
  do
  if condPassed then
    addressLS := addressP
  
    if (regList{0} = 1) then
      if r_usr then
        SRU.GPR.write32(0, mem.read32(addressLS))
      else
        SRU.writeR32(0, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{1} = 1) then
      if r_usr then
        SRU.GPR.write32(1, mem.read32(addressLS))
      else
        SRU.writeR32(1, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{2} = 1) then
      if r_usr then
        SRU.GPR.write32(2, mem.read32(addressLS))
      else
        SRU.writeR32(2, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{3} = 1) then
      if r_usr then
        SRU.GPR.write32(3, mem.read32(addressLS))
      else
        SRU.writeR32(3, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{4} = 1) then
      if r_usr then
        SRU.GPR.write32(4, mem.read32(addressLS))
      else
        SRU.writeR32(4, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{5} = 1) then
      if r_usr then
        SRU.GPR.write32(5, mem.read32(addressLS))
      else
        SRU.writeR32(5, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{6} = 1) then
      if r_usr then
        SRU.GPR.write32(6, mem.read32(addressLS))
      else
        SRU.writeR32(6, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{7} = 1) then
      if r_usr then
        SRU.GPR.write32(7, mem.read32(addressLS))
      else
        SRU.writeR32(7, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{8} = 1) then
      if r_usr then
        SRU.GPR.write32(8, mem.read32(addressLS))
      else
        SRU.writeR32(8, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{9} = 1) then
      if r_usr then
        SRU.GPR.write32(9, mem.read32(addressLS))
      else
        SRU.writeR32(9, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{10} = 1) then
      if r_usr then
        SRU.GPR.write32(10, mem.read32(addressLS))
      else
        SRU.writeR32(10, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{11} = 1) then
      if r_usr then
        SRU.GPR.write32(11, mem.read32(addressLS))
      else
        SRU.writeR32(11, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{12} = 1) then
      if r_usr then
        SRU.GPR.write32(12, mem.read32(addressLS))
      else
        SRU.writeR32(12, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{13} = 1) then
      if r_usr then
        SRU.GPR.write32(13, mem.read32(addressLS))
      else
        SRU.writeR32(13, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{14} = 1) then
      if r_usr then
        SRU.GPR.write32(14, mem.read32(addressLS))
      else
        SRU.writeR32(14, mem.read32(addressLS))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
  end if
  
  addressEnd := addressLS
  end do
  
end behavior

-- store multiple regs
behavior storeMultipleRegs (u1 condPassed, u32 addressP, u16 regList, u1 r_usr)
  
  u32 addressLS
  do
  if condPassed then
    addressLS := addressP
    
    if (regList{0} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(0))
      else
        mem.write32(addressLS, SRU.readR32(0))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{1} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(1))
      else
        mem.write32(addressLS, SRU.readR32(1))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{2} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(2))
      else
        mem.write32(addressLS, SRU.readR32(2))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{3} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(3))
      else
        mem.write32(addressLS, SRU.readR32(3))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{4} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(4))
      else
        mem.write32(addressLS, SRU.readR32(4))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{5} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(5))
      else
        mem.write32(addressLS, SRU.readR32(5))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{6} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(6))
      else
        mem.write32(addressLS, SRU.readR32(6))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{7} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(7))
      else
        mem.write32(addressLS, SRU.readR32(7))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{8} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(8))
      else
        mem.write32(addressLS, SRU.readR32(8))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{9} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(9))
      else
        mem.write32(addressLS, SRU.readR32(9))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{10} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(10))
      else
        mem.write32(addressLS, SRU.readR32(10))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{11} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(11))
      else
        mem.write32(addressLS, SRU.readR32(11))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{12} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(12))
      else
        mem.write32(addressLS, SRU.readR32(12))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{13} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(13))
      else
        mem.write32(addressLS, SRU.readR32(13))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{14} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(14))
      else
        mem.write32(addressLS, SRU.readR32(14))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
    if (regList{15} = 1) then
      if r_usr then
        mem.write32(addressLS, SRU.GPR.read32(15))
      else
        mem.write32(addressLS, SRU.readR32(15))
      end if
      addressLS := (u32)(addressLS + 4)
    end if
  end if
  end do

end behavior

-- loadStore multiple increment after
behavior loadStoreMultipleIA(u1 condPassed, u16 regList, out u32 start_address, out u32 end_address)
  
  field u4 Rn
  u32 rnVal
  
  do
    rnVal := SRU.readR32(Rn)
    
    start_address := rnVal 
    end_address := (u32)(rnVal + (alu.numberOfSetBitsIn(regList) * 4) - 4) 
  end do
  
  select 
    case #W
      do
        if condPassed then
          SRU.writeR32(Rn, (u32)(rnVal + (alu.numberOfSetBitsIn(regList) * 4)))
        end if
      end do
    case #noW -- nothing
  end select
end behavior

-- loadStore multiple increment before
behavior loadStoreMultipleIB(u1 condPassed, u16 regList, out u32 start_address, out u32 end_address)
  
  field u4 Rn
  u32 rnVal
  
  do
    rnVal := SRU.readR32(Rn)
    
    start_address := (u32)(rnVal + 4)
    end_address := (u32)(rnVal + (alu.numberOfSetBitsIn(regList) * 4))
  end do
  
  select 
    case #W
      do
        if condPassed then
          SRU.writeR32(Rn, (u32)(rnVal + (alu.numberOfSetBitsIn(regList) * 4)))
        end if
      end do
    case #noW -- nothing
  end select

end behavior

-- loadStore multiple decrement after
behavior loadStoreMultipleDA(u1 condPassed, u16 regList, out u32 start_address, out u32 end_address)
  
  field u4 Rn
  u32 rnVal
  
  do
    rnVal := SRU.readR32(Rn)
    
    start_address := (u32)(rnVal - (alu.numberOfSetBitsIn(regList) * 4) + 4)
    end_address := rnVal
  end do
  
  select 
    case #W
      do
        if condPassed then
          SRU.writeR32(Rn, rnVal - (alu.numberOfSetBitsIn(regList) * 4))
        end if
      end do
    case #noW -- nothing
  end select

end behavior

-- loadStore multiple decrement before
behavior loadStoreMultipleDB(u1 condPassed, u16 regList, out u32 start_address, out u32 end_address)
  
  field u4 Rn
  u32 rnVal
  
  do
    rnVal := SRU.readR32(Rn)
    
    start_address := rnVal - (alu.numberOfSetBitsIn(regList) * 4)
    end_address := rnVal - 4
  end do
  
  select 
    case #W
      do
        if condPassed then
          SRU.writeR32(Rn, start_address)
        end if
      end do
    case #noW -- nothing
  end select

end behavior


-- mul
behavior mul
  u1 condPassed
  cond_inst(condPassed)
  
  u32 cpsrResult
  
  mulOperation(condPassed, cpsrResult)
        
  select
    case #S
      updateCCR(condPassed, cpsrResult)
    case #noS -- nothing
  end select

end behavior

-- mul operation
behavior mulOperation(u1 condPassed, out u32 cpsrResult)
  field u4 Rs
  field u4 Rm

  select
    case #mul
      mulOperationMul(condPassed, cpsrResult)
    case #LongMul
      mulOperationLongMul(condPassed, cpsrResult)
    case #signed #smlal
      mulOperationSmlal(condPassed, cpsrResult)
    case #dual #long #Acc
      mulOperationSmlaldSmlsld(condPassed, cpsrResult)
  end select
  
end behavior

-- mul operation for normal mul (+ signed & dual)
behavior mulOperationMul(u1 condPassed, out u32 cpsrResult)
  
  field u4 Rd
  field u4 Rs
  field u4 Rm
  
  u32 result
  u32 rsVal
  u32 rmVal
  
  do
    cpsrResult := CPSR
    rsVal := SRU.readR32(Rs)
    rmVal := SRU.readR32(Rm)
  end do
  
  select
    case #Acc
      -- mla
      field u4 Rn
      u32 rnVal
      
      do
        rnVal := SRU.readR32(Rn)
        
        result := mac.mla(rmVal, rsVal, rnVal)
        
        cpsrResult{31} := result{31} -- N
        cpsrResult{30} := (result = 0) -- Z
      end do
      
    case #noAcc
      -- mul
      do
        result := mac.mul(rmVal, rsVal)
        cpsrResult{31} := result{31} -- N
        cpsrResult{30} := (result = 0) -- Z 
      end do
    case #dual
      field u1 x
      u32 operand2
      u32 product1
      u32 product2
      u33 product
      
      do
        if x = 1 then
          operand2 := rsVal ror 16 
        else
          operand2 := rsVal
        end if 
        
        product1 := rmVal{15..0} * operand2{15..0} 
        product2 := rmVal{31..16} * operand2{31..16} 
      end do
      
      select 
        case #add
          -- smuad, smlad
          do
            product := product1 + product2
          end do
        case #sub
          -- smusd, smlsd
          do
            product := product1 - product2
          end do
      end select
      
      select
        case #noLong #Acc
          -- smlad, smlsd
          field u4 Rn
          u32 rnVal
          
          do
            rnVal := SRU.readR32(Rn)
            result := mac.sml_d(product, rnVal) 
          end do
          
          select
            case #add
              do
                if alu.overflowFrom(rnVal, product1, result) && alu.overflowFrom(rnVal, product2, result) then
                  cpsrResult{27} := 1 -- Q
                end if
              end do
            case #sub
              do
                if alu.overflowFrom(rnVal, product1, result) && alu.overflowFrom(rnVal, ~product2, result) then
                  cpsrResult{27} := 1 -- Q
                end if
              end do
          end select
        case #noLong #noAcc
          -- smuad, smusd
          do
            result := mac.smu_d(product)
          end do 
          
          select
            case #add
              do
                if alu.overflowFrom(product1, product2, result) then
                  cpsrResult{27} := 1 -- Q
                end if
              end do
            case #sub -- nothing
          end select
      end select
    case #signed
     
      field u1 y
      u32 operand2
    
      do
        if (y = 0) then 
          operand2 := (u32)((s32)(rsVal{15..0}))
        else
          operand2 := (u32)((s32)(rsVal{31..16}))
        end if
      end do
          
      select
        case #Acc
          field u1 x
          field u4 Rn
          
          u32 operand1
          u32 rnVal
          
          -- smlaxy
          do
            rnVal := SRU.readR32(Rn)
          
            if (x = 0) then 
              operand1 := (u32)((s32)(rmVal{15..0}))
            else
              operand1 := (u32)((s32)(rmVal{31..16}))
            end if
          
            result := mac.smlaxy(operand1, operand2, rnVal) 
            
            if alu.overflowFrom(operand1, operand2, result) && alu.overflowFrom(operand1, rnVal, result) then
              cpsrResult{27} := 1 -- Q
            end if
          end do
        case #noAcc
          -- smulxy
          field u1 x
          u32 operand1
          
          do
            if (x = 0) then 
              operand1 := (u32)((s32)(rmVal{15..0}))
            else
              operand1 := (u32)((s32)(rmVal{31..16}))
            end if
            
            result := mac.smulxy(operand1, operand2)
          end do
          
        case #word #Acc
          -- smlaw
          field u4 Rn
          u32 rnVal
          
          do
            rnVal := SRU.read32(Rn)
            
            result := mac.smlaw(rmVal, operand2, rnVal)

            if alu.overflowFrom(rmVal, operand2, result) && alu.overflowFrom(rmVal, rnVal, result) then
              cpsrResult{27} := 1 -- Q
            end if
          end do
        
        case #word #noAcc
          -- smulw
          do
            result := mac.smulw(rmVal, operand2)
          end do
          
      end select
    case #signed #msw #Acc
        
          field u1 r
          field u4 Rn
          u64 value
          u32 rnVal
          
          do
            rnVal := SRU.read32(Rn)
            value := (u64)((s32)(rmVal) * (s32)(rsVal))
          end do
          
          select
            case #add
              -- smmla
              do
                if r = 1 then
                  result := mac.smmla1(rnVal, value)
                else
                  result := mac.smmla2(rnVal, value)
                end if
              end do
            case #sub
              -- smmls
              do
                if r = 1 then
                  result := mac.smmls1(rnVal, value) 
                else
                  result := mac.smmls2(rnVal, value)
                end if
              end do
          end select
    case #signed #msw #noAcc
      -- smmul
      field u1 r
          
      do
        if r = 1 then
          result := mac.smmul1(rmVal, rsVal)
        else
          result := mac.smmul2(rmVal, rsVal)  
        end if
      end do
  end select
  
  do
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
  end do
  
end behavior

-- mul operation for long mul
behavior mulOperationLongMul(u1 condPassed, out u32 cpsrResult)

  field u4 RdHi
  field u4 RdLo
  field u4 Rm
  field u4 Rs
  u32 rmVal
  u32 rsVal
  u32 resHi
  u32 resLo
  
  do
    cpsrResult := CPSR
    rmVal := SRU.read32(Rm)
    rsVal := SRU.read32(Rs)
  end do
  
  select
    case #unsigned #noAcc
      -- umull
      u64 value
      do
        value := mac.umull(rmVal, rsVal)
        resHi := value{63..32} 
        resLo := value{31..0}
      end do
    case #unsigned #Acc
      -- umlal
      u32 rdLoVal
      u32 rdHiVal
      u33 value
      do
        rdLoVal := SRU.readR32(RdLo)
        rdHiVal := SRU.readR32(RdHi)
        
        value := mac.umlal(rmVal, rsVal, rdLoVal)
        
        resLo := (u32)(value)
        resHi := (u32)((rmVal * rsVal){63..32} + rdHiVal + alu.carryFrom(value))
      end do
    case #unsigned #umall
      -- umall
      u32 rdLoVal
      u32 rdHiVal
      u64 result
      do
        rdLoVal := SRU.readR32(RdLo)
        rdHiVal := SRU.readR32(RdHi)
        result := mac.umall(rmVal, rsVal, rdLoVal, rdHiVal) 
        resLo := result{31..0} 
        resHi := result{63..32}
      end do
    case #signed #noAcc
      -- smull
      u64 result
      do
        result := mac.smull(rmVal, rsVal)
        resHi := result{63..32} 
        resLo := result{31..0} 
      end do
    case #signed #Acc
      -- smlal
      u32 rdLoVal
      u32 rdHiVal
      u33 result
      do
        rdLoVal := SRU.readR32(RdLo)
        rdHiVal := SRU.readR32(RdHi)
        result := mac.smlal(rmVal, rsVal, rdLoVal)
        resLo := (u32)(result)
        resHi := (u32)(((s32)(rmVal) * (s32)(rsVal)){63..32} + rdHiVal + alu.carryFrom(result))
      end do
  end select
  
  do
    if condPassed then
      SRU.writeR32(RdHi, resHi)
      SRU.writeR32(RdLo, resLo)
    end if
  end do
   
  do  
    cpsrResult{31} := resHi{31} -- N
    cpsrResult{30} := ((resHi = 0) && (resLo = 0)) -- Z
  end do
  
end behavior

-- mul operation for smlalxy
behavior mulOperationSmlal(u1 condPassed, out u32 cpsrResult)
  
  field u4 RdLo
  field u4 RdHi
  field u4 Rm
  field u4 Rs
  field u1 x
  field u1 y
  
  u32 rdLoVal
  u32 rdHiVal
  u32 rmVal
  u32 rsVal
  
  u32 resLo
  u32 resHi
  u33 result
  
  s32 operand1
  s32 operand2

  do
    cpsrResult := CPSR
    rmVal := SRU.readR32(Rm)
    rsVal := SRU.readR32(Rs)
  
    if (x = 0) then 
      operand1 := (s32)(rmVal{15..0})
    else
      operand1 := (s32)(rmVal{31..16})
    end if
    
    if (y = 0) then
      operand2 := (s32)(rsVal{15..0})
    else 
      operand2 := (s32)(rsVal{31..16})
    end if
    
    result := mac.smlalxy(rdLoVal, operand1, operand2)    
    resLo := (u32)(result) 
    if((u64)(operand1*operand2) < (u64)(0)) then
      resHi := (u32)(rdHiVal + \xFFFFFFFF + alu.carryFrom(result))
    else
      resHi := (u32)(rdHiVal + alu.carryFrom(result))
    end if

    if condPassed then
      SRU.writeR32(RdLo, resLo)
      SRU.writeR32(RdHi, resHi)
    end if  
  
    cpsrResult{31} := resHi{31} -- N
    cpsrResult{30} := ((resHi = 0) && (resLo = 0)) -- Z
  end do
  
  
end behavior


-- mul operation for smlald and smlsld
behavior mulOperationSmlaldSmlsld(u1 condPassed, out u32 cpsrResult)
   
  field u1 x
  field u4 Rs
  field u4 RdLo
  field u4 RdHi
  field u4 Rm
  
  u32 rsVal
  u32 rmVal
  u32 rdLoVal
  u32 rdHiVal
  u32 operand2
  u64 accvalue
  u64 product1
  u64 product2
  u64 result
  
  do
    cpsrResult := CPSR
  
    rsVal := SRU.readR32(Rs)
    rmVal := SRU.readR32(Rm)
    rdLoVal := SRU.readR32(RdLo)
    rdHiVal := SRU.readR32(RdHi)
    
    if x = 1 then
      operand2 := rsVal ror 16 
    else
      operand2 := rsVal 
    end if
    
    accvalue{31..0} := rdLoVal
    accvalue{63..32} := rdHiVal
  
    product1 := (u64)((s64)((s16)(rmVal{15..0}) * (s16)(operand2{15..0})))
    product2 := (u64)((s64)((s16)(rmVal{31..16}) * (s16)(operand2{31..16})))
  end do
  
  select
    case #add
      do
        result := mac.smlald(accvalue, product1, product2)
      end do
    case #sub
      do
        result := mac.smlsld(accvalue, product1, product2)
      end do
  end select
  
  do
    if condPassed then 
      SRU.writeR32(RdLo, result{31..0})
      SRU.writeR32(RdHi, result{63..32})
    end if
  end do
end behavior

-- swap operation
behavior swapOperation #swap
 
  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rd
  field u4 Rn
  field u4 Rm
  
  u32 temp
  u32 rnVal
  u32 rmVal
  
  do
    rnVal := SRU.readR32(Rn)
    rmVal := SRU.readR32(Rm)
  end do
  
  select
    case #word
      -- swp
      do
        if condPassed then
          if (CP15_reg1.U = 0) then 
            temp := mem.read32(rnVal) ror (8 * rnVal{1..0}) 
            mem.write32(rnVal, rmVal)
          else
            temp := mem.read32(rnVal) 
            mem.write32(rnVal, rmVal)
          end if
        end if
      end do
    case #byte
      -- swpb
      do
        if condPassed then
          temp := mem.read8(rnVal) 
          mem.write8(rnVal, rmVal{7..0})
        end if 
      end do
  end select
  
  do
    if condPassed then
      SRU.writeR32(Rd, temp)
    end if
  end do

end behavior

-- instruction bkpt
behavior bkptInst #bkpt
  
  field u16 immed
  
  do
    --if (not overridden by debug hardware) then
      SRU.GPR.write32(34, (u32)(instruction address + 4)) -- R14_abt
      SPSR_ABT := CPSR 
      CPSR{4..0} := \b10111 
      CPSR{5} := 0
      CPSR{7} := 1
      CPSR{8} := 1
      CPSR{9} := CP15_reg1.EE
    
      --if high vectors configured then
        PC := \xFFFF000C 
      --else
      --  PC = 0x0000000C
      --end if
    --end if
  end do
end behavior

-- instruction swi
behavior swiInstr #swi
  u1 condPassed
  cond_inst(condPassed)
  field u24 swi

  do
    if condPassed then 
      SRU.GPR.write32(28, (u32)(instruction address + 4)) -- R14_svc
      SPSR_SVC := CPSR 
      CPSR.Mode := \b10011 
      CPSR.T := 0
      CPSR.I := 1
      CPSR.E := CP15_reg1.EE
    
      --if high vectors configured then
      --  PC := \xFFFF0008 
      --else
      --  PC := \x00000008
        PC := \x40000008
      --end if
    end if
  end do
end behavior

-- instruction setend
behavior setendInstr #setend

  field u1 e
  
  do
    CPSR.E := e
  end do
end behavior

-- instruction msr
behavior msrInst #msr
  
  -- v4T, v5T constants
  u32 UnallocMask := \x0FFFFF00
  u32 UserMask :=    \xF0000000
  u32 PrivMask :=    \x0000000F
  u32 StateMask :=   \x00000020
  
  u1 condPassed
  cond_inst(condPassed)
  
  u32 operand
  u32 mask
  u32 byte_mask
  field u1 r
  field u4 field_mask

  select
    case #reg
      field u4 Rm
      do
        operand := SRU.readR32(Rm) 
      end do
    case #imm
      field u8 immed_8
      field u4 rotate_imm
      do
        operand := immed_8 ror (rotate_imm * 2) 
      end do
  end select

  do
--    if (operand & UnallocMask) !=0 then
--       warning "UNPREDICTABLE" -- Attempt to set reserved bits 
--    end if
  
    if field_mask{0} = 1 then 
      byte_mask := \x000000FF 
    else 
      byte_mask := \x00000000
    end if
     
    if field_mask{1} = 1 then 
      byte_mask := byte_mask | \x0000FF00 
    end if
    
    if field_mask{2} = 1 then 
      byte_mask := byte_mask | \x00FF0000 
    end if
    
    if field_mask{3} = 1 then 
      byte_mask := byte_mask | \xFF000000 
    end if
    
    if r = 0 then
      if SRU.inAPrivilegedMode() then 
        if (operand & StateMask) != 0 then
          warning "UNPREDICTABLE" -- Attempt to set non-ARM execution state 
        else
          mask := byte_mask & (UserMask | PrivMask)
        end if
      else 
        mask := byte_mask & UserMask
      end if
    
      if condPassed then
        CPSR := (CPSR & ~mask) | (operand & mask) 
      end if
    else
      if SRU.currentModeHasSPSR() then 
        mask := byte_mask & (UserMask | PrivMask | StateMask) 
        
        if condPassed then
          SRU.setSPSR((SRU.SPSR() & ~mask) | (operand & mask))
        end if
--      else 
--        warning "UNPREDICTABLE"
      end if
    end if
  end do
end behavior

-- instruction mrs
behavior mrsInst #mrs

  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rd
  field u1 r
  
  do
    if condPassed then 
      if r = 1 then
        SRU.writeR32(Rd, SRU.SPSR())
      else
        SRU.writeR32(Rd, CPSR)
      end if
    end if
  end do
end behavior

-- instruction cps
behavior cpsInst #cps
   field u2 imod
   field u1 mmod
   field u1 a
   field u1 i
   field u1 f
   field u5 mode
      
  do
    --if InAPrivilegedMode() then 
      if imod{1} = 1 then
        if a = 1 then 
          CPSR{8} := imod{0} 
        end if
        if i = 1 then 
          CPSR{7} := imod{0} 
        end if
        if f = 1 then 
          CPSR{6} := imod{0}
        end if
      end if
     
      if mmod = 1 then
          CPSR{4..0} := mode
      end if
    --end if
  end do

end behavior

-- extend instructions
behavior extendInst #extend
  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rm
  field u2 rot
  u32 operand2
  
  do
    operand2 := SRU.readR32(Rm) ror (8 * rot)
  end do
  
  select
    case #unsigned
      select
        case #b16
          do
            operand2 := operand2 & \x00ff00ff
          end do
          extendB16Operation(condPassed, operand2)
        case #b
          do
            operand2 := operand2 & \x000000ff
          end do
          extendOperation(condPassed, operand2)
        case #h
          do
            operand2 := operand2 & \x0000ffff
          end do
          extendOperation(condPassed, operand2)
      end select
    case #signed -- nothing
      select
        case #b16
          extendB16Operation(condPassed, operand2)
        case #b
          do
            operand2 := (u32)((s32)(operand2{7..0}))
          end do
          extendOperation(condPassed, operand2)
        case #h
          do
            operand2 := (u32)((s32)(operand2{15..0}))
          end do
          extendOperation(condPassed, operand2)
      end select  
  end select
end behavior

-- extend operation (sxtab, sxtah, sxtb, sxth, uxtab, uxtah, uxtb, uxth)
behavior extendOperation(u1 condPassed, u32 operand2)

  field u4 Rd
  u32 result
  
  select
    case #Acc
      field u4 Rn
      u32 rnVal
      
      do
        rnVal := SRU.readR32(Rn)
        result := (u32)(rnVal + operand2)
      end do
    case #noAcc
      do
        result := operand2
      end do
  end select

  do
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
  end do

end behavior

-- extend b16 operation (sxtab16, sxtb16, uxtab16, uxtb16)
behavior extendB16Operation(u1 condPassed, u32 operand2)

  field u4 Rd
  u16 op1
  u16 op2
  u32 result
 
  select
    case #signed
      do
        op1 := (u16)((s16)(operand2{7..0}))
        op2 := (u16)((s16)(operand2{23..16}))
      end do
    case #unsigned
      do
        op1 := operand2{15..0}
        op2 := operand2{31..16}
      end do
  end select
 
  select
    case #Acc
      field u4 Rn
      u32 rnVal
      
      do
        rnVal := SRU.readR32(Rn)
        result{15..0} := (u16)(rnVal{15..0} + op1)
        result{31..16} := (u16)(rnVal{31..16} + op2)
      end do
    case #noAcc
      do
        result{15..0} := op1
        result{31..16} := op2
      end do
  end select

  do
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
  end do

end behavior

-- parallel instruction
behavior parallelInst
  u1 condPassed
  cond_inst(condPassed)
  
  select 
    case #S16
      parallelInstS16(condPassed)
    case #S8
      parallelInstS8(condPassed)
    case #addsubx
      parallelInstAddSubX(condPassed)
    case #subaddx
      parallelInstSubAddX(condPassed)
  end select

end behavior

-- parallel instruction with s16 ({S|Q|SH|U|UQ|UH}{ADD|SUB}16)
behavior parallelInstS16(u1 condPassed)
  
  field u4 Rd
  field u4 Rm
  field u4 Rn
  
  u32 rmVal
  u32 rnVal
  
  u17 res15_0
  u17 res31_16
  
  u32 res
  
  select
    case #add
      do
        res15_0 := rnVal{15..0} + rmVal{15..0}
        res31_16 := rnVal{31..16} + rmVal{31..16}
      end do
    case #sub
      do
        res15_0 := rnVal{15..0} - rmVal{15..0}
        res31_16 := rnVal{31..16} - rmVal{31..16}
      end do
  end select
  
  select
    case #S
      --sadd16, ssub16
      do
        if condPassed then
          res{15..0} := res15_0{15..0} 
          
          if (s16)(res15_0) >= (s16)(0) then
            CPSR.GE{1..0} := \b11 
          else 
            CPSR.GE{1..0} := 0
          end if 
          
          res{31..16} := res31_16{15..0}
          
          if (s16)(res31_16) >= (s16)(0) then
            CPSR.GE{3..2} := \b11 
          else 
            CPSR.GE{3..2} := 0
          end if 
        end if
      end do
    case #Q
      --qadd16, qsub16
      do
         --res{15..0} := alu.signedSat((s17)(res15_0), 16) 
         --res{31..16} := alu.signedSat((s17)(res31_16), 16)
      end do
    case #SH
      --shadd16, shsub16
      do
        res{15..0} := res15_0{16..1} 
        res{31..16} := res31_16{16..1}
      end do
    case #U
      select
        case #add
          --uadd16
          do
            --CPSR.GE{1..0} := if CarryFrom16(Rn[15:0] + Rm[15:0]) == 1 then 0b11 else 0 
            --CPSR.GE{3..2} := if CarryFrom16(Rn[31:16] + Rm[31:16]) == 1 then 0b11 else 0
          end do
        case #sub
          --usub16
          do
            --CPSR.GE{1..0} := if BorrowFrom(Rn[15:0] - Rm[15:0]) then 0 else 0b11 
            --CPSR.GE{3..2} := if BorrowFrom(Rn[31:16] - Rm[31:16]) then 0 else 0b11 
          end do
      end select
    case #UQ
      --uqadd16, uqsub16
      do
        --res{15..0} := alu.unsignedSat(res15_0, 16) 
        --res{31..16} := alu.unsignedSat(res31_16, 16)
      end do
    case #UH
      --uhadd16, uhsub16
      do
        res{15..0} := res15_0{16..1} 
        res{31..16} := res31_16{16..1}
      end do
  end select
 
  do
    SRU.writeR32(Rd, res)
  end do
end behavior

-- parallel instruction with s8 ({S|Q|SH|U|UQ|UH}{ADD|SUB}8)
behavior parallelInstS8(u1 condPassed)

  field u4 Rd
  field u4 Rm
  field u4 Rn
  
  u32 rmVal
  u32 rnVal
  
  u9 res7_0
  u9 res15_8
  u9 res23_16
  u9 res31_24
  
  u32 res
  
  select
    case #add
      do
        res7_0 := rnVal{7..0} + rmVal{7..0}
        res15_8 := rnVal{15..8} + rmVal{15..8}
        res23_16 := rnVal{23..16} + rmVal{23..16}
        res31_24 := rnVal{31..24} + rmVal{31..24}
      end do
    case #sub
      do
        res7_0 := rnVal{7..0} - rmVal{7..0}
        res15_8 := rnVal{15..8} - rmVal{15..8}
        res23_16 := rnVal{23..16} - rmVal{23..16}
        res31_24 := rnVal{31..24} - rmVal{31..24}
      end do
  end select
  
  select
    case #S
      --sadd8, ssub8
      do
        if condPassed then
          res{7..0} := res7_0{7..0} 
          CPSR.GE{0} := ((s8)(res7_0) >= (s8)(0))
          
          res{15..8} := res15_8{7..0} 
          CPSR.GE{1} := ((s8)(res15_8) >= (s8)(0))
          
          res{23..16} := res23_16{7..0} 
          CPSR.GE{2} := ((s8)(res23_16) >= (s8)(0))
          
          res{23..16} := res23_16{7..0} 
          CPSR.GE{3} := ((s8)(res23_16) >= (s8)(0))
        end if
      end do
    case #Q
      --qadd8, qsub8
      do
         --res{7..0} := alu.signedSat((s9)(res7_0), 8) 
         --res{15..8} := alu.signedSat((s9)(res15_8), 8) 
         --res{23..16} := alu.signedSat((s9)(res23_16), 8)
         --res{31..24} := alu.signedSat((s9)(res31_24), 8)
      end do
    case #SH
      --shadd8, shsub8
      do
        res{7..0} := res7_0{8..1} 
        res{15..8} := res15_8{8..1} 
        res{23..16} := res23_16{8..1} 
        res{31..24} := res31_24{8..1}
      end do
    case #U
      select
        case #add
          --uadd8
          do
            res{7..0} := res7_0{7..0} 
            res{15..8} := res15_8{7..0}
            res{23..16} := res23_16{7..0} 
            res{31..24} := res31_24{7..0} 
            --CPSR.GE{0} := CarryFrom8(Rn[7:0] + Rm[7:0])
            --CPSR.GE{1} := CarryFrom8(Rn[15:8] + Rm[15:8])
            --CPSR.GE{2} := CarryFrom8(Rn[23:16] + Rm[23:16])
            --CPSR.GE{3} := CarryFrom8(Rn[31:24] + Rm[31:24])
          end do
        case #sub
          --usub8
          do
            res{7..0} := res7_0{7..0} 
            res{15..8} := res15_8{7..0}
            res{23..16} := res23_16{7..0} 
            res{31..24} := res31_24{7..0} 
            --CPSR.GE{0} := ~BorrowFrom(Rn[7:0] - Rm [7:0])
            --CPSR.GE{1} := ~BorrowFrom(Rn[15:8] - Rm [15:8])
            --CPSR.GE{2} := ~BorrowFrom(Rn[23:16] - Rm [23:16])
            --CPSR.GE{3} := ~BorrowFrom(Rn[31:24] - Rm [31:24]) 
          end do
      end select
    case #UQ
      --uqadd8, uqsub8
      do
        --res{7..0} := alu.unsignedSat(res7_0, 8) 
         --res{15..8} := alu.unsignedSat(res15_8, 8) 
         --res{23..16} := alu.unsignedSat(res23_16, 8)
         --res{31..24} := alu.unsignedSat(res31_24, 8)
      end do
    case #UH
      --uhadd8, uhsub8
      do
        res{7..0} := res7_0{8..1} 
        res{15..8} := res15_8{8..1} 
        res{23..16} := res23_16{8..1} 
        res{31..24} := res31_24{8..1}
      end do
  end select
 
  do
    SRU.writeR32(Rd, res)
  end do
  
end behavior

-- parallel instruction with add sub ({S|Q|SH|U|UQ|UH}ADDSUBX)
behavior parallelInstAddSubX(u1 condPassed)
  
  field u4 Rd
  field u4 Rm
  field u4 Rn
  
  u32 rmVal
  u32 rnVal
  
  u17 res15_0
  u17 res31_16
  
  u32 res

  do
        res15_0 := rnVal{15..0} - rmVal{31..16}
        res31_16 := rnVal{31..16} + rmVal{15..0}
  end do
  
  select
    case #S
      --saddsubx
      do
        if condPassed then
          res{15..0} := res15_0{15..0} 
          
          if (s16)(res15_0) >= (s16)(0) then
            CPSR.GE{1..0} := \b11 
          else 
            CPSR.GE{1..0} := 0
          end if 
          
          res{31..16} := res31_16{15..0}
          
          if (s16)(res31_16) >= (s16)(0) then
            CPSR.GE{3..2} := \b11 
          else 
            CPSR.GE{3..2} := 0
          end if 
        end if
      end do
    case #Q
      --qaddsubx
      do
         --res{15..0} := alu.signedSat((s17)(res15_0), 16) 
         --res{31..16} := alu.signedSat((s17)(res31_16), 16)
      end do
    case #SH
      --shaddsubx
      do
        res{15..0} := res15_0{16..1} 
        res{31..16} := res31_16{16..1}
      end do
    case #U
      --uaddsubx
      do
        res{15..0} := res15_0{15..0} 
        res{31..16} := res31_16{15..0}
        --CPSR.GE{1..0} := if BorrowFrom16(Rn[15:0] - Rm[31:16]) == 1 then 0b11 else 0 
        --CPSR.GE{3..2} := if CarryFrom16(Rn[31:16] + Rm[15:0]) == 1 then 0b11 else 0
      end do
    case #UQ
      --uqaddsubx
      do
        --res{15..0} := alu.unsignedSat(res15_0, 16) 
        --res{31..16} := alu.unsignedSat(res31_16, 16)
      end do
    case #UH
      --uhaddsubx
      do
        res{15..0} := res15_0{16..1} 
        res{31..16} := res31_16{16..1}
      end do
  end select
 
  do
    SRU.writeR32(Rd, res)
  end do

end behavior

-- parallel instruction with sub add ({S|Q|SH|U|UQ|UH}SUBAdX
behavior parallelInstSubAddX(u1 condPassed)
  field u4 Rd
  field u4 Rm
  field u4 Rn
  
  u32 rmVal
  u32 rnVal
  
  u17 res15_0
  u17 res31_16
  
  u32 res

  do
    res15_0 := rnVal{15..0} + rmVal{31..16}
    res31_16 := rnVal{31..16} - rmVal{15..0}
  end do
  
  select
    case #S
      --ssubaddx
      do
        if condPassed then
          res{15..0} := res15_0{15..0} 
          
          if (s16)(res15_0) >= (s16)(0) then
            CPSR.GE{1..0} := \b11 
          else 
            CPSR.GE{1..0} := 0
          end if 
          
          res{31..16} := res31_16{15..0}
          
          if (s16)(res31_16) >= (s16)(0) then
            CPSR.GE{3..2} := \b11 
          else 
            CPSR.GE{3..2} := 0
          end if 
        end if
      end do
    case #Q
      --qsubaddx
      do
         --res{15..0} := alu.signedSat((s17)(res15_0), 16) 
         --res{31..16} := alu.signedSat((s17)(res31_16), 16)
      end do
    case #SH
      --shaddsubx
      do
        res{15..0} := res15_0{16..1} 
        res{31..16} := res31_16{16..1}
      end do
    case #U
      --usubaddx
      do
        res{15..0} := res15_0{15..0} 
        res{31..16} := res31_16{15..0}
        --CPSR.GE{1..0} := if CarryFrom16(Rn[15:0] + Rm[31:16]) == 1 then 0b11 else 0 
        --CPSR.GE{3..2} := if BorrowFrom16(Rn[31:16] - Rm[15:0]) == 1 then 0b11 else 0
      end do
    case #UQ
      --uqsubaddx
      do
        --res{15..0} := alu.unsignedSat(res15_0, 16) 
        --res{31..16} := alu.unsignedSat(res31_16, 16)
      end do
    case #UH
      --uhsubaddx
      do
        res{15..0} := res15_0{16..1} 
        res{31..16} := res31_16{16..1}
      end do
  end select
 
  do
    SRU.writeR32(Rd, res)
  end do
end behavior

-- CLZ
behavior clzInst #clz
  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rm
  field u4 Rd
  
  u32 result
  u32 rmVal
  
  do
    rmVal := SRU.readR32(Rm)
   
    if rmVal = 0 then
      result := 32
    else 
      result := alu.clz(rmVal)
    end if
    
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
  end do
  
end behavior

-- usad8, usada8
behavior unsignedSumAbsoluteDifference #usad
  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rd
  field u4 Rm
  field u4 Rs

  u32 rmVal
  u32 rsVal
  u32 result
  u8 diff1
  u8 diff2
  u8 diff3
  u8 diff4
  
  do
    rmVal := SRU.readR32(Rm)
    rsVal := SRU.readR32(Rs)
  
    if rmVal{7..0} < rsVal{7..0} then 
      diff1 := rsVal{7..0} - rmVal{7..0}
    else 
      diff1 := rmVal{7..0} - rsVal{7..0}
    end if
    
    if rmVal{15..8} < rsVal{15..8} then 
      diff2 := rsVal{15..8} - rmVal{15..8}
    else 
      diff2 := rmVal{15..8} - rsVal{15..8}
    end if
    
    if rmVal{23..16} < rsVal{23..16} then 
      diff3 := rsVal{23..16} - rmVal{23..16}
    else 
      diff3 := rmVal{23..16} - rsVal{23..16}
    end if
    
    if rmVal{31..24} < rsVal{31..24} then 
      diff4 := rsVal{31..24} - rmVal{31..24}
    else 
      diff4 := rmVal{31..24} - rsVal{31..24}
    end if
  end do

  select
    case #noAcc
      do
        result := alu.usad8(diff1, diff2, diff3, diff4)
      end do
    case #Acc
      field u4 Rn
      u32 rnVal
      do
        rnVal := SRU.readR32(Rn)
       
        result := alu.usada8(rnVal, diff1, diff2, diff3, diff4)
      end do
  end select
  
  do
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
  end do
end behavior

-- other miscellaneous instructions
behavior misc
  u1 condPassed
  cond_inst(condPassed)
  
  field u4 Rd
  field u4 Rm

  u32 result  
  u32 rmVal
  
  do
    rmVal := SRU.readR32(Rm)
  end do

  select 
    case #pack
      
      field u4 Rn
      field u5 shift_imm

      u32 rnVal
      
      do
        rnVal := SRU.readR32(Rn)
      end do
      
      select
        case #bt
        -- pkhbt
          do
            result{15..0} := rnVal{15..0} 
            result{31..16} := (rmVal << shift_imm){31..16}
          end do
        case #tb
        -- pkhtb
          do
            if shift_imm = 0 then
              if rmVal{31} = 0 then 
                result{15..0} := \x0000
              else 
                result{15..0} := \xffff
              end if
            else 
              result{15..0} := ((s32)(rmVal) >> shift_imm){15..0}
              result{31..16} := rnVal{31..16}
            end if
          end do
      end select
    case #rev
    -- rev
      do
        result{31..24} := rmVal{7..0} 
        result{23..16} := rmVal{15..8}
        result{15..8} := rmVal{23..16} 
        result{7..0} := rmVal{31..24}
      end do
    case #rev16
    -- rev16
      do
        result{15..8} := rmVal{7..0} 
        result{7..0} := rmVal{15..8}
        result{31..24} := rmVal{23..16} 
        result{23..16} := rmVal{31..24}      
      end do
    case #revsh
    -- revsh
      do
        result{15..8} := rmVal{7..0}
        result{7..0} := rmVal{15..8}
        
        if rmVal{7} = 1 then
          result{31..16} := \xffff 
        else
          result{31..16} := \x0000
        end if
      end do
    case #sel
    -- sel
      field u4 Rn
      
      u32 rnVal
    
      do
        rnVal := SRU.readR32(Rn)
      
        if CPSR.GE{0} = 1 then
          result{7..0} := rnVal{7..0}
        else
          result{7..0} := rmVal{7..0}
        end if
        
        if CPSR.GE{1} = 1 then
          result{15..8} := rnVal{15..8}
        else
          result{15..8} := rmVal{15..8}
        end if
  
        if CPSR.GE{2} = 1 then
          result{23..16} := rnVal{23..16}
        else
          result{23..16} := rmVal{23..16}
        end if
        
        if CPSR.GE{3} = 1 then
          result{31..24} := rnVal{31..24}
        else
          result{31..24} := rmVal{31..24}
        end if
      end do
    case #sat
      
      select 
        case #sat32
     
          field u5 sat_imm
          field u5 shift_imm
          field u1 sh
      
          select 
            case #signed
              -- ssat
              s32 operand
      
              do 
                if sh = 1 then
                  if shift_imm = 0 then 
                    operand := (s32)(((s32)(rmVal) >> 32){31..0})
                  else 
                    operand := (s32)(((s32)(rmVal) >> shift_imm){31..0})
                  end if
                else 
                  operand := (s32)((rmVal << shift_imm){31..0})
                end if
        
                result := (u32)(alu.signedSat((s33)(operand), (u5)(sat_imm + 1)))
        
                if alu.signedDoesSat((s33)(operand), (u5)(sat_imm + 1)) && condPassed then
                  CPSR.Q := 1
                end if
              end do

            case #unsigned
              -- usat
              
              u32 operand
              
              do
                if sh = 1 then
                  if shift_imm = 0 then 
                    operand := ((s32)(rmVal) >> 32){31..0}
                  else 
                    operand := ((s32)(rmVal) >> shift_imm){31..0}
                  end if
                else 
                  operand := (rmVal << shift_imm){31..0}
                end if
                
                result := alu.unsignedSat((s33)((s32)(operand)), sat_imm)
                
                if alu.unsignedDoesSat((s33)((s32)(operand)), sat_imm) && condPassed then
                  CPSR.Q := 1
                end if
              end do
          end select
        case #sat16
        
          field u4 sat_imm
          select 
            case #signed
        
            case #unsigned
          end select
      end select
  end select
  
  do
    if condPassed then
      SRU.writeR32(Rd, result)
    end if
  end do
  
end behavior

--##==================================================
--## Format description
--##==================================================

-- root instruction
format instBase
  condition
  select slice{27..25}
    case \m00- is dataProcessingOrMul
    case \m01- is LoadStoreWordOrByte
    case \b100 is LoadStoreMultiple
    case \b101 is branch
    case \b111 is coproAndSoftInterrupt
  end select
end format

in arm_opt {
  format condition
    select slice {31..28}
      case \b0000 is #EQ
      case \b0001 is #NE
      case \b0010 is #CS
      case \b0011 is #CC
      case \b0100 is #MI
      case \b0101 is #PL
      case \b0110 is #VS
      case \b0111 is #VC
      case \b1000 is #HI
      case \b1001 is #LS
      case \b1010 is #GE
      case \b1011 is #LT
      case \b1100 is #GT
      case \b1101 is #LE
      case \b1110 is #AL
  --    case \b1111 is #SPEC
    end select 
  end format
}
in arm_dbg {
  format condition
      select slice {31..28} -- all but \b1111
      --here, if we use the 'others', 2 paths will be created :-/
        case 0  or 1  or 2  or 3  or 4  or 5 or 6 or 7 or 8 or 9 or 
             10 or 11 or 12 or 13 or 14 is
          condition := slice{31..28} 
      end select
  end format
}

format dataProcessingOrMul
  select slice{25,7,4}
    case \b011 is mul
    others is dataProcessing 
  end select
end format

-- data processing instruction: addressing mode 1
format dataProcessing -- armv5-inst-manual p.443
  select slice {25}
    case 1 is #imm32
      rotate_imm := slice{11..8}
      immed_8    := slice{7..0}
    case 0 is 
      shift      := slice{6..5}
      Rm         := slice{3..0}
      select slice {7,4}
        case \m-0 is #immShift
          shift_imm := slice{11..7}
        case \m01 is #regShift --bit 7 is 0: else multiplication.
          Rs := slice{11..8}
      end select
  end select
  select slice{24,23}
    case \b10 is
      dataProcessingInstructionOpcodeNoDest
      select slice{20}
        case 1 is -- CCR bit always set, as there is no dest.
      end select
    others is
      dataProcessingInstructionOpcode
      select slice{20}
        case 0 is #noUpdateCCR
        case 1 is #updateCCR
      end select
      Rd := slice{15..12}
  end select
  Rn := slice{19..16}
end format

format dataProcessingInstructionOpcodeNoDest
  select slice{22..21}
    case \b00 is #TST
    case \b01 is #TEQ
    case \b10 is #CMP
    case \b11 is #CMN
  end select
end format

format dataProcessingInstructionOpcode
  select slice{24..21,19..16}
    case \m0000_---- is #AND
    case \m0001_---- is #EOR
    case \m0010_---- is #SUB
    case \m0011_---- is #RSB
    case \m0100_---- is #ADD
    case \m0101_---- is #ADC
    case \m0110_---- is #SBC
    case \m0111_---- is #RSC
    case \m1100_---- is #ORR
    case \m1101_0000 is #MOV --19..16 is SBZ
    case \m1110_---- is #BIC
    case \m1111_0000 is #MVN --19..16 is SBZ
  end select
end format

-- load store for Word or Byte: addressing mode 2
format LoadStoreWordOrByte -- armv5-inst-manual p.459
  Rn := slice{19..16}
  Rd := slice{15..12}
  pubwl
  select slice{25}
    case 0 is #immediatOffset
      offset_12 := slice{11..0}
    case 1 is
      Rm := slice{3..0}
      select slice{4} -- bit 4 should be 0
        case 0 is #scaledRegisterOffset
          shift_imm := slice{11..7}
          shift := slice{6..5}
      end select 
  end select
end format

format pu_w_
  select slice {24}
    case 0 is #noP
    case 1 is #P
  end select
  select slice {23}
    case 0 is #subOffset
    case 1 is #addOffset
  end select
  select slice {21}
    case 0 is #noW
    case 1 is #W
  end select
end format

format pu_wl
  pu_w_
  select slice {20}
    case 0 is #Store
    case 1 is #Load
  end select
end format

format pubwl -- PUBWL on bits 24..20
  pu_wl
  select slice {22}
    case 0 is #Word
    case 1 is #Byte
  end select
end format

-- Miscellaneous Loads and Stores : addressing mode 3.
format miscellaneousLoadStore
  condition
  pu_w_
  select slice {27..25,7,4}
    case \m00011 is
      select slice {20,6,5} -- normally LoadStore/S/H
        case \b001 is #Store #halfword   #priviledge
        case \b010 is #Load  #doubleword
        case \b011 is #Store #doubleword
        case \b101 is #Load  #halfword #unsigned #priviledge
        case \b110 is #Load  #Byte #signed       #priviledge
        case \b111 is #Load  #halfword #signed   #priviledge
      end select
      Rn := slice{19..16}
      Rd := slice{15..12}      
  end select
  select slice {22}
    case 1 is #Imm imm := slice{11..8,3..0}
    case 0 is #noImm
      select slice{11..8} --SBZ
        case \b0000 is Rm  := slice{3..0}
      end select
  end select
end format

--Load and Store Multiple: Addressing Mode 4 
format LoadStoreMultiple
  pu_wl
  select slice{22}
    case 0 is #noS
    case 1 is #S
  end select
  Rn      := slice{19..16}
  regList := slice{15..0}
end format

-- Load and Store Coprocessor: Addressing Mode 5
format loadStoreCoprocessor
  conditionCoproc
  cp_num  := slice{11..8}

  select slice {27..25}
    case \b110 is
      select slice {24..21}
        case \m0010 is -- MRRC or MCRR
          CRm := slice{3..0}
          opcode := slice{7..4}
          Rn := slice{19..16}
          Rd := slice{15..12}
          select slice{20}
            case \b1 is #MRRC
            case \b0 is #MCRR
          end select
        -- load store format (addressing mode 5),
        -- except opcodes for MRRC and MCRR
        others is 
          pu_wl
          select slice{22}
            case 0 is #noN
            case 1 is #N
          end select
          Rn      := slice{19..16}
          Crd     := slice{15..12}
          offset8 := slice{7..0}
      end select
  end select
end format

format branch #branch
  select slice{24}
    case 0 is #noLink
    case 1 is #withLink  #SP_Check
  end select
  offset := signed slice {23..0}
end format

format blx1 #branch #withLink #Thumb #SP_Check -- branch, link and change ISA to Thumb.
  select slice {31..25}
    case \b1111_101 is #abs -- absolute (other blx may be relative)
      half := slice{24}
      offset := signed slice {23..0}
  end select
end format

format bx #branch #rel  -- branch and change ISA (Thumb or Jazelle) and may link.
  condition
  Rm := slice{3..0}
  select slice {27..8}
    case \b00010010_1111_1111_1111 is 
    select slice {7..4}
      case \b1111 is #withLink #Thumb
      case \b0001 is #noLink   #Thumb
      case \b0010 is #noLink   #Jazelle
    end select
  end select
end format

format coproAndSoftInterrupt
  select slice{24}
--    case \b0 is coprocessorFunc not yet implemented.
    case \b1 is #swi
      swi := slice{23..0}
  end select
end format

format mul
  select slice {20}
    case 0 is #noS
    case 1 is #S
  end select
  Rs := slice{11..8}
  Rm := slice{3..0}
  select slice {27..21,7..4}
    case \m000000-_1001 is normalMul -- 32x32 -> low 32
    case \m00001--_1001 is longMul   -- 32x32 -> 64
  end select
end format

format longMulFields
  RdHi := slice{19..16}
  RdLo := slice{15..12}
end format

format mulNoS #noS -- multiplication without status
  condition
  Rs := slice{11..8}
  Rm := slice{3..0}
  select slice {27..20,7..4}
    case \m00000100_1001 is #LongMul #unsigned #umall-- 32x32 -> 64
      longMulFields
    case \m00010--0_1--0 is #signed #mul -- 
      Rd := slice{19..16}
      y := slice{6}
      x := slice{5}
      select slice{22..21,15..12}
        case \b11_0000 is #noAcc -- smulxy 16x16->32
        case \m00_---- is #Acc   -- smlaxy (16x16)+32->32
          Rn := slice{15..12}
      end select
    case \m00010100_1--0 is #signed #smlal -- smlalxy (16x16)+64->64?
      RdHi := slice{19..16}
      RdLo := slice{15..12}
      y := slice{6}
      x := slice{5}
    case \m00010010_1--0 is #signed #mul #word --#smulw 
      Rd := slice{19..16}
      y := slice{6}
      select slice{15..12,5}
        case \b00001 is #noAcc -- smulw -- 32x16 -> 32
        case \m----0 is #Acc   -- smlaw -- 32x16+32 -> 32
          Rn := slice{15..12}
      end select
    case \m01110101_---1 is #signed #mul #msw
      r := slice{5}
      Rd := slice{19..16}
      select slice {7..6}
        case \b00 is
          select slice{15..12}
            case \m1111 is #noAcc     -- smmul
            others      is #Acc #add  -- smmla
              Rn := slice{15..12}
          end select
        case \b11 is #Acc #sub        -- smmls
          Rn := slice{15..12}
      end select
    case \m01110-00_0--1 is #dual #mul
      x  := slice{5}
      select slice {6}
        case 0 is #add -- smuad, smlad and smlald
        case 1 is #sub -- smusd, smlsd and smlsld
      end select
      select slice{22}
        case 1 is #long #Acc --smlald and smlsld
          RdHi := slice{19..16}
          RdLo := slice{15..12}
        case 0 is #noLong
          Rd := slice{19..16}
          select slice{15..12}
            case \m1111 is #noAcc -- smuad and smusd
            others      is #Acc   -- smlad and smlsd
              Rn := slice{15..12}
          end select
      end select
  end select
end format

format longMul #LongMul
  longMulFields
  select slice{22}
    case 0 is #unsigned
    case 1 is #signed
  end select
  select slice{21}
    case 0 is #noAcc
    case 1 is #Acc --accumulate.
  end select
end format

format normalMul #mul
  Rd := slice{19..16}
  select slice{21,15..12}
    case \m1---- is #Acc Rn := slice{15..12} --#mla 
    case \m00000 is #noAcc --#mul
  end select
end format

format parallelAddAndSub
  condition
  Rn := slice{19..16}
  Rd := slice{15..12}
  Rm := slice{3..0}
  select slice{22..20}
    case \b001 is #S
    case \b010 is #Q
    case \b011 is #SH
    case \b101 is #U
    case \b110 is #UQ
    case \b111 is #UH
  end select
  select slice{27..23,11..8}
    case \m01100_1111 is -- all of these inst match these bits.
      select slice {7..4}
        case \b0001 is #add #S16
        case \b0111 is #sub #S16
        case \b1001 is #add #S8
        case \b1111 is #sub #S8
        case \b0011 is #addsubx
        case \b0101 is #subaddx
      end select
  end select 
end format

format extendInst
  condition
  Rd := slice{15..12}
  Rm := slice{3..0}
  rot := slice{11..10}
  select slice {27..23,9..4}
    case \b01101_000111 is #extend
  end select
  select slice {19..16}
    case \b1111 is #noAcc -- sxtb, sxth, sxtb16, uxtb, ..
    others      is #Acc Rn := slice{19..16}  -- sxtab, sxtah, ...
  end select
  select slice {21..20}
    case \b00 is #b16 -- sxtab16, sxtb16, uxtab16, uxtb16
    case \b10 is #b   -- sxtab,   sxtb,   uxtab,   uxtb
    case \b11 is #h   -- sxtah,   sxth,   uxtah,   uxth
  end select
  select slice {22}
    case \b0 is #signed     -- sxtab16, sxtb16
    case \b1 is #unsigned   -- uxtab,   uxtb
  end select
end format

format clz #clz
  condition
  select slice{27..16,11..4}
    case \b00010110_1111_1111_0001 is
      Rd := slice{15..12}
      Rm := slice{3..0}
  end select
end format

format usadX8 -- usad8 and usada8
  condition
  Rd := slice{19..16}
  Rs := slice{11..8}
  Rm := slice{3..0}
  select slice {27..20,7..4}
    case \b01111000_0001 is #usad
      select slice {15..12}
        case \b1111 is #noAcc
        others      is #Acc Rn := slice{15..12}
      end select
  end select
end format

format misc
  condition
  Rd := slice {15..12}
  Rm := slice {3..0}
  select slice {27..20,5..4}
    case \b01101000_01 is #pack
      Rn := slice {19..16}
      shift_imm := slice {11..7}
      select slice {6}
        case 0 is #bt -- pkhbt
        case 1 is #tb -- pkhtb
      end select
    case \m01101-11_11 is
      select slice {22,19..16,11..6}
        case \b0_1111_1111_00 is #rev
        case \b0_1111_1111_10 is #rev16
        case \b1_1111_1111_10 is #revsh
      end select
    case \m01101000_11 is
      Rn := slice {19..16}
      select slice {11..6}
        case \b1111_10 is #sel
      end select
    case \m01101-1-_-- is #sat
      select slice {22}
       case 0 is #signed
       case 1 is #unsigned
      end select
      select slice {20,11..8,7..6,5..4}
        case \m-_----_--_01 is #sat32
          sat_imm := slice {20..16}
          shift_imm := slice {11..7}
          sh := slice {6}
        case \m0_1111_00_11 is #sat16
          sat_imm := slice {19..16}
      end select
  end select
end format

format status
  condition
  r := slice{22}
  select slice{27..20,15..12}
    case \m00-10-10_1111 is #msr
      field_mask := slice{19..16}
      select slice{25,11..4}
        case \b0_0000_0000 is #reg 
          Rm := slice{3..0}
        case \m1_----_---- is #imm
          rotate_imm := slice{11..8}
          immed_8 := slice{7..0}
      end select
    case \m00010-00_---- is #mrs
      select slice{19..16,11..0} --sbo, sbz
        case \b1111_000000000000 is
          Rd := slice{15..12}
      end select 
  end select
end format

format cps
  select slice {31..20,16,15..9,5}
    case \b1111_00010000_0_0000000_0 is #cps
      imod := slice{19..18}
      mmod := slice{17}
      a    := slice{8}
      i    := slice{7}
      f    := slice{6}
      mode := slice{4..0}
  end select
end format

format setendAndBkpt
  select slice {31..0}
    case \m1111000100000001000000-000000000 is #setend
      e := slice{9}
    case \m1110_00010010_------------_0111_---- is #bkpt
      immed := slice{19..8,3..0}
  end select
end format

format swap
  condition
  Rn := slice{19..16}
  Rd := slice{15..12}
  Rm := slice{3..0}
  select slice{27..20,11..8, 7..4}
    case \b00010000_0000_1001 is #swap #word
    case \b00010100_0000_1001 is #swap #byte
  end select
end format

format coprocRegs1
   opcode1 := slice{23..20}
   CRd := slice{15..12}
end format

format coprocRegs2
   CRn := slice{19..16}
   opcode2 := slice{7..5}
end format

format conditionCoproc
  select slice{31..28}
    case \m1111 is #Ext
    others is      #noExt condition
  end select
end format

format cdp
  conditionCoproc
  CRm := slice{3..0}
  cp_num := slice{11..8}
  select slice{27..24,20,4}
    case \m1110_-_0 is #CDP coprocRegs1 coprocRegs2 --CDP
    case \m1110_1_1 is #MRC coprocRegs2 
      opcode1 := slice{23..21}  --manque Rd.
      Rd := slice{15..12}
    case \m1110_0_1 is #MCR coprocRegs2 
      opcode1 := slice{23..21} 
      Rd := slice{15..12}
  end select
end format

number syntax binary prefix "0b"
number syntax octal prefix "0"
-- number syntax hexadecimal prefix "0x"

in arm_opt {
  syntax condition
    select 
      case #EQ "eq"
      case #NE "ne"
      case #CS "cs"
      case #CC "cc"
      case #MI "mi"
      case #PL "pl"
      case #VS "vs"
      case #VC "vc"
      case #HI "hi"
      case #LS "ls"
      case #GE "ge"
      case #LT "lt"
      case #GT "gt"
      case #LE "le"
      case #AL -- nothing to print 
    end select 
  end syntax
}

in arm_dbg
{
  syntax condition
    field u4 condition
      if condition = \b0000 then "eq"
      elseif condition = \b0001 then "ne"
      elseif condition = \b0010 then "cs"
      elseif condition = \b0011 then "cc"
      elseif condition = \b0100 then "mi"
      elseif condition = \b0101 then "pl"
      elseif condition = \b0110 then "vs"
      elseif condition = \b0111 then "vc"
      elseif condition = \b1000 then "hi"
      elseif condition = \b1001 then "ls"
      elseif condition = \b1010 then "ge"
      elseif condition = \b1011 then "lt"
      elseif condition = \b1100 then "gt"
      elseif condition = \b1101 then "le"
      --elseif condition = \b1110 then "al" --"al" not printed.
      -- if condition = \b1111 then "spec"
      end if
  end syntax
}

syntax dataProcessingInstructionOpcode2sources
  select 
    case #AND "and"
    case #EOR "eor"
    case #SUB "sub"
    case #RSB "rsb"
    case #ADD "add"
    case #ADC "adc"
    case #SBC "sbc"
    case #RSC "rsc"
    case #ORR "orr"
    case #BIC "bic"
  end select
end syntax

syntax dataProcessingCCR
  select 
    case #noUpdateCCR --nothing
    case #updateCCR   "s"
  end select
end syntax

syntax dataProcessing1source -- mov, movn instructions.
  select 
    case #MOV "mov"
    case #MVN "mvn"
  end select
  dataProcessingCCR
  condition
  " "
  printRd
  dataProcessingLastPart
end syntax

syntax dataProcessingNoDest
  select 
    case #TST "tst"
    case #CMN "cmn"
    case #CMP "cmp"
    case #TEQ "teq"
  end select
  condition
  " "
  printRn
  dataProcessingLastPart
end syntax

-- all data processing instruction, except mov and movn.
syntax dataProcessing2sources
  dataProcessingInstructionOpcode2sources
  dataProcessingCCR
  condition
  " "
  printRd
  ", "
  printRn
  dataProcessingLastPart
end syntax

syntax rotateImm8
  field u4 rotate_imm
  field u8 immed_8
  ", #\d", (s32)((u32)(immed_8) ror (rotate_imm << 1)) --ok
end syntax

syntax dataProcessingLastPart
  select
    case #imm32 rotateImm8
    case #immShift
      field u4 Rm
      ", " printRm
      shiftPartAM1
    case #regShift
      field u2 shift
      field u4 Rm
      ", " printRm
      if shift = 0 then ", lsl " end if
      if shift = 1 then ", lsr " end if
      if shift = 2 then ", asr " end if
      if shift = 3 then ", ror " end if
      printRs
  end select
end syntax

-- shift part with addressing mode 2
syntax shiftPartAM2
  field u2 shift
  field u5 shift_imm
  if shift != 0 | shift_imm != 0 then 
    --shift is 0 to 31 for lsl, 
    --         1 to 32 for lsr and asr (32 is encoded with shift_imm = 0)
    --         1 to 31 for ror  (if shift_imm = 0 => rrx)
    if     shift = 0 then ", lsl #\d", shift_imm
    elseif shift = 1 then ", lsr"
      if shift_imm = 0 then " #32" else " #\d", shift_imm end if
    elseif shift = 2 then ", asr"
      if shift_imm = 0 then " #32" else " #\d", shift_imm end if
    elseif shift = 3 then 
      if shift_imm = 0 then ", rrx" 
      else ", ror #\d", shift_imm end if
    end if
  end if
end syntax

-- shift part with addressing mode 1
syntax shiftPartAM1
  field u2 shift
  field u5 shift_imm
  -- rotate right with extend.
  if shift_imm = 0 & shift = 3 then ", rrx"
  elseif shift != 0 | shift_imm != 0 then 
    if     shift = 0 then ", lsl"
    elseif shift = 1 then ", lsr"
    elseif shift = 2 then ", asr"
    elseif shift = 3 then ", ror" end if
    --shift is 0 to 31 for lsl, 1 to 32 for others, 32 is encoded with shift_imm = 0
    if shift_imm = 0 & shift != 0 then " #32"
    else " #\d", shift_imm
    end if
  end if
end syntax

-- branch instructions
syntax branch #branch
  "b"
  select
    case #noLink --nothing
    case #withLink  #SP_Check "l"
  end select
  condition
  field s24 offset
  -- instruction address already updated...
  " \x", (u32)((s32)(instruction address) + 8s + ((s30)(offset)<<2))
end syntax

syntax blx #branch
  "b"
  select
    case #withLink "l"
    case #noLink   --nothing.
  end select
  select
    case #Thumb   "x"
    case #Jazelle "j"
  end select
  select
    case #abs
      field u1 half
      field s24 offset
      -- instruction address already updated...
      " \x", (u32)((u32)((s32)(instruction address) + 8s + ((s30)(offset)<<2)) + half<<1)
    case #rel
      condition " " printRm
  end select
end syntax

syntax loadStoreBase
  select
    case #Load  "ldr"
    case #Store "str"
  end select
end syntax

-- load store: addressing mode 2.
syntax loadStoreWordOrByte
  field u4 Rn
  field u4 Rd
  loadStoreBase
  select
    case #Word -- default case
    case #Byte "b"
  end select
  priviledgeAccess
  condition
  " " 
  printRd
  ", ["
  printRn
  select
    case #P   
    case #noP "]"
  end select
  select 
    case #immediatOffset
      field u12 offset_12
      select
        case #subOffset if offset_12 > 0 then ", #-" end if
        case #addOffset  if offset_12 > 0 then ", #" end if
      end select
      if offset_12 > 0 then "\d", offset_12 end if
    case #scaledRegisterOffset
      field u5 shift_imm
      field u2 shift
      select
        case #subOffset ", -"
        case #addOffset  ", "
      end select
      printRm
      shiftPartAM2
  end select
  select
    case #noP #W   -- already the 't'. objdump does not add the '!'
    case #noP #noW
    case #P #W     "]!"
    case #P #noW   "]"
  end select
end syntax

syntax priviledgeAccess
  select
    case #noP #W "t" -- unpriviledge access.
    case #noP #noW
    case #P #W
    case #P #noW
  end select
end syntax

-- Miscellaneous Loads and Stores: addressing mode 3
syntax miscellaneousLoadStore
  -- some instructions have the 't' of priviledge access in the objdump
  -- disassembler, but I did not found such information in datasheet.
  select
    case #Store #halfword #priviledge            "str" "h"                   condition -- priviledgeAccess -- store halfword -- no priviledge access in objdump :-/
    case #Load  #doubleword                      "ldr" "d"                   condition -- load doubleword
    case #Store #doubleword                      "str" "d"                   condition -- store doubleword
    case #Load  #halfword #unsigned #priviledge  "ldr" "h"  priviledgeAccess condition -- load unsigned halfword
    case #Load  #Byte #signed       #priviledge  "ldr" "sb" priviledgeAccess condition -- load signed byte
    case #Load  #halfword #signed   #priviledge  "ldr" "sh" priviledgeAccess condition -- load signed halfword
  end select
  " "
  printRd
  ", ["
  printRn
  select
    case #P   
    case #noP "]"
  end select
  select 
    case #Imm
      field u8 imm
      select
        case #subOffset if imm > 0 then ", #-" end if
        case #addOffset  if imm > 0 then ", #" end if
      end select
      if imm > 0 then "\d", imm end if
    case #noImm
      select
        case #subOffset ", -"
        case #addOffset  ", "
      end select
      printRm
  end select
  select
    case #noP #W
    case #noP #noW
    case #P #W     "]!"
    case #P #noW   "]"
  end select
end syntax

syntax LoadStoreExclusive #EX
  loadStoreBase "ex" condition " "
  printRd ", "
  select
    case #Load  
    case #Store printRm ", "
  end select
  printRn
end syntax

-- stmed, stmea, stmfd, stmfa and the corresponding loads (stack ops)
-- are not simplified by objdump...and not by harmless too.
syntax LoadStoreMultiple
  select
    case #Load   #noP #subOffset #W   "ldmda" condition " " printRn "!, "
    case #Load   #noP #addOffset #W   
      field u4 Rn if Rn=13 then "pop" else "ldm" end if
      condition " " printRnPushPop
    case #Load   #P   #subOffset #W   "ldmdb" condition " " printRn "!, "
    case #Load   #P   #addOffset #W   "ldmib" condition " " printRn "!, "
    case #Store  #noP #subOffset #W   "stmda" condition " " printRn "!, "
    case #Store  #noP #addOffset #W   "stm"   condition " " printRn "!, " 
    case #Store  #P   #subOffset #W
      field u4 Rn if Rn=13 then "push" else "stmdb" end if
      condition " " printRnPushPop
    case #Store  #P   #addOffset #W   "stmib" condition " " printRn "!, "
    case #Load   #noP #subOffset #noW "ldmda" condition " " printRn ", "
    case #Load   #noP #addOffset #noW "ldm"   condition " " printRn ", "
    case #Load   #P   #subOffset #noW "ldmdb" condition " " printRn ", "
    case #Load   #P   #addOffset #noW "ldmib" condition " " printRn ", "
    case #Store  #noP #subOffset #noW "stmda" condition " " printRn ", "
    case #Store  #noP #addOffset #noW "stm"   condition " " printRn ", "
    case #Store  #P   #subOffset #noW "stmdb" condition " " printRn ", "
    case #Store  #P   #addOffset #noW "stmib" condition " " printRn ", "
  end select
  "{"
  field u16 regList;
  -- this is particularly ugly because of the lack of expressions and loops...
  if regList{00} then "r0" if regList{15..01} != 0 then ", " end if end if 
  if regList{01} then "r1" if regList{15..02} != 0 then ", " end if end if 
  if regList{02} then "r2" if regList{15..03} != 0 then ", " end if end if 
  if regList{03} then "r3" if regList{15..04} != 0 then ", " end if end if 
  if regList{04} then "r4" if regList{15..05} != 0 then ", " end if end if 
  if regList{05} then "r5" if regList{15..06} != 0 then ", " end if end if 
  if regList{06} then "r6" if regList{15..07} != 0 then ", " end if end if 
  if regList{07} then "r7" if regList{15..08} != 0 then ", " end if end if 
  if regList{08} then "r8" if regList{15..09} != 0 then ", " end if end if 
  if regList{09} then "r9" if regList{15..10} != 0 then ", " end if end if 
  if regList{10} then "sl" if regList{15..11} != 0 then ", " end if end if 
  if regList{11} then "fp" if regList{15..12} != 0 then ", " end if end if 
  if regList{12} then "ip" if regList{15..13} != 0 then ", " end if end if 
  if regList{13} then "sp" if regList{15..14} != 0 then ", " end if end if 
  if regList{14} then "lr" if regList{15..15} != 0 then ", " end if end if 
  if regList{15} then "pc" end if
  "}"
  select
    case #S   "^"
    case #noS --nothing
  end select
end syntax

syntax swi
  #swi
  field u24 swi
  "svc" -- SoftWare Interrupt (SWI) is renamed SuperVisor Call (SVC)
  condition
  " \x",swi
end syntax

syntax longMul #LongMul
  select
    case #unsigned "u"
    case #signed   "s"
  end select
  select
    case #umall "maal" 
    case #noAcc "mull"
    case #Acc   "mlal" 
  end select
  select
    case #S   "s"
    case #noS --nothing
  end select
  condition
  op4_rd64 
end syntax

syntax op4_rd64 -- 4 operands, Rd on 64 bits.
  " "
  printRdLo ", "
  printRdHi ", "
  printRm   ", "
  printRs
end syntax

syntax op3or4 -- 3 or 4 operands, depending of acc.
  " "
  printRd ", "
  printRm ", "
  printRs
  acc
end syntax

syntax acc
  select
    case #noAcc --nothing else
    case #Acc ", " printRn
  end select
end syntax

syntax normalMul #mul
  select
   case #Acc   "mla"
   case #noAcc "mul"
  end select
  select
    case #S   "s"
    case #noS --nothing
  end select
  condition
  op3or4 
end syntax

syntax x
  field u1 x
  if x then "t" else "b" end if;
end syntax

syntax y
  field u1 y
  if y then "t" else "b" end if;
end syntax

syntax r
  field u1 r
  if r then "r" end if;
end syntax

syntax smlal #noS #signed #smlal
  "smlal" x y
  condition
  op4_rd64 
end syntax

syntax smul_smla #noS #signed #mul
  select 
    case       #Acc      "smla"  x y
    case       #noAcc    "smul"  x y 
    case #word #Acc      "smlaw"   y
    case #word #noAcc    "smulw"   y 
    case #msw  #noAcc    "smmul" r
    case #msw  #Acc #add "smmla" r
    case #msw  #Acc #sub "smmls" r
  end select
  condition
  op3or4 
end syntax

syntax dualHalfwordMultiply #noS #dual #mul
  "sm"
  select 
    case #Acc   "l"
    case #noAcc "u"
  end select
  select
    case #add "a"
    case #sub "s"
  end select
  select
    case #long   "ld"
    case #noLong "d"
  end select
  field u1 x
  if x then "x" end if
  condition
  select 
    case #long   op4_rd64 
    case #noLong op3or4  
  end select
end syntax

syntax parallelAddAndSub
  select
    case #S  "s"
    case #Q  "q"
    case #SH "sh"
    case #U  "u"
    case #UQ "uq"
    case #UH "uh"
  end select
  select
    case #add #S16 "add16"
    case #sub #S16 "sub16"
    case #add #S8  "add8"
    case #sub #S8  "sub8"
    case #addsubx  "addsubx"
    case #subaddx  "subaddx"
  end select
  condition " "
  printRd ", "
  printRn ", "
  printRm
end syntax

syntax extendInst #extend
  select
    case #signed   "s"
    case #unsigned "u"
  end select
  "xt"
  select
    case #noAcc
    case #Acc "a"
  end select
  select
    case #b16 "b16"
    case #b   "b"
    case #h   "h"
  end select
  condition " "
  printRd ", "
  select
    case #Acc   printRn ", "
    case #noAcc
  end select
  printRm
  field u2 rot
  if rot != 0 then 
    ", ror #\d", rot <<3
  end if
end syntax

syntax clz #clz
  "clz"
  condition " "
  printRd ", "
  printRm
end syntax

syntax usadX8 #usad
  "usad"
  select
    case #Acc   "a"
    case #noAcc
  end select
  "8" condition op3or4
end syntax

syntax pkh #pack
  "pkh"
  select 
    case #bt "bt"
    case #tb "tb"
  end select
  condition " "
  printRd ", "
  printRn ", "
  printRm 
  select 
    case #bt ", lsl"
    case #tb ", asr"
  end select

  field u5 shift_imm
  if shift_imm = 0 then " #32" else " #\d", shift_imm end if
end syntax

syntax rev
  "rev"
  select
    case #rev
    case #rev16 "16"
    case #revsh "sh"
  end select
  condition " "
  printRd ", "
  printRm
end syntax

syntax sel #sel
  "sel" condition " "
  printRd ", "
  printRn ", "
  printRm
end syntax

syntax sat #sat
  select
    case #unsigned "u"
    case #signed   "s"
  end select
  "sat"
  select
    case #sat16 
      "16" condition " " 
      field u4 sat_imm
      printRd ", #\d, ",sat_imm
      printRm
    case #sat32
      condition " " 
      printRd
      field u5 sat_imm
      select 
        case #signed   ", #\d, ",sat_imm+1
        case #unsigned ", #\d, ",sat_imm
      end select
      printRm
      field u1 sh
      field u5 shift_imm
      if sh then ", asr "
        if shift_imm = 0 then "#32" else "#\d", shift_imm end if
      else -- no shift if lsl #0 (sh=0 and shift_imm=0)
        if shift_imm != 0 then ", lsl #\d", shift_imm end if
      end if
  end select
end syntax

syntax status
  select
    case #mrs "mrs" condition " " printRd ", "
    case #msr "msr" condition " "
  end select
  field u1 r
  if r then "spsr" else "cpsr" end if;
  select
    case #mrs
    case #msr "_"
      field u4 field_mask;
      if field_mask{3} then "f" end if;
      if field_mask{2} then "s" end if;
      if field_mask{1} then "x" end if;
      if field_mask{0} then "c" end if;
      select
        case #reg ", " printRm
        case #imm rotateImm8
      end select
  end select
end syntax

syntax cps #cps
  "cps"
  field u2 imod
  field u1 mmod
  field u1 a 
  field u1 i 
  field u1 f 
  if imod{1}  then
    if imod = \b10 then "ie" end if;
    if imod = \b11 then "id" end if;
    " "
    if a then "a" end if;
    if i then "i" end if;
    if f then "f" end if;
    if mmod then "," end if
  end if
  field u5 mode
  if mmod then " #\d", mode end if;
end syntax

syntax setend #setend
  "setend "
  field u1 e if e then "be" else "le" end if
end syntax

syntax bkpt #bkpt
  field u16 immed;
  "bkpt #\d", immed
end syntax

syntax swap #swap
  "swp"
  condition
  select
    case #word
    case #byte "b"
  end select
  printRd ", "
  printRm ", "
  printRn
end syntax

syntax conditionCoproc
  select
    case #Ext "2"
    case #noExt condition
  end select
end syntax

syntax offsetCoprocAM
  field u8 offset8
  select
    case #subOffset if offset8 > 0 then ", #-" end if
    case #addOffset  if offset8 > 0 then ", #" end if
  end select
  if offset8 > 0 then ", \d*4", offset8 end if
end syntax

syntax loadStoreCoprocessor --except MCRR and MRRC
  select
    case #Load  "ldc"
    case #Store "stc"
  end select
  conditionCoproc
  select
    case #N   "l"
    case #noN --nothing
  end select
  field u4 cp_num
  " \d", cp_num
  field u4 Crd
  ", cr\d, ", Crd
  -- addressing mode 5
  "[" printRn
  select
    case #P  -- Immediate offset and Immediate pre-indexed
      offsetCoprocAM
      "]"
      select
        case #noW    -- Immediate offset
        case #W   "!"-- Immediate pre-indexed
      end select
    case #noP #W --Immediate post-indexed
      "], "
      offsetCoprocAM
    case #noP #noW  --Unindexed
      field u8 offset8
      "], {\d}", offset8
      select
        case #subOffset " (unpredictable)" --should not happen
        case #addOffset 
      end select
  end select
end syntax

syntax move2RegsCoproc -- MCRR and MRRC
  select
    case #MRRC "mrrc"
    case #MCRR "mcrr"
  end select
  conditionCoproc
  field u4 CRm
  field u4 cp_num
  field u4 opcode
  " \d, \d, ", cp_num, opcode
  printRd ", " 
  printRn ", "
  "cr\d", CRm
end syntax

syntax coproc #CDP
  "cdp"
  conditionCoproc
  field u4 cp_num
  field u4 opcode1
  field u4 opcode2
  field u4 CRn
  field u4 CRd
  field u4 CRm
  " \d, \d, cr\d, cr\d, cr\d, {\d}", cp_num, opcode1, CRd, CRn, CRm, opcode2
end syntax

syntax printRd
  field u4 Rd
  if Rd < 10 then "r\d",Rd
  elseif Rd = 10 then "sl"
  elseif Rd = 11 then "fp"
  elseif Rd = 12 then "ip"
  elseif Rd = 13 then "sp"
  elseif Rd = 14 then "lr"
  elseif Rd = 15 then "pc"
  end if
end syntax

syntax printRdLo
  field u4 RdLo
  if RdLo < 10 then "r\d",RdLo
  elseif RdLo = 10 then "sl"
  elseif RdLo = 11 then "fp"
  elseif RdLo = 12 then "ip"
  elseif RdLo = 13 then "sp"
  elseif RdLo = 14 then "lr"
  elseif RdLo = 15 then "pc"
  end if
end syntax

syntax printRdHi
  field u4 RdHi
  if RdHi < 10 then "r\d",RdHi
  elseif RdHi = 10 then "sl"
  elseif RdHi = 11 then "fp"
  elseif RdHi = 12 then "ip"
  elseif RdHi = 13 then "sp"
  elseif RdHi = 14 then "lr"
  elseif RdHi = 15 then "pc"
  end if
end syntax

syntax printRnPushPop -- really ugly
  field u4 Rn
  if Rn < 10 then "r\d!, ",Rn
  elseif Rn = 10 then "sl!, "
  elseif Rn = 11 then "fp!, "
  elseif Rn = 12 then "ip!, "
  elseif Rn = 14 then "lr!, "
  elseif Rn = 15 then "pc!, "
  end if
end syntax

syntax printRn --ugly
  field u4 Rn
  if Rn < 10 then "r\d",Rn
  elseif Rn = 10 then "sl"
  elseif Rn = 11 then "fp"
  elseif Rn = 12 then "ip"
  elseif Rn = 13 then "sp"
  elseif Rn = 14 then "lr"
  elseif Rn = 15 then "pc"
  end if
end syntax

syntax printRm --ugly
  field u4 Rm
  if Rm < 10 then "r\d",Rm
  elseif Rm = 10 then "sl"
  elseif Rm = 11 then "fp"
  elseif Rm = 12 then "ip"
  elseif Rm = 13 then "sp"
  elseif Rm = 14 then "lr"
  elseif Rm = 15 then "pc"
  end if
end syntax

syntax printRs --ugly
  field u4 Rs
  if Rs < 10 then "r\d",Rs
  elseif Rs = 10 then "sl"
  elseif Rs = 11 then "fp"
  elseif Rs = 12 then "ip"
  elseif Rs = 13 then "sp"
  elseif Rs = 14 then "lr"
  elseif Rs = 15 then "pc"
  end if
end syntax

------------- timing approach (without any pipeline).
--timing allInstruction
--  do add 1 cycle end do
--end timing

} -- model
-- vim:ft=hadl:ts=2:sw=2
