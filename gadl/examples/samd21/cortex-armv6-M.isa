-- 
-- ARMv6-M ISA description (used in the Cortex M0/M0+/M1 core).
-- This is the little endian version 
-- 
-- CURRENTLY MODELLED: nothing :-/
-- 
-- TODO : 
-- 
-- NOT MODELLED: 
-- 
isa {

default {
  instruction := 16 -- instruction basic chunk on 16 bits.
  little endian     -- may have big endian!
}

--##==================================================
--## Components
--##==================================================

component fetcher {
  program counter u32 PC

  void reset() {
    -- SP <- contenu adresse 0
    PC := 0 -- en fait PC <- (contenu adresse 4) - 1
  }

  void absBranch(u32 newPC, u1 cond)
  {
    if (cond) then 
      PC := newPC 
    end if   
  }
}

--##==================================================
--## Behavior description
--##==================================================

--behavior nopInstruction #moveImmediate -- Page A6-154
--end behavior

-- behavior ADC #ADC
--   field u4 Rn
--   field u4 Rd
--   field u12 imm12 -- concatened from decode stage
--   u32 regN
--   u32 regD
--   do
--     regN := reg.read32(Rn)
--     -- Rn and Rd should not be SP(13) or PC(15)
--     -- This should be checked in decode stage...
--     if Rn = 13 || Rn = 15 || 
--        Rd = 13 || Rd = 15 then
--       error "ADC should not use SP nor PC"
--     end if
--     u33 result;
-- 		result := regN+imm12+APSR.C
--     reg.write32(Rd,result{31..0})
--   end do
--   select
--     case #WithUpdateFlags
--       APSR.N = result
--     case #WithNoUpdateFlags
--   end select
-- end behavior 

--##==================================================
--## Format description
--##==================================================
format Instruction16	 -- p A5.127 (ARM DDI 0403E.b)
  select slice{15..10}
    case \m00---- is arith    --A5.128
    case \m010000 is dataProc --A5.129
    case \m010001 is specialAndBex
    case \m01001- is loadFromLiteralPool --A7.254
    case \m0101-- or \m011--- or \m100--- is loadStore -- A5.131
    case \m10100- is #ADR imm10reg1  -- A7.197
    case \m10101- is #AddRdSP imm10reg1 --A7.193
    case \m1011-- is misc16
    case \m11000- is #store #multipleWord lstm
    case \m11001- is #load  #multipleWord lstm
    case \m1101-- is condBranchAndSupervisorCall
--    case \m11100- is unconditionnalBranch
  end select
end format

format condBranchAndSupervisorCall
  select slice{11..8}
    case \m0--- or
         \m10-- or
         \m110- is branch #branch
    case \m1110 is imm8 #udf
    case \m1111 is imm8 #svc
  end select  
end format

format imm8 #imm8
  imm8 := slice{7..0}
end format

format branch #cond #imm9
  cond := slice{11..8}
  imm9 := signed slice{7..0} << 1
end format

format lstm #Rn -- load/store multiple word
  regList := slice{7..0}
  Rn := slice{10..8}
end format

format misc16 -- A7.132
  select slice{11..5}
    case \m0110011 is CPS
    case \m00000-- is #AddSP #imm9 imm9 := slice{6..0} << 2
    case \m00001-- is #SubSP #imm9 imm9 := slice{6..0} << 2
    case \m-0-1--- is compareAndBranch
    case \m001000- is #XT #signed #reg16   reg2 --sxth
    case \m001001- is #XT #signed #reg8    reg2 --sxtb
    case \m001010- is #XT #unsigned #reg16 reg2 --uxth
    case \m001011- is #XT #unsigned #reg8  reg2 --uxtb
    case \m010---- is push 
    case \m0110010 is setEnd
    case \m0110000 is setPan
    case \m101000- is #rev #reg32 reg2
    case \m101001- is #rev #reg16 #unsigned reg2
    case \m101011- is #rev #reg16 #signed reg2
    case \m101010- is #hlt imm6 := slice{5..0}
    case \m110---- is pop
    case \m1110--- is #bkpt imm8 
    case \m1111--- is ifThenElseAndHint
  end select
end format

format setEnd  -- set endianess
  select slice{4,2..0}
    case \b1_000 is #setEnd E := slice{3}
  end select
end format

format setPan -- set priviledge access never
  select slice{4,2..0}
    case \b1_000 is #setPan imm1 := slice{3}
  end select
end format

format ifThenElseAndHint
  select slice{7..0}
    case \m----_0001 or
         \m----_001- or
         \m----_01-- or
         \m----_1--- is ifThen
    case \m0000_0000 is #nop
    case \m0001_0000 is #yield
    case \m0010_0000 is #wfe
    case \m0011_0000 is #wfi
    case \m0100_0000 is #sev
    case \m011-_0000 or
         \m1---_0000 is #nop #hint cond := slice{7..4}
  end select
end format

format ifThen #ifThen #cond
  cond := slice{7..4}
  mask := slice{3..0}
end format

format pop #pop
  regList := slice{7..0}
  P := slice{8}
end format

format push #push
  regList := slice{7..0}
  M := slice{8}
end format

format compareAndBranch
  select slice{11}
    case 0 is #CBZ
    case 1 is #CBNZ
  end select
  imm7 := slice{9,7..3} << 1 #imm7
  Rn := slice{2..0} #Rn
end format

format CPS
  select slice{3..0}
    -- bits 3..2 should be set to '0', but are always decoded in objdump
		-- bits 1..0 should not be set as 0, but objdump decode it.
    case \m0--- or \m0--- is #CPS
  end select
  Im := slice{4}
  A  := slice{2} -- A not defined in ARMv8...
  I  := slice{1}
  F  := slice{0}
end format

format loadStore
  select slice{15..9}
    case \m0101_000 is reg3Rt #store #reg32
    case \m0101_001 is reg3Rt #store #reg16
    case \m0101_010 is reg3Rt #store #reg8
    case \m0101_011 is reg3Rt #load  #reg8  #signed
    case \m0101_100 is reg3Rt #load  #reg32
    case \m0101_101 is reg3Rt #load  #reg16 #unsigned
    case \m0101_110 is reg3Rt #load  #reg8  #unsigned
    case \m0101_111 is reg3Rt #load  #reg16 #signed
    case \m0110_0-- is #store #reg32 regImm7reg2Rt
    case \m0110_1-- is #load  #reg32 regImm7reg2Rt
    case \m0111_0-- is #store #reg8  regImm5reg2Rt
    case \m0111_1-- is #load  #reg8  regImm5reg2Rt
    case \m1000_0-- is #store #reg16 regImm6reg2Rt
    case \m1000_1-- is #load  #reg16 regImm6reg2Rt
    case \m1001_0-- is #store #SP imm10reg1Rt
    case \m1001_1-- is #load  #SP imm10reg1Rt
  end select
end format

format loadFromLiteralPool #load #Rt #imm10
  Rt := slice{10..8}
  imm10 := slice{7..0} << 2
end format

format specialAndBex
  select slice {9..6} -- from A5.130
    case \m00-- is #add reg2_4bits
    -- case 0100 is said UNPREDICTABLE, but objdump understand it as a cmp instruction.
    case \m010- or \m011- or \b0110 is #compare reg2_4bits
    case \m10-- is #mov reg2_4bits
    case \m11-- is #bex
      select slice {7} 
        case \b0 is #noLink
        case \b1 is #link
      end select
      -- bits 1..0 should be set to 0, but objdump interprets instruction as bx (but not with blx!)
      select slice {7,2..0} --C2.2.3
        case \m-100 is #ns   -- non secure => ARMv8-M
        case \m0_0-- or \m0_11- or \m0_101 or \m1_000 is #nons -- no ns
      end select
      Rm := slice{6..3} #Rm
  end select
end format

format dataProc
  select slice {9..6} -- from A7.129
    case \b0000 is #and reg2 
    case \b0001 is #eor reg2
    case \b0010 is #lsl reg2
    case \b0011 is #lsr reg2
    case \b0100 is #asr reg2
    case \b0101 is #adc reg2
    case \b0110 is #sbc reg2
    case \b0111 is #ror reg2
    case \b1000 is #tst reg2
    case \b1001 is #rsb reg2Rn
    case \b1010 is #cmp reg2
    case \b1011 is #cmn reg2
    case \b1100 is #orr reg2
    case \b1101 is #mul reg2
    case \b1110 is #bic reg2
    case \b1111 is #mvn reg2
  end select
end format

format arith
  select slice{13..9}
  -- Page A5-85
    case \m00--- is 
      select slice{11}
        case 0 is #left
        case 1 is #right
      end select
      #logicalShift --A7.298/302
		  Imm5Reg2
    case \m010-- is #right #arithmeticShift Imm5Reg2 -- A7.203
    case \m01100 is #add     reg3     --A7.191
    case \m01101 is #sub     reg3     --A7.350
    case \m01110 is #add     imm3reg2 --A7.189
    case \m01111 is #sub     imm3reg2	--A7.448
    case \m100-- is #move    imm8reg1 --A7.312
    case \m101-- is #compare imm8reg1 --A7.229
    case \m110-- is #add     imm8reg1 --A7.189
    case \m111-- is #sub     imm8reg1 --A7.448
  end select
end format

format Imm5Reg2 #imm5 #Rm #Rd
  imm5 := slice{10..6}
  Rm := slice{5..3}
  Rd := slice{2..0}
end format

format reg2_4bits #Rm #Rd
  Rm := slice{6..3}
  Rd := slice{7,2..0}
end format

format reg2 #Rm #Rd
  Rm := slice{5..3}
  Rd := slice{2..0}
end format

format reg2Rn #Rn #Rd
  Rn := slice{5..3}
  Rd := slice{2..0}
end format

format reg2Rt #Rn #Rt
  Rn   := slice{5..3}
  Rt   := slice{2..0}
end format

format regImm7reg2Rt #imm7
  imm7 := slice{10..6} << 2
  reg2Rt
end format

format regImm6reg2Rt #imm6
  imm6 := slice{10..6} << 1
  reg2Rt
end format

format regImm5reg2Rt #imm5
  imm5 := slice{10..6}
  reg2Rt
end format

format reg3Rt #Rm #Rn #Rt
  Rm := slice{8..6}
  Rn := slice{5..3}
  Rt := slice{2..0}
end format

format reg3 #Rm #Rn #Rd
  Rm := slice{8..6}
  Rn := slice{5..3}
  Rd := slice{2..0}
end format

format imm3reg2 #imm3 #Rn #Rd
  imm3 := slice{8..6}
  Rn := slice{5..3}
  Rd := slice{2..0}
end format

format imm8reg1 #imm8 #Rd
  imm8 := slice{7..0}
  Rd := slice{10..8}
end format

format imm10reg1 #imm10 #Rd
  imm10 := slice{7..0} << 2
  Rd := slice{10..8}
end format

format imm10reg1Rt #imm10 #Rt
  imm10 := slice{7..0} << 2
  Rt := slice{10..8}
end format

--##==================================================
--- Format 32 bits
--##==================================================
format Instruction32	 -- p A5.135 (ARM DDI 0403E.b)
  select slice{15..13}
    case \m111 is -- all 32 bits instructions start with '111'
		  select slice{12..4}+{15} -- select op1/op2/op
        case \m01_00--0--_- is loadStoreMultiple
      end select
  end select
end format

format loadStoreMultiple #multiple
  Rn := slice{3..0}{-} #Rn
  regList := slice{-}{15..0}
  W := slice{5}{-}
  select slice{8..7,4}{-}
    case \m01_0 is #store #emptyAscending #incrementAfter
    case \m01_1 is #load  #fullDescending #incrementAfter
    case \m10_0 is #store #fullDescending #decrementBefore
    case \m10_1 is #load  #emptyAscending #decrementBefore
  end select
end format

--##==================================================
--## Syntax 32 bits description
--##==================================================

syntax Rn4       #Rn    field u4  Rn    "r\d",Rn    end syntax
syntax regList
  "{"
  field u16 regList;
  -- this is particularly ugly because of the lack of expressions and loops...
  if regList{00} then "r0" if regList{15..01} != 0 then ", " end if end if 
  if regList{01} then "r1" if regList{15..02} != 0 then ", " end if end if 
  if regList{02} then "r2" if regList{15..03} != 0 then ", " end if end if 
  if regList{03} then "r3" if regList{15..04} != 0 then ", " end if end if 
  if regList{04} then "r4" if regList{15..05} != 0 then ", " end if end if 
  if regList{05} then "r5" if regList{15..06} != 0 then ", " end if end if 
  if regList{06} then "r6" if regList{15..07} != 0 then ", " end if end if 
  if regList{07} then "r7" if regList{15..08} != 0 then ", " end if end if 
  if regList{08} then "r8" if regList{15..09} != 0 then ", " end if end if 
  if regList{09} then "r9" if regList{15..10} != 0 then ", " end if end if 
  if regList{10} then "sl" if regList{15..11} != 0 then ", " end if end if 
  if regList{11} then "fp" if regList{15..12} != 0 then ", " end if end if 
  if regList{12} then "ip" if regList{15..13} != 0 then ", " end if end if 
  if regList{13} then "sp" if regList{15..14} != 0 then ", " end if end if 
  if regList{14} then "lr" if regList{15..15} != 0 then ", " end if end if 
  if regList{15} then "pc" end if
  "}"
end syntax

syntax loadStoreMultiple #multiple
  field u1 W
  "stm"
  select
    case #store #emptyAscending #incrementAfter
      "ia.w\t" Rn4 ", " regList
  end select
end syntax

--##==================================================
--## Syntax description
--##==================================================

syntax arith
  select
    case #logicalShift #left
				field u5 imm5 #imm5
				field u3 Rm   #Rm
				field u3 Rd   #Rd
				if imm5 = 0 then "movs\tr\d, r\d",Rd,Rm 
				else "lsls\tr\d, r\d, #\d", Rd, Rm, imm5
				end if
		case #logicalShift #right "lsrs\t" Imm5Reg2Shift
    case #right #arithmeticShift "asrs\t" Imm5Reg2Shift
    case #add "adds\t" reg3
    case #sub "subs\t" reg3
    case #add "adds\t" imm3reg2
    case #sub "subs\t" imm3reg2
		case #move "movs\t" imm8reg
		case #compare "cmp\t" imm8reg
		case #add "adds\t" imm8reg
		case #sub "subs\t" imm8reg
  end select
end syntax

-- Data processing
syntax dataProc
  select
    case #and "ands\t" reg2
    case #eor "eors\t" reg2
    case #lsl "lsls\t" reg2
    case #lsr "lsrs\t" reg2
    case #asr "asrs\t" reg2
    case #adc "adcs\t" reg2
    case #sbc "sbcs\t" reg2
    case #ror "rors\t" reg2
    case #tst "tst\t"  reg2
    case #rsb "negs\t" reg2Rn -- rsb in ARM, negs in objdump.
    case #cmp "cmp\t"  reg2
    case #cmn "cmn\t"  reg2
    case #orr "orrs\t" reg2
    case #mul "muls\t" reg2
    case #bic "bics\t" reg2
    case #mvn "mvns\t" reg2
  end select
end syntax

syntax specialAndBex
  select
    case #add     "add\t" reg2_4bits
    case #mov mov
    case #compare "cmp\t" reg2_4bits
    case #bex "b"
		  select case #link "lx" case #noLink "x" end select
		  select case #ns "ns" case #nons end select
      "\t"  Rm4
  end select
end syntax

-- mov is a special case, as mov r8,r8 is interpreted as a 'nop' in objdump.
-- due to limitation of the 'if', we could not call other chunks.
syntax mov #mov #Rm #Rd
  field u4 Rd
  field u4 Rm
  if Rd = 8 & Rm = 8 then "nop"
  else
    --"mov\t" reg2_4bits
    "mov\t"
		if    Rd =15 then "pc" 
		elseif Rd=14 then "lr"
		elseif Rd=13 then "sp"
		else   "r\d",Rd
    end if
    ", "
		if    Rm =15 then "pc" 
		elseif Rm=14 then "lr"
		elseif Rm=13 then "sp"
		else   "r\d",Rm
    end if
  end if
end syntax

syntax loadFromLiteralPool #load
  "ldr\t" Rt ", [pc, " imm10 "]"
end syntax

syntax loadStore
  select
    case #load  "ldr"
    case #store "str"
  end select
  select
    case #signed "s"
    case #unsigned
    case
  end select
  select
    case #reg32 "\t"
    case #reg16 "h\t"
    case #reg8  "b\t"
  end select
  select
    case reg3Rt
    case regImm7reg2Rt
    case regImm6reg2Rt
    case regImm5reg2Rt
  end select
end syntax

syntax loadStoreSP #SP
  select
    case #load  "ldr\t"
    case #store "str\t"
  end select
  Rt ", [sp, " imm10 "]"
end syntax

syntax adr #ADR
  "add\t" Rd ", pc, " imm10 --objdump uses 'add', while ARM DDI 0403E.b uses 'adr'...
end syntax

syntax addsp #AddRdSP
  "add\t" Rd ", sp, " imm10
end syntax

syntax addTosp
  select
    case #AddSP "add\t"
    case #SubSP "sub\t"
  end select
  "sp, " imm9
end syntax

syntax endianess #setEnd
  "setend\t"
  field u1 E
  if E then "be" else "le" end if
end syntax

syntax privAccess #setPan
  field u1 imm1
  "setpan\t#\d",imm1
end syntax

syntax hlt #hlt
  field u6 imm6
  "hlt\t0x00"
  if imm6 < 16 then "0" end if
  "\x",imm6
end syntax

syntax hint
  select
    case #nop    "nop"
    case #yield  "yield" -- strange mnemo from objdump
    case #wfe    "wfe"   -- strange mnemo from objdump
    case #wfi    "wfi"   -- strange mnemo from objdump
    case #sev    "sev"
		case #nop #hint field u4 cond "nop\t{\d}",cond
  end select
end syntax

syntax ifThen #ifThen
  "it"
  field u4 mask
  field u4 cond
  if mask{2..0} != 0 then
    if mask{3} = cond{0} then "t" else "e" end if
    if mask{1..0} != 0 then
      if mask{2} =cond{0} then "t" else "e" end if
      if mask{0} != 0 then
        if mask{1} =cond{0} then "t" else "e" end if
      end if
    end if
  end if
  "\t"
  condWithAl
end syntax

syntax bkpt #bkpt #imm8
  field u8 imm8
  "bkpt\t0x00"
  if imm8 < 16 then "0" end if
  "\x",imm8
end syntax

syntax rev #rev 
  "rev"
  select 
    case #reg32 "\t"
    case #reg16 #unsigned "16\t"
    case #reg16 #signed   "sh\t"
  end select
  reg2
end syntax

syntax CPS #CPS --change processor state
  "cps"
  field u1 Im
  field u1 A
  field u1 I
  field u1 F
  if Im then "id" else "ie" end if
  if A | I | F then "\t" end if
  if A then "a" end if
  if I then "i" end if
  if F then "f" end if
end syntax

syntax pushPop 
  select
    case #push "push\t" reglistM
    case #pop "pop\t" reglistP
  end select
end syntax

syntax reglist
  field u8 regList
  "{"
  -- this is particularly ugly because of the lack of expressions and loops...
  if regList{0} then "r0" if regList{7..1} then ", " end if end if 
  if regList{1} then "r1" if regList{7..2} then ", " end if end if 
  if regList{2} then "r2" if regList{7..3} then ", " end if end if 
  if regList{3} then "r3" if regList{7..4} then ", " end if end if 
  if regList{4} then "r4" if regList{7..5} then ", " end if end if 
  if regList{5} then "r5" if regList{7..6} then ", " end if end if 
  if regList{6} then "r6" if regList{7..7} then ", " end if end if 
  if regList{7} then "r7"                                   end if 
  "}"
end syntax

syntax reglistP
  field u1 P
  field u8 regList
  "{"
  -- this is particularly ugly because of the lack of expressions and loops...
  if regList{0} then "r0" if regList{7..1} cat P != 0 then ", " end if end if 
  if regList{1} then "r1" if regList{7..2} cat P != 0 then ", " end if end if 
  if regList{2} then "r2" if regList{7..3} cat P != 0 then ", " end if end if 
  if regList{3} then "r3" if regList{7..4} cat P != 0 then ", " end if end if 
  if regList{4} then "r4" if regList{7..5} cat P != 0 then ", " end if end if 
  if regList{5} then "r5" if regList{7..6} cat P != 0 then ", " end if end if 
  if regList{6} then "r6" if regList{7..7} cat P != 0 then ", " end if end if 
  if regList{7} then "r7" if                   P != 0 then ", " end if end if 
  if P          then "pc" end if 
  "}"
end syntax

syntax reglistM
  field u1 M
  field u8 regList
  "{"
  -- this is particularly ugly because of the lack of expressions and loops...
  if regList{0} then "r0" if regList{7..1} cat M != 0 then ", " end if end if 
  if regList{1} then "r1" if regList{7..2} cat M != 0 then ", " end if end if 
  if regList{2} then "r2" if regList{7..3} cat M != 0 then ", " end if end if 
  if regList{3} then "r3" if regList{7..4} cat M != 0 then ", " end if end if 
  if regList{4} then "r4" if regList{7..5} cat M != 0 then ", " end if end if 
  if regList{5} then "r5" if regList{7..6} cat M != 0 then ", " end if end if 
  if regList{6} then "r6" if regList{7..7} cat M != 0 then ", " end if end if 
  if regList{7} then "r7" if                   M != 0 then ", " end if end if 
  if M          then "lr" end if 
  "}"
end syntax

syntax extend #XT
  select
    case #signed   "s"
    case #unsigned "u"
  end select
  "xt"
  select
    case #reg8  "b\t"
    case #reg16 "h\t"
  end select
  reg2
end syntax

syntax compareAndBranch
  select
    case #CBZ  "cbz\t"
    case #CBNZ "cbnz\t"
  end select
  Rn ", " label7
end syntax

syntax loadStoreMulti #multipleWord
  select 
    case #load  "ldmia\t" Rn 
    field u3 Rn
		field u8 regList
		if regList{Rn} != 1 then "!" end if
    ", "
    case #store "stmia\t" Rn "!, "
  end select
  reglist
end syntax

syntax branch #branch #cond
  "b" cond ".n\t" label9
end syntax

syntax udf #udf "udf\t" imm8 end syntax
syntax svc #svc #imm8 field u8 imm8 "svc\t\d",imm8 end syntax

syntax label9 #imm9 
  field s9 imm9 
  "\x",(s32)(instruction address) + imm9 + 4s 
  -- show label information as in objdump
  " <" function "+0x\x>",((s32)(instruction address) + imm9 + 4s - (s32)(function address))
end syntax

syntax label7 #imm7
  field u7 imm7
  "\x",(instruction address) + imm7 + 4 
  -- show label information as in objdump
  " <" function "+0x\x>",(instruction address+ imm7 + 4 -function address)
end syntax

syntax imm10     #imm10 field u10 imm10 "#\d",imm10 end syntax -- value used as an addres (x4)
syntax imm9      #imm9  field u9  imm9  "#\d",imm9  end syntax -- value used as an addres (x4)
syntax imm8      #imm8  field u8  imm8  "#\d",imm8  end syntax
syntax imm7      #imm7  field u7  imm7  "#\d",imm7  end syntax -- value used as an addres (x4)
syntax imm6      #imm6  field u7  imm6  "#\d",imm6  end syntax -- value used as an addres (x2)
syntax imm5      #imm5  field u5  imm5  "#\d",imm5  end syntax
syntax imm3      #imm3  field u3  imm3  "#\d",imm3  end syntax
syntax Rm        #Rm    field u3  Rm    "r\d",Rm    end syntax
syntax Rd        #Rd    field u3  Rd    "r\d",Rd    end syntax
syntax Rn        #Rn    field u3  Rn    "r\d",Rn    end syntax
syntax Rt        #Rt    field u3  Rt    "r\d",Rt    end syntax
syntax imm5Shift #imm5  field u5  imm5 if imm5 = 0 then "#32" else "#\d",imm5 end if end syntax

syntax Rm4  #Rm 
		field u4 Rm 
		if    Rm =15 then "pc" 
		elseif Rm=14 then "lr"
		elseif Rm=13 then "sp"
		else   "r\d",Rm
    end if
end syntax

syntax Rd4  #Rd 
		field u4 Rd 
		if    Rd =15 then "pc" 
		elseif Rd=14 then "lr"
		elseif Rd=13 then "sp"
		else   "r\d",Rd
    end if
end syntax

syntax Imm5Reg2      Rd  ", "  Rm ", " imm5          end syntax
syntax Imm5Reg2Shift Rd  ", "  Rm ", " imm5Shift     end syntax -- replace if imm5 = 0, value is 32.
syntax reg3          Rd  ", "  Rn ", " Rm            end syntax
syntax reg2          Rd  ", "  Rm                    end syntax
syntax reg2Rn        Rd  ", "  Rn                    end syntax
syntax imm3reg2      Rd  ", "  Rn ", " imm3          end syntax
syntax imm8reg       Rd  ", "  imm8                  end syntax
syntax reg2_4bits    Rd4 ", "  Rm4                   end syntax
syntax reg3Rt        Rt  ", [" Rn ", " Rm        "]" end syntax 
syntax regImm5reg2Rt Rt  ", [" Rn ", " imm5      "]" end syntax 
syntax regImm6reg2Rt Rt  ", [" Rn ", " imm6      "]" end syntax 
syntax regImm7reg2Rt Rt  ", [" Rn ", " imm7      "]" end syntax 

syntax condWithAl #cond -- version of cond that prints the 'al' condition.
		field u4 cond
		cond
		if cond = 14 then "al" end if
		if cond = 15 then "<und>" end if
end syntax

syntax cond #cond
  field u4 cond
  if     cond = 0  then "eq"
  elseif cond = 1  then "ne"
  elseif cond = 2  then "cs"
  elseif cond = 3  then "cc"
  elseif cond = 4  then "mi"
  elseif cond = 5  then "pl"
  elseif cond = 6  then "vs"
  elseif cond = 7  then "vc"
  elseif cond = 8  then "hi"
  elseif cond = 9  then "ls"
  elseif cond = 10 then "ge"
  elseif cond = 11 then "lt"
  elseif cond = 12 then "gt"
  elseif cond = 13 then "le"
  end if
  -- 14 is 'always but do not have a mnemonic
  -- 15 should not happen.
end syntax

}
-- errorformat=%f:%l:%c:%m
-- makeprg=gadl\ \%
-- vim:ft=hadl:ts=2:sw=2:tw=0
