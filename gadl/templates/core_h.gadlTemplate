%template headerC%
#ifndef __%!MODELNAME%_CORE_H__
#define __%!MODELNAME%_CORE_H__

#include "types.h"
#include "storage.h"
#include "macro.h"
#include "instructionBase.h"
#include "fifo.h"
#include <vector> 
#include <string>
#include <string.h> //required by Linux for memcpy...

#include <map> //used for breakpoints.
class breakpointAction;
class executeAction;
class %!MODELNAME%_instDecoder;
class %!MODELNAME%_instruction;
class codeReader;

#ifdef DEBUG_MEM
#include <assert.h>
#endif //DEBUG_MEM

// SP Check
#ifdef GADL_SP_CHECK_ALLOWED
	class stackSpyController;
#endif
#ifdef GADL_WITH_PIPELINE_TRACE
	class pipelineTraceDebug;
#endif

%if exists timingList then
if [timingList length] > 0 then
%//timing parts.
#include "timingSignal.h"
class timingBase;
%end if
foreach timing in timingList do
  %#include "timing_%!timing::name%.h"\n% #tmp: only the timing for activation is required.
end foreach
end if #timingList exists

if useCAS then
  foreach pipeline in pipelineList 
  before
  %//pipeline models declaration\n%
  do
    %class %!pipeline::name%;\n%
  end foreach
  if exists DDCRegInfo then
    %//DDC register mask definition\n%
    foreach reg in DDCRegInfo do
      %#define DDC_REGISTER_MASK_%!reg::regName% (1<<%!reg::id%)\n%
    end foreach
  end if
end if
%

class core
{
	public:
		/** ISS (Instruction Set Simulation) mode or
		 *  CAS (Cycle Accurate Simulation) mode.
		 */ 
		enum executionMode {ISS, CAS};
		
		///constructor
		core();

		/** 
		 * Stop the simulation (breakpoint, ..)
		 * \param : reason: see m_stopSimu var
		 */
		void stopSimu(int);

	private:
		/** values are the same than in gdb-server.
		 *  0  : Run
		 *  18 : Stopped by user
		 *  5  : Breakpoint found 
		 */
		int m_stopSimu; 

		/** used for breakpoints (interactive simulation). Breakpoints use actions.
		 * When a breakpoint is defined at an address, an action is inserted. 
		 * This variable store the address of the last breakpoint found.
		 */
		u32  m_lastBreakpointAddr;
		
		/** map that stores a pointer for each action. This is useful to
		*  remove all breakpoints. Key is the address (in program chunk).
		*/  
		std::map<u32, breakpointAction *> m_breakpointActionMap; 
		
		/** object that read a program file from a Intel Hex, 
		 *  Motorola SRecord or Elf format and store code in memory.
		 *  It can also handle symbols.
		 */
		codeReader *m_reader;
	
		///core memory chunks declaration.
%foreach memInCore in memInCoreList do
  let storageName := memInCore::name."_memChunk"
  %\t\t%
  if memInCore::type == 0 then %roStorage% #ROM
  else %rwStorage%
  end if
  % *%!storageName%;\n%
 end foreach
%
		///registers (global use) var declaration
%foreach reg in idfStruct::varList do
  if reg::varClassId == 0 #program counter
   | reg::varClassId == 1 #GPR
   | reg::varClassId == 2 then #SFR
    %\t\t%!reg::type% m_%!reg::name%;\n%
  end if
end foreach
%

		///store the number of cycles executed since the beginning of the simulation.
		///value is not updated in ISS mode.
		u64 m_nbCycles;
		///store the number of instruction executed since the beginning of the simulation.
		///value is updated both in CAS and ISS modes.
		u64 m_nbInst;
		
		///pointer to the decoder... that decodes instructions :-)
		%!MODELNAME%_instDecoder *m_decoder;
	
		///ISS (Instruction Set Simulation) mode or
		///CAS (Cycle Accurate Simulation) mode.
		executionMode m_executionMode;
	
		/// Exec instruction (ISS mode)
		/// \param nb number of instruction to execute.
		int emuInst(const unsigned int nb);

%if exists useCounters then
%		//counters of component method accesses.\n%
  foreach counter in counterMap do
    %		u64 %!KEY%;\n%
  end foreach
end if
%
		/* Stack Spy */
		#ifdef	GADL_SP_CHECK_ALLOWED
		stackSpyController *m_stackController;
		#endif

		//internal function related to file I/O stubs.
		bool addIOStub(executeAction *act, std::string funcName);

%if useCAS then
   foreach pipeline in pipelineList 
   before
   %		//pipeline models instance\n%
   do%
		%!pipeline::name% *m_pipeline%!pipeline::name%;
		%!MODELNAME%_instruction *m_nextInstruction_%!pipeline::name%;
%    let pipelineBufferSize := 1 << nbBitsToCodeUnsigned([pipeline::stageList length] - 1)
%		%!MODELNAME%_instruction *m_instructionsInPipeline_%!pipeline::name%[%!pipelineBufferSize%];
		u64 m_instInPipe_%!pipeline::name%;
		//*******  Data Cache (TODO:Hand coded).*****
		u64 m_memStage; //TODO: will not work if more than 1 pipeline!
		fifo<u32> *m_fifoMemAccessTab[%!pipelineBufferSize%];
   %end foreach
end if #useCAS
%

		#ifdef GADL_WITH_PIPELINE_TRACE
		pipelineTraceDebug *m_pipelineTrace;
		#endif
   
		//*******  DDC related part.
		u64 m_DDCInstRequireStage; //used to get instruction in stage 'F'
		u64 m_DDCInstLockStage;    //used to get instruction in stage 'D'
		fifo<u64> *m_fifoDDC;      //fifo to store registers locked in the DDC.
		//registers that are used in the pipeline (locked).
		u64 m_DDCregsInUse;
		//registers that are required to get into the exec pipeline stage (not to get it from inst each time)
		u64 m_DDCCurrentReadRegs; 
		//return 0 if there is no DDC related lock.
		inline bool testDDCLock() {return ((m_DDCregsInUse & m_DDCCurrentReadRegs) != 0);}
		//main function for DDC management. Used each cycle.
		void DDCManagement(const unsigned int notification);
		void debugDDCRegField(); //debug.
%if useCAS then
%		//DDC register file access (R/W);
%foreach memInfo in DDCRegFileMemInfo do %		u64 m_DDCreadRegFile%!memInfo::memoryId%Access;
		u64 m_DDCwriteRegFile%!memInfo::memoryId%Access;
%end foreach
%		u64 m_DDCreadRegAccess;
		u64 m_DDCwriteRegAccess;
%
end if #useCAS
%\n		//timing related automata.
%
if exists timingList then
foreach timing in deviceToTimingMap do
  %\t\ttiming%!timing% *m_timing%!KEY%;\n%
end foreach
if [timingList length] > 0 then
%		timingBase *m_pendingSignalEmitTab[NB_SIGNAL_EMIT];
		timingBase *m_pendingSignalWaitTab[NB_SIGNAL_WAIT];
		timingBase *m_timingListRoot;
		u64 m_timingNextWakeUp;
		//this function is called when this is the date to wake up an automata
		void manageTiming();
%end if
end if #exists timingList
%public:

		/*******************************************************************
		 *  status
		 *******************************************************************/
		///debugging info
		void decoderStats();
		/** get number of cycles executed since the beginning of the simulation.
		 * This value is not modified in ISS mode (functional)
		 */
		inline unsigned long long const getNBCycles() const {return m_nbCycles;};
		/// get number of instruction executed since the beginning of the simulation.
		inline unsigned long long const getNBInstructions() const {return m_nbInst;};
		/** generic function to access the program counter */
		inline %!idfStruct::PC_C_TYPE% programCounter() {%if useCAS then%
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_%!idfStruct::PC_NAME%; %end if%
			return m_%!idfStruct::PC_NAME%;};
		
		/** returns the function symbol for a given address (typically program counter). (for ELF files). */
		std::string whichFunctionAtAddress(const u32 v_addr);

		/** Disassemble binary code.
		* \param ipStart Instruction Pointer from which the disassemble is started
		* \param nbBytes Number of bytes to disassemble: Value may be exceeded: 
		* i.e. if set to 1 to decode a 32 bits instruction, 1 instruction will be decoded.
		* \param verbose return also the address where the code is decoded and the opcode of the instruction.
		*/ 
		std::string disassemble(const unsigned int pcStart, const int nbBytes, bool verbose = false);
		/** print the value of all variables defined as 'register' in the description
          * It does not take into account memory chunk defined has 'register'
          */
		void printRegs();
		/* @return the physical address. 
		 * If no physical address is matching, the virtual address is returned
		 * and found is set to false.
	 	 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			u32 getPhysicalAddress(const u32 v_addr, bool &OUTPUT);
		#else
			u32 getPhysicalAddress(const u32 v_addr, bool &found);
		#endif
		/* this function search for the virtual address and size of the symbol name (first parameter).
		 * @return true if a symbol have been found, and updates v_addr and size
		 * @return false if no symbol is matching. v_addr and size are not updated.
		 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			bool getSymbolObjectAddress(const char *symbolName, u32 &OUTPUT, u32 &OUTPUT);
		#else
			bool getSymbolObjectAddress(const char *symbolName, u32 &v_addr, u32 &size);
		#endif
		/* this function search for the virtual address of the function (first parameter).
		 * @return true if a function have been found, and updates v_addr 
		 * @return false if no function is matching. v_addr and size are not updated.
		 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			bool getFunctionName(const char *symbolName, u32 &OUTPUT);
		#else
			bool getFunctionName(const char *symbolName, u32 &v_addr);
		#endif
		
		/** print all object symbols (for ELF files)*/
		void dumpObjects();
		/** print all function symbols  (for ELF files)*/
		void dumpFunctions();

		/** Use this function to record the pipeline trace.. Simulation is quite slower. */
		void usePipelineTrace();
		/** Output pipeline trace to a .ptr file 
		 *  @see pipelineTraceDebug.h
		 */
		void outputPipelineTrace(const std::string filename);

		/** return the instruction object at address. Note that p_addr is modified and 
		 * updated to point to the next instruction address.
		 **/
		#ifdef SWIG /*Swig wrapper (for Python interface)*/		
			std::string getInstructionStaticInfo(unsigned int &INOUT);
		#else
			std::string getInstructionStaticInfo(unsigned int &p_addr);
		#endif

		/*******************************************************************
		 *  Breakpoints
		 *******************************************************************/
		/** remove all breakpoints (interactive simulation) */
		void removeAllBreakpoints();
		/** remove a breakpoint for interactive simulation */
		void removeBreakpoint(const unsigned int addr);
		/** remove a breakpoint for interactive simulation */
		void removeBreakpoint(const char *symbolName);
		/** add a breakpoint for interactive simulation
		 *  An error is generated if there is already a breakpoint at this addr.
		 */
		void addBreakpoint(const unsigned int addr);
		/** add a breakpoint for interactive simulation */
		void addBreakpoint(const char *symbolName);

		/*******************************************************************
		 *  Configuration
		 *******************************************************************/
		/** Set the simulator mode:
		 *  - ISS: Instruction Set Simulator
		 *  - CAS: Cycle Accurate Simulator
		 */
		void setExecutionMode(const executionMode mode);
		/** install io stubs to support open, close, read and write functions.
		 * These functions are mapped to the host, using actions.
		 * It returns true if there was no error.
		 * This function requires extra files (ioStubs.cpp and .h) that are nor yet
		 * generated by the Harmless compiler (have a look in the example folder)
		 * Moreover, the USE_IO_STUBS should be set to 1 in the Makefile and it requires
		 * actions.
		 */
		bool useIOStubs();
		
		/*******************************************************************
		 *  Execution
		 *******************************************************************/
		/// restore the cpu in the init state (called in constructor)
		void reset();
		/** Read a code file with 
		 *  - Intel Hex format
		 *  - Motorola SRecord format
		 *  - ELF format (if linked with the appropriate library).
		 *  (no CRC verification)
		 *  \return true if the code file is correctly read.
		 */  
		bool readCodeFile(const char *filename, const bool verbose = false);
		/** simulate instructions of the processor.
		* The simulator may be in CAS or ISS mode
		* \param nb number of instruction to execute.
		* \return what causes the execution to stop : 18 on user stop, 5 on breakpoint or 0 on success
		*/ 
		int execInst(const unsigned int nb);

		/** run simulation until PC=addr. It does not take into account segmentation!!
		 *  \param addr the address compared to the program counter
		 *  \param max the max number of instruction to execute.
		 */
		void runUntil(const unsigned int addr, const unsigned int max);

		/** generic function to access the program counter */
		inline void setProgramCounter(const %!idfStruct::PC_C_TYPE% val) { %if useCAS then%
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_%!idfStruct::PC_NAME%; %end if%
			m_%!idfStruct::PC_NAME% = val;};

		/** return the object that reads the binary application code */
		codeReader *getCodeReader() {return m_reader;};

		/*******************************************************************
		 * Stack/Task observation.
		 *******************************************************************/
		/* Stack SPY */
		#ifdef	GADL_SP_CHECK_ALLOWED
		inline stackSpyController* getStackSpyController(){return m_stackController;};
		#endif
		/*******************************************************************
		 *  Internals :public functions that are accessed by other
		 *             simulators objects: memory, actions, ...
		 *             THEY SHOULD NOT BE CALLED DURING SIMULATION.
		 *******************************************************************/
		/**
		 * This is an internal function that SHOULD ONLY be called 
		 * from harmless instructions.
		 */
		inline void addCycle(unsigned int val) {m_nbCycles += val;};

		void removeExecuteActionAtAddress(const u32 addr, executeAction *ea);
		void addExecuteActionAtAddress(const u32 addr, executeAction *ea);
		/** this method should ONLY be called by an action that is 
		 *  associated to a breakpoint (interactive simulation)
		 */
		inline void actionFoundABreakpoint(const u32 addr) {stopSimu(5); m_lastBreakpointAddr = addr;};
		/** return the memory chunk that contains 'address'. This is used for program loading. */
		storage * getProgramChunk(const unsigned int address);
		/** this method is called by instructions that have a 'nop' statement:
         *  'add xx nop'
		 * This method will be called to decode (and NOT execute) the next xx (val)
		 * instructions. Instructions should be decoded if not all the instructions
		 * have the same size: TODO: optimize for the other case.
		 */
		void doNotExececuteNextInstructions(const u32 val);

%if useCAS then
   foreach pipeline in pipelineList do 
%		/** pipeline model related function */
		unsigned int getNextInstructionCodeIn_%!pipeline::name%();
		/** pipeline model related function */
		unsigned int getExternalResourcesState_%!pipeline::name%();
%  end foreach
 end if
%
		bool execOneCycle(); //TODO: remove.

		/** internal function that translates an address from the linker
          * to a real address in the global memory address.
          */
		u32 linkerAddressTranslation(u32 addr);
		/** This is the default fetch function used in the decode phase. Another Fetch function can be defined
         *  and should be declared in the default section of the .hadl processor description
         *  This function just get a word (size is defined in instruction size in the default section) in 
         *  memory, update the pc in parameter and returns the value reads in memory.
		 * If no user fetch function is defined, this one is used each time a program word is read. Note that
		 * due to the instruction cache, the function may not be called!
		 * If a user fetch function is defined, the default fetch function is used for the disassembler.
         */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			inline %!INST_DEFAULT_C_SIZE% defaultFetch(%!idfStruct::PC_C_TYPE% &INOUT)
		#else
			inline %!INST_DEFAULT_C_SIZE% defaultFetch(%!idfStruct::PC_C_TYPE% &pc)
		#endif
		{
			unsigned int realAddress = getFetchAddress(pc);
			roStorage *codeMem = (roStorage *)getProgramChunk(realAddress);
			const %!INST_DEFAULT_C_SIZE% instCode = codeMem->read%!INST_SIZE_IN_BITS%AtAddress(realAddress);
			pc += %!INST_SIZE_IN_BYTES%;
			return instCode;
		}

		inline u32 getFetchAddress(u32 address)
		{
			 return %
		if fetchAddressComponentName != "" then
			!fetchAddressComponentName%_%!fetchAddressMethodName%(address)%
		else
			%address%
		end if%;
		}
%if useCAS then%
		//this function should be called ONLY by the execute method of an instruction.
		inline void initDDCRegAccess() {
			%foreach memInfo in DDCRegFileMemInfo do %
			m_DDCreadRegFile%!memInfo::memoryId%Access  = 0;
			m_DDCwriteRegFile%!memInfo::memoryId%Access = 0;
			%end foreach%
			m_DDCreadRegAccess = 0;
			m_DDCwriteRegAccess = 0;
		};
%foreach memInfo in DDCRegFileMemInfo do %
		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegFile%!memInfo::memoryId%AccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegFile%!memInfo::memoryId%Access;
			w=m_DDCwriteRegFile%!memInfo::memoryId%Access;
		};
%end foreach%
		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegAccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegAccess;
			w=m_DDCwriteRegAccess;
		};
%end if #useCAS
		if exists timingList then
			if [timingList length] > 0 then
%		//timing simulation steps accessors
		void timingWaitForCycles(timingBase *,const u64 nbCycles);
		bool timingSynchroEmit(timingBase *,unsigned int sigName, const bool broadcast);
		bool timingSynchroWait(timingBase *,unsigned int sigName);
%			end if
		end if%
		/*******************************************************************
		 * Automatically generated functions.
		 *******************************************************************/

		/** Memory Access */
%
let memSpaceMap := mapOf idfStruct::memSpaceList by name
foreach mem in memSpaceMap do
  #one getChunk for each mem space.
  %\t\tinline storage *get_%!mem::name%_chunk(const u32 address)\n\t\t{\n%
  let addr := "address"
  if mem::stride != 0 then
    let addr := "addressWithStride"
    %\t\t\tconst u32 %!addr% = address << %!mem::stride%;\n%
  end if
  let first := True
  let nbMemChunks := 0 #can optimize if there is only one.
  let storageName := ""
  foreach memChunk in memInCoreList do
    if mem::name == memChunk::memSpaceName then #chunk in same address space
      let nbMemChunks := nbMemChunks + 1
      %\t\t\t%
      if not first then %else % else let first := False end if
      let max := memChunk::baseAddress + memChunk::size -1
      let storageName := memChunk::name."_memChunk"
      %if(%
      if memChunk::baseAddress != 0 then
        !addr% >= %!memChunk::baseAddress% && %
      end if
      !addr% <= %!max%) return %!storageName%;\n%
    end if
  end foreach
  %\t\t\tstd::cerr << "Memory Access Error: invalid access at address 0x"\n%
  %\t\t\t          << std::hex << %!addr% << ", in memory space \'%!mem::name%\'." << std::endl;\n%
  %\t\t\treturn 0;\n\t\t}\n%
  foreach methodSize in mem::methodSizeList do
    #R/W access
    let type := CType(methodSize::size)
    let addressWithStride := "address"
    if mem::stride != 0 then let addressWithStride := "address << ".[mem::stride string] end if
    #read access.
    %\t\tinline u%!type% %!mem::name%_read%!methodSize::size%(const u32 address)\n\t\t{\n%
    if nbMemChunks > 1 then
      %\t\t\troStorage *sto = (roStorage *)get_%!mem::name%_chunk(%!addressWithStride%);\n%
      %\t\t\t#ifdef DEBUG_MEM\n%
      %\t\t\t\tassert(sto);\n%
      %\t\t\t#endif //DEBUG_MEM\n%
      %\t\t\treturn sto->%
    else #optimisation (about 20-30% with the ISS).
      %\t\t\t#ifdef DEBUG_MEM\n%
      %\t\t\t\tassert(get_%!mem::name%_chunk(%!addressWithStride%));\n%
      %\t\t\t#endif //DEBUG_MEM\n%
      %\t\t\treturn %!storageName%->%
    end if
    %read%!type%AtAddress(%!addressWithStride%);\n%
    %\t\t}\n%
    #write access.
    %\t\tinline void %!mem::name%_write%!methodSize::size%(const u32 address, const u%!type% value)\n\t\t{\n%
    if nbMemChunks > 1 then
      %\t\t\trwStorage *sto = (rwStorage *)get_%!mem::name%_chunk(%!addressWithStride%);\n%
      %\t\t\t#ifdef DEBUG_MEM\n%
      %\t\t\t\tassert(sto);\n%
      %\t\t\t#endif //DEBUG_MEM\n%
      %\t\t\tsto->%
    else
      %\t\t\t#ifdef DEBUG_MEM\n%
      %\t\t\t\tassert(get_%!mem::name%_chunk(%!addressWithStride%));\n%
      %\t\t\t#endif //DEBUG_MEM\n%
      %\t\t\t%!storageName%->%
    end if
    %write%!type%AtAddress(%!addressWithStride%, value);\n%
    %\t\t}\n%
  end foreach
end foreach
%
		/** components implementation*/
%
let DDCRegFileChunkMap := emptyMap
if exists DDCRegFileChunk then
  let DDCRegFileChunkMap := mapOf DDCRegFileChunk by key
end if
foreach component in componentList
do
	%\t\t/*********** component %!component::name% ************/\n%
	foreach method in component::methodList
	do
		let key := component::name."_".method::name
		%\t\tinline %!method::returnTypeStr% %!component::name%_%!method::name%(%!method::paramStr%) {\n%
		if useCAS then
			if exists DDCRegFileChunkMap[key] then #this is a DDC related function (read or write).
				let reg := "m_DDC".DDCRegFileChunkMap[key]::access."RegFile".DDCRegFileChunkMap[key]::memoryId."Access"
				%\t\t\t//DDC related function (%!DDCRegFileChunkMap[key]::access%)\n%
				%\t\t\t%!reg% |= 1<<address;\n%
			end if
			if useCAS then
				#TODO: Temporary for Data Cache -> UGLY
				foreach pipeline in pipelineList 
				before
				do
					let pipelineBufferSize := 1 << nbBitsToCodeUnsigned([pipeline::stageList length] - 1)
					let firstPipelinebufferMask := pipelineBufferSize - 1
					if component::name == "mem" & method::name != "getChunk" then
						if exists archList then
							foreach arch in archList do
								foreach spl in arch::sharedPortActivationList do
									if spl::port == "loadStore" then #special case for the load store: HAND CODED!
										%\t\t\tm_fifoMemAccessTab[m_nbCycles & %![firstPipelinebufferMask hexString]%]->write(address);\n%
									end if
								end foreach
							end foreach
						end if
					end if
				end foreach
		    end if
		end if #useCAS
	    let keyCount := "counter_".key
		if exists counterMap[keyCount] then #access counter
			%\t\t\t%!keyCount%++;\n%
		end if
		!method::codeStr
		%\n\t\t}\n%
	end foreach
end foreach
%		
		/** local registers accessors */
%
foreach reg in idfStruct::varList do
  if reg::varClassId == 0 #program counter
   | reg::varClassId == 1 #GPR
   | reg::varClassId == 2 #SFR
   | reg::varClassId == 3 then #reg fields.
    %\t\t//register %!reg::name% access\n%
    ##### getter code #####
    %\t\tinline %!reg::type% %!reg::name%() {\n%
    let key := "counter_read_".reg::name #access counter
    if exists counterMap[key] then
      %\t\t\t%!key%++;\n%
    end if
    if useCAS then
      %\t\t\tm_DDCreadRegAccess |= DDC_REGISTER_MASK_%!reg::name%;\n%
    end if
    #effective code
    %\t\t\t%!reg::getter%\n\t\t};\n%
    ##### setter code #####
    %\t\tinline void set%!reg::name%(const %!reg::type
    if reg::constant then 
      %) {% 
    else
      % value) {\n%
      if useCAS then
        %\t\t\tm_DDCwriteRegAccess |= DDC_REGISTER_MASK_%!reg::name%;\n%
      end if
      #effective code
      !reg::setter%\n%
    end if #constant
    let key := "counter_write_".reg::name #access counter
    if exists counterMap[key] then
      %\t\t\t%!key%++;\n%
    end if
    %\t\t};\n%
  end if #varClass id
end foreach

if exists useCounters then
%		//accessors for counters of component method and registers accesses.\n%
  foreach counter in counterMap do
    %		inline u64 const get_%!KEY%() { return %!KEY%;};\n%
  end foreach
end if
%
};
#endif 
