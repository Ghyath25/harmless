%template headerC%
#ifndef __TIMING_%!className%_H__
#define __TIMING_%!className%_H__

#include <iostream>
#include "timingBase.h"
#include "types.h"
#include "fifo.h"
#include "timingRun.h"

class %!baseName%;
class timingRun;
class timingRdv; //synchronisation.

class %!className% : public timingBase {\n
	typedef enum {
%let sigId := 0
foreach sig in timingPart::signalEmit do
%		%!sig::name%=%!sigId
let sigId := sigId+1
between %,\n%
end foreach
let nbSigOut := sigId%
	} enumSigOut;
	static const size_t NB_SIG_OUT = %!sigId%; 
 
 	typedef enum {
%let sigId := 0
foreach sig in timingPart::signalWait do
%		%!sig::name%=%!sigId
let sigId := sigId+1
between %,\n%
end foreach
let nbSigIn := sigId%
	} enumSigIn;
	static const size_t NB_SIG_IN = %!sigId%;

	//pointers to synchronisation objects.
%if nbSigOut!=0 then%	timingRdv *m_sigOut [NB_SIG_OUT];%end if%
%if nbSigIn!=0 then%	timingRdv *m_sigIn [NB_SIG_IN];%end if%

	%!baseName% *m_peripheral; 
	const unsigned int m_inOffset;
	const unsigned int m_outOffset;
%foreach var in timingPart::localVar do
%	%!var::declare% \n%
end foreach
let id := 0
%	//declare simulation steps\n%
foreach step in timingPart::timingStepList do
%	bool step_%!id%();
%let id := id + 1
end foreach
%	typedef bool (%!className%::* stepPtr)();
	stepPtr nextStep; //points to the next step
//	fifo<u32> *m_accessFifo;
	public:
	%!className%(timingRun *tr, %!baseName% *peripheral, const unsigned int inOffset, const unsigned int outOffset) : 
	timingBase(tr),
	m_peripheral(peripheral),
	m_inOffset(inOffset),
	m_outOffset(outOffset)
	{
		init();
	};

	virtual void run() {
		while(currentState() == READY) 
		{
			(this->*nextStep)();
		}
%		#deprecated?
		let addrFound := 0
		foreach var in timingPart::localVar do
			if var::name == "addr" then let addrFound := 1 end if
		end foreach
        if addrFound==1 then
%		if(isInit() && m_accessFifo->read(addr)) //init state, and read was a success (i.e. not empty)
		{
			run(); //recursive call. (not a big depth!).
		}
%end if
%	}
	virtual void init() {
		nextStep = &%!className%::step_0;
//		m_accessFifo = new fifo<u32>("timing %!className% fifo",16); //arbitrary max val
	};
	bool isInit() {return nextStep == &%!className%::step_0;};
	virtual std::string toString() {return std::string("%!className%");};
//	void insertInDataCacheFifo(const u32 addr)
//	{
//		m_accessFifo->write(addr);
//	}	
};
#endif // __TIMING_%!className%_H__
