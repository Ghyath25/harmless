#include <iostream>
#include <sstream> //stringstream
#include "logManager.h"
//#define NDEBUG (uncomment to disable assert())
#include <cassert>
#include "timingBase.h"
using namespace std;

bool logManager::alreadyCreated = false;
logManager _logManager; //unique instance.
logManager *log()
{
	return &_logManager;
}

logEventTiming::logEventTiming(timingBase *timing,int fromState,int toState)
{
	assert(timing != NULL);
	m_date = timing->nbCycles();
	m_timing = timing;
	m_fromState = fromState;
	m_toState = toState;
}

string logEventTiming::data(outFormat format,int nbTab)
{
	string state[4] = {"SUSPENDED","READY","WAITTIME","WAITEVENT"};
	stringstream result;
	result << string(nbTab,'\t');
	switch(format) {
		case txt: 
			result << "date " << m_date << " ";
			result << m_timing->name() << "	:";
			result << state[m_fromState] << " -> " << state[m_toState];
			break;
		case xml:
			result << "<timingEvent";
			result << " id=\"" << m_timing->name() << "\"";
			result << " date=\"" << m_date  << "\"";
			result << " from=\"" << state[m_fromState] << "\"";
			result << " to=\""   << state[m_toState]   << "\"";
			result << "/>";
			break;
	}
	return result.str();
}

void logManager::addLogTiming(timingBase *timing, int fromState, int toState)
{
	m_eventList.push_back(new logEventTiming(timing,fromState,toState));
}

void logManager::addItem(logItem *item)
{
	m_eventList.push_back(item);
}

//TODO: tmp
void logManager::testOut(logItem::outFormat format)
{
	cout << prologue(format);
	const int size = m_eventList.size();
	for(int i=0;i<size;i++)
	{
		cout << m_eventList[i]->data(format) << endl;
	}
	cout << epilogue(format);
}

string logManager::prologue(logItem::outFormat format)
{
	stringstream result;
	switch(format) {
		case logItem::txt: 
			break;
		case logItem::xml:
			result << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n";
			result << "<root><events>\\n";
			break;
	}
	return result.str();
}

string logManager::epilogue(logItem::outFormat format)
{
	stringstream result;
	switch(format) {
		case logItem::txt: 
			break;
		case logItem::xml:
			result << "</events>\\n</root>\\n";
			break;
	}
	return result.str();
}

logConfigItem::logConfigItem(configType type, std::string name, std::string instanceName) :
	m_type(type),
	m_name(name),
	m_instanceName(instanceName)
{
}

void logConfigItem::addItem(logConfigItem *item)
{
	m_itemList.push_back(item);
}

string logConfigItem::data(outFormat format,int nbTab)
{
	string type[] = {"cpu","peripheral","timing","memory"};
	stringstream result;
	string tabs = string(nbTab,'\t');
	result << tabs;
	switch(format) {
		case logItem::txt: 
			break;
		case logItem::xml:
			result << "<config type=\""+type[m_type]+"\" ";
			result << "name=\""<<m_name<<"\" ";
			result << "instance=\""<<m_instanceName<<"\" ";
			result << ">\\n";
			const int size = m_itemList.size();
			for(int i=0;i<size;i++)
			{
				result << m_itemList[i]->data(format,nbTab+1);
			}
			result << tabs << "</config>\\n";
			break;
	}
	return result.str();
}

