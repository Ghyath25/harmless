%template headerC%
#ifndef __%!MODELNAME%_ARCH_H__
#define __%!MODELNAME%_ARCH_H__

#include "types.h"
#include "storage.h"
#include "macro.h"
#include "instructionBase.h"
#include "fifo.h"
#include <vector> 
#include <string>
#include <string.h> //required by Linux for memcpy...
#include "componentTypeDef.h" //typedefs in components.

#include <map> //used for breakpoints.
class breakpointAction;
class executeAction;
class %!MODELNAME%_instDecoder;
class %!MODELNAME%_instruction;
class codeReader;

// SP Check
#ifdef GADL_SP_CHECK_ALLOWED
	class stackSpyController;
#endif
#ifdef GADL_WITH_PIPELINE_TRACE
	class pipelineTraceDebug;
#endif

%if [timingList length] > 0 then
%//timing parts.
#include "timingSignal.h"
class timingBase;
%end if
foreach timing in timingList do
  %#include "timing_%!timing::name%.h"\n% #tmp: only the timing for activation is required.
end foreach

if useCAS then
   foreach pipeline in pipelineList 
   before
   %//pipeline models declaration\n%
   do
    %class %!pipeline::name%;\n%
   end foreach
   if exists DDCRegInfo then
      %//DDC register mask definition\n%
     foreach reg in DDCRegInfo do
       %#define DDC_REGISTER_MASK_%!reg::regName% (1<<%!reg::id%)\n%
     end foreach
   end if
 end if
%
//cyclic part related structure (every)
struct cyclicPartNode {
	int id; //id of the cyclic part to run
	u64 wakeUpDate;
	cyclicPartNode *next;
	cyclicPartNode(int _id, u64 _wakeUpDate, cyclicPartNode *_next) : id(_id), wakeUpDate(_wakeUpDate), next(_next) {}
};

//cyclic part related typedefs ('every' construction)
typedef void (arch::*__cyclicFunc_%!MODELNAME%)();
typedef int  (arch::*__cyclicNextFunc_%!MODELNAME%)();

class arch
{
	public:
		/** ISS (Instruction Set Simulation) mode or
		 *  CAS (Cycle Accurate Simulation) mode.
		 */ 
		enum executionMode {ISS, CAS};
		
		///constructor
		arch();

		/** 
		 * Stop the simulation (breakpoint, ..)
		 * \param : reason: see m_stopSimu var
		 */
		void stopSimu(int);

	private:
		/** values are the same than in gdb-server.
		 *  0  : Run
		 *  18 : Stopped by user
		 *  5  : Breakpoint found 
		 */
		int m_stopSimu; 

		/** used for breakpoints (interactive simulation). Breakpoints use actions.
		 * When a breakpoint is defined at an address, an action is inserted. 
		 * This variable store the address of the last breakpoint found.
		 */
		u32  m_lastBreakpointAddr;
		
		/** map that stores a pointer for each action. This is useful to
		*  remove all breakpoints. Key is the address (in program chunk).
		*/  
		std::map<u32, breakpointAction *> m_breakpointActionMap; 
		
		/** object that read a program file from a Intel Hex, 
		 *  Motorola SRecord or Elf format and store code in memory.
		 *  It can also handle symbols.
		 */
		codeReader *m_reader;

		%!PC_C_TYPE% m_%!PC_NAME%;
	
		///memory chunks declaration.
%foreach component in componentList do
  foreach memory in component::memoryChunks do
    let storageName := component::name."_".memory::name."Chunk"
    %\t\t%
    if memory::type == 0 then %roStorage% #ROM
    else %rwStorage%
    end if
    % *%!storageName%;\n%
  end foreach
end foreach%
		///component local var declaration
%foreach component in componentList do
  foreach var in component::localVar do
    %\t\t/* component %!component::name%, local var %!var::name%*/\n%
    %\t\t%!var::declare%\n%
  end foreach
end foreach%
		///registers (global use) var declaration
%foreach component in componentList do
  foreach reg in component::registers do
    %\t\t%!reg::type% %!reg::name%;\n%
  end foreach
end foreach%
		///store the number of cycles executed since the beginning of the simulation.
		///value is not updated in ISS mode.
		u64 m_nbCycles;
		///store the number of instruction executed since the beginning of the simulation.
		///value is updated both in CAS and ISS modes.
		u64 m_nbInst;
		
		///pointer to the decoder... that decodes instructions :-)
		%!MODELNAME%_instDecoder *m_decoder;
	
		///ISS (Instruction Set Simulation) mode or
		///CAS (Cycle Accurate Simulation) mode.
		executionMode m_executionMode;
	
		/// Exec instruction (ISS mode)
		/// \param nb number of instruction to execute.
		int emuInst(const unsigned int nb);

%if exists useCounters then
%		//counters of component method accesses.\n%
  foreach counter in counterMap do
    %		u64 %!KEY%;\n%
  end foreach
end if
%
		/* Stack Spy */
		#ifdef	GADL_SP_CHECK_ALLOWED
		stackSpyController *m_stackController;
		#endif

		//internal function related to file I/O stubs.
		bool addIOStub(executeAction *act, std::string funcName);

		//part related to cyclic behaviors ('every')
		u64 m_nextCyclicWakeUpDate; //date of the next cyclic part.
		cyclicPartNode *m_cyclicRootNode; //single linked list ordered by wakeUpDate
		void manageCyclicPart();
		void insertCyclicNode(cyclicPartNode *node);
%let cyclicId := 0
foreach cyclicPart in periphCyclicList
do
  %\t\tvoid cyclicPart_%!cyclicId%();\n%
  %\t\tint cyclicNextDatePart_%!cyclicId%();\n%
  let cyclicId := cyclicId + 1
end foreach
let cyclicTabLength := cyclicId
if [periphCyclicList length] == 0 then let cyclicTabLength := 1 end if%
		static const __cyclicFunc_%!MODELNAME% cyclicFuncFor[%!cyclicTabLength%];
		static const __cyclicNextFunc_%!MODELNAME% cyclicNextDate[%!cyclicTabLength%];

%if useCAS then
   foreach pipeline in pipelineList 
   before
   %		//pipeline models instance\n%
   do%
		%!pipeline::name% *m_pipeline%!pipeline::name%;
		%!MODELNAME%_instruction *m_nextInstruction_%!pipeline::name%;
%    let pipelineBufferSize := 1 << nbBitsToCodeUnsigned([pipeline::stageList length] - 1)
%		%!MODELNAME%_instruction *m_instructionsInPipeline_%!pipeline::name%[%!pipelineBufferSize%];
		u64 m_instInPipe_%!pipeline::name%;
		//*******  Data Cache (TODO:Hand coded).*****
		u64 m_memStage; //TODO: will not work if more than 1 pipeline!
		fifo<u32> *m_fifoMemAccessTab[%!pipelineBufferSize%];
   %end foreach
end if%

		#ifdef GADL_WITH_PIPELINE_TRACE
		pipelineTraceDebug *m_pipelineTrace;
		#endif
   
		//*******  DDC related part.
		u64 m_DDCInstRequireStage; //used to get instruction in stage 'F'
		u64 m_DDCInstLockStage;    //used to get instruction in stage 'D'
		fifo<u64> *m_fifoDDC;      //fifo to store registers locked in the DDC.
		//registers that are used in the pipeline (locked).
		u64 m_DDCregsInUse;
		//registers that are required to get into the exec pipeline stage (not to get it from inst each time)
		u64 m_DDCCurrentReadRegs; 
		//return 0 if there is no DDC related lock.
		inline bool testDDCLock() {return ((m_DDCregsInUse & m_DDCCurrentReadRegs) != 0);}
		//main function for DDC management. Used each cycle.
		void DDCManagement(const unsigned int notification);
		void debugDDCRegField(); //debug.
%if useCAS then
%		//DDC register file access (R/W);
%foreach memInfo in DDCRegFileMemInfo do %		u64 m_DDCreadRegFile%!memInfo::memoryId%Access;
		u64 m_DDCwriteRegFile%!memInfo::memoryId%Access;
%end foreach
%		u64 m_DDCreadRegAccess;
		u64 m_DDCwriteRegAccess;
%
end if
%\n		//timing related automata.
%
foreach timing in deviceToTimingMap do
  %\t\ttiming%!timing% *m_timing%!KEY%;\n%
end foreach
if [timingList length] > 0 then
%		timingBase *m_pendingSignalEmitTab[NB_SIGNAL_EMIT];
		timingBase *m_pendingSignalWaitTab[NB_SIGNAL_WAIT];
		timingBase *m_timingListRoot;
		u64 m_timingNextWakeUp;
		//this function is called when this is the date to wake up an automata
		void manageTiming();
%end if
%public:

		/*******************************************************************
		 *  status
		 *******************************************************************/
		///debugging info
		void decoderStats();
		/** get number of cycles executed since the beginning of the simulation.
		 * This value is not modified in ISS mode (functional)
		 */
		inline unsigned long long const getNBCycles() const {return m_nbCycles;};
		/// get number of instruction executed since the beginning of the simulation.
		inline unsigned long long const getNBInstructions() const {return m_nbInst;};
		/** generic function to access the program counter */
		inline %!PC_C_TYPE% programCounter() {%if useCAS then%
			m_DDCreadRegAccess |= DDC_REGISTER_MASK_%!PC_NAME%; %end if%
			return m_%!PC_NAME%;};
		
		/** specific functions to access the program counter (use processor real name) */
		inline void set%!PC_NAME%(const %!PC_C_TYPE% val) {setProgramCounter(val);};
		/** specific functions to access the program counter (use processor real name) */
		inline %!PC_C_TYPE% %!PC_NAME%() {return programCounter();};
		/** returns the function symbol for a given address (typically program counter). (for ELF files). */
		std::string whichFunctionAtAddress(const u32 v_addr);

		/** Disassemble binary code.
		* \param ipStart Instruction Pointer from which the disassemble is started
		* \param nbBytes Number of bytes to disassemble: Value may be exceeded: 
		* i.e. if set to 1 to decode a 32 bits instruction, 1 instruction will be decoded.
		* \param verbose return also the address where the code is decoded and the opcode of the instruction.
		*/ 
		std::string disassemble(const unsigned int pcStart, const int nbBytes, bool verbose = false);
		/** print the value of all variables defined as 'register' in the description
          * It does not take into account memory chunk defined has 'register'
          */
		void printRegs();
		/* @return the physical address. 
		 * If no physical address is matching, the virtual address is returned
		 * and found is set to false.
	 	 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			u32 getPhysicalAddress(const u32 v_addr, bool &OUTPUT);
		#else
			u32 getPhysicalAddress(const u32 v_addr, bool &found);
		#endif
		/* this function search for the virtual address and size of the symbol name (first parameter).
		 * @return true if a symbol have been found, and updates v_addr and size
		 * @return false if no symbol is matching. v_addr and size are not updated.
		 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			bool getSymbolObjectAddress(const char *symbolName, u32 &OUTPUT, u32 &OUTPUT);
		#else
			bool getSymbolObjectAddress(const char *symbolName, u32 &v_addr, u32 &size);
		#endif
		/* this function search for the virtual address of the function (first parameter).
		 * @return true if a function have been found, and updates v_addr 
		 * @return false if no function is matching. v_addr and size are not updated.
		 */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			bool getFunctionName(const char *symbolName, u32 &OUTPUT);
		#else
			bool getFunctionName(const char *symbolName, u32 &v_addr);
		#endif
		
		/** print all object symbols (for ELF files)*/
		void dumpObjects();
		/** print all function symbols  (for ELF files)*/
		void dumpFunctions();

		/** Use this function to record the pipeline trace.. Simulation is quite slower. */
		void usePipelineTrace();
		/** Output pipeline trace to a .ptr file 
		 *  @see pipelineTraceDebug.h
		 */
		void outputPipelineTrace(const std::string filename);

		/** return the instruction object at address. Note that p_addr is modified and 
		 * updated to point to the next instruction address.
		 **/
		#ifdef SWIG /*Swig wrapper (for Python interface)*/		
			std::string getInstructionStaticInfo(unsigned int &INOUT);
		#else
			std::string getInstructionStaticInfo(unsigned int &p_addr);
		#endif

		/*******************************************************************
		 *  Breakpoints
		 *******************************************************************/
		/** remove all breakpoints (interactive simulation) */
		void removeAllBreakpoints();
		/** remove a breakpoint for interactive simulation */
		void removeBreakpoint(const unsigned int addr);
		/** remove a breakpoint for interactive simulation */
		void removeBreakpoint(const char *symbolName);
		/** add a breakpoint for interactive simulation
		 *  An error is generated if there is already a breakpoint at this addr.
		 */
		void addBreakpoint(const unsigned int addr);
		/** add a breakpoint for interactive simulation */
		void addBreakpoint(const char *symbolName);

		/*******************************************************************
		 *  Configuration
		 *******************************************************************/
		/** Set the simulator mode:
		 *  - ISS: Instruction Set Simulator
		 *  - CAS: Cycle Accurate Simulator
		 */
		void setExecutionMode(const executionMode mode);
		/** install io stubs to support open, close, read and write functions.
		 * These functions are mapped to the host, using actions.
		 * It returns true if there was no error.
		 * This function requires extra files (ioStubs.cpp and .h) that are nor yet
		 * generated by the Harmless compiler (have a look in the example folder)
		 * Moreover, the USE_IO_STUBS should be set to 1 in the Makefile and it requires
		 * actions.
		 */
		bool useIOStubs();
		
		/*******************************************************************
		 *  Execution
		 *******************************************************************/
		/// restore the cpu in the init state (called in constructor)
		void reset();
		/** Read a code file with 
		 *  - Intel Hex format
		 *  - Motorola SRecord format
		 *  - ELF format (if linked with the appropriate library).
		 *  (no CRC verification)
		 *  \return true if the code file is correctly read.
		 */  
		bool readCodeFile(const char *filename, const bool verbose = false);
		/** simulate instructions of the processor.
		* The simulator may be in CAS or ISS mode
		* \param nb number of instruction to execute.
		* \return what causes the execution to stop : 18 on user stop, 5 on breakpoint or 0 on success
		*/ 
		int execInst(const unsigned int nb);

		/** run simulation until PC=addr. It does not take into account segmentation!!
		 *  \param addr the address compared to the program counter
		 *  \param max the max number of instruction to execute.
		 */
		void runUntil(const unsigned int addr, const unsigned int max);

		/** generic function to access the program counter */
		inline void setProgramCounter(const %!PC_C_TYPE% val) { %if useCAS then%
			m_DDCwriteRegAccess |= DDC_REGISTER_MASK_%!PC_NAME%; %end if%
			m_%!PC_NAME% = val;};

		/** return the object that reads the binary application code */
		codeReader *getCodeReader() {return m_reader;};

		/*******************************************************************
		 * Stack/Task observation.
		 *******************************************************************/
		/* Stack SPY */
		#ifdef	GADL_SP_CHECK_ALLOWED
		inline stackSpyController* getStackSpyController(){return m_stackController;};
		#endif
		/*******************************************************************
		 *  Internals :public functions that are accessed by other
		 *             simulators objects: memory, actions, ...
		 *             THEY SHOULD NOT BE CALLED DURING SIMULATION.
		 *******************************************************************/
		/**
		 * This is an internal function that SHOULD ONLY be called 
		 * from harmless instructions.
		 */
		inline void interruptHandling(u32 trapId) { %!INTERRUPT_HANDLING% };
		/**
		 * This is an internal function that SHOULD ONLY be called 
		 * from harmless instructions.
		 */
		inline void addCycle(unsigned int val) {m_nbCycles += val;};

		void removeExecuteActionAtAddress(const u32 addr, executeAction *ea);
		void addExecuteActionAtAddress(const u32 addr, executeAction *ea);
		/** this method should ONLY be called by an action that is 
		 *  associated to a breakpoint (interactive simulation)
		 */
		inline void actionFoundABreakpoint(const u32 addr) {stopSimu(5); m_lastBreakpointAddr = addr;};
		/** return the memory chunk that contains 'address'. This is used for program loading. */
		storage * getProgramChunk(const unsigned int address);
		/** this method is called by instructions that have a 'nop' statement:
         *  'add xx nop'
		 * This method will be called to decode (and NOT execute) the next xx (val)
		 * instructions. Instructions should be decoded if not all the instructions
		 * have the same size: TODO: optimize for the other case.
		 */
		void doNotExececuteNextInstructions(const u32 val);

%if useCAS then
   foreach pipeline in pipelineList do 
%		/** pipeline model related function */
		unsigned int getNextInstructionCodeIn_%!pipeline::name%();
		/** pipeline model related function */
		unsigned int getExternalResourcesState_%!pipeline::name%();
%  end foreach
 end if
%
		bool execOneCycle(); //TODO: remove.

		/** internal function that translates an address from the linker
          * to a real address in the global memory address.
          */
		u32 linkerAddressTranslation(u32 addr);
		/** This is the default fetch function used in the decode phase. Another Fetch function can be defined
         *  and should be declared in the default section of the .hadl processor description
         *  This function just get a word (size is defined in instruction size in the default section) in 
         *  memory, update the pc in parameter and returns the value reads in memory.
		 * If no user fetch function is defined, this one is used each time a program word is read. Note that
		 * due to the instruction cache, the function may not be called!
		 * If a user fetch function is defined, the default fetch function is used for the disassembler.
         */
		#ifdef SWIG /*Swig wrapper (for Python interface)*/
			inline %!INST_DEFAULT_C_SIZE% defaultFetch(%!PC_C_TYPE% &INOUT)
		#else
			inline %!INST_DEFAULT_C_SIZE% defaultFetch(%!PC_C_TYPE% &pc)
		#endif
		{
			unsigned int realAddress = getFetchAddress(pc);
			roStorage *codeMem = (roStorage *)getProgramChunk(realAddress);
			const %!INST_DEFAULT_C_SIZE% instCode = codeMem->read%!INST_SIZE_IN_BITS%AtAddress(realAddress);
			pc += %!INST_SIZE_IN_BYTES%;
			return instCode;
		}

		inline u32 getFetchAddress(u32 address)
		{
			 return %
		if fetchAddressComponentName != "" then
			!fetchAddressComponentName%_%!fetchAddressMethodName%(address)%
		else
			%address%
		end if%;
		}
%if useCAS then%
		//this function should be called ONLY by the execute method of an instruction.
		inline void initDDCRegAccess() {
			%foreach memInfo in DDCRegFileMemInfo do %
			m_DDCreadRegFile%!memInfo::memoryId%Access  = 0;
			m_DDCwriteRegFile%!memInfo::memoryId%Access = 0;
			%end foreach%
			m_DDCreadRegAccess = 0;
			m_DDCwriteRegAccess = 0;
		};
%foreach memInfo in DDCRegFileMemInfo do %
		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegFile%!memInfo::memoryId%AccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegFile%!memInfo::memoryId%Access;
			w=m_DDCwriteRegFile%!memInfo::memoryId%Access;
		};
%end foreach%
		//this function should be called ONLY by the execute method of an instruction.
		inline void getDDCRegAccessMask(u64 &r, u64 &w) {
			r=m_DDCreadRegAccess;
			w=m_DDCwriteRegAccess;
		};
%end if%
%		if [timingList length] > 0 then
%		//timing simulation steps accessors
		void timingWaitForCycles(timingBase *,const u64 nbCycles);
		bool timingSynchroEmit(timingBase *,unsigned int sigName, const bool broadcast);
		bool timingSynchroWait(timingBase *,unsigned int sigName);
%		end if%
		/*******************************************************************
		 * Automatically generated functions.
		 *******************************************************************/
		
		/** components and memory implementation*/
%
let DDCRegFileChunkMap := emptyMap
if exists DDCRegFileChunk then
  let DDCRegFileChunkMap := mapOf DDCRegFileChunk by key
end if
foreach component in componentList
do
	%\t\t/*********** component %!component::name% ************/\n%
	foreach method in component::methodList
	do
		let key := component::name."_".method::name
		%\t\tinline %!method::returnTypeStr% %!component::name%_%!method::name%(%!method::paramStr%) {\n%
		if useCAS then
			if exists DDCRegFileChunkMap[key] then #this is a DDC related function (read or write).
				let reg := "m_DDC".DDCRegFileChunkMap[key]::access."RegFile".DDCRegFileChunkMap[key]::memoryId."Access"
				%\t\t\t//DDC related function (%!DDCRegFileChunkMap[key]::access%)\n%
				%\t\t\t%!reg% |= 1<<address;\n%
			end if
			if useCAS then
				#TODO: Temporary for Data Cache -> UGLY
				foreach pipeline in pipelineList 
				before
				do
					let pipelineBufferSize := 1 << nbBitsToCodeUnsigned([pipeline::stageList length] - 1)
					let firstPipelinebufferMask := pipelineBufferSize - 1
					if component::name == "mem" & method::name != "getChunk" then
						if exists archList then
							foreach arch in archList do
								foreach spl in arch::sharedPortActivationList do
									if spl::port == "loadStore" then #special case for the load store: HAND CODED!
										%\t\t\tm_fifoMemAccessTab[m_nbCycles & %![firstPipelinebufferMask hexString]%]->write(address);\n%
									end if
								end foreach
							end foreach
						end if
					end if
				end foreach
		    end if
		end if
	    let keyCount := "counter_".key
		if exists counterMap[keyCount] then #access counter
			%\t\t\t%!keyCount%++;\n%
		end if
		!method::codeStr
		%\n\t\t}\n%
	end foreach
end foreach
%
		
		/** registers declaration for each component */
%let regWithPeriphAccess := mapOf periphCompRegisterList by name
foreach component in componentList do
  if [component::registerList length] > 0 then
    %\t\t//registers defined in component %!component::name%:\n%
  end if
  foreach reg in component::registerList do
    #get the real name
    let name := reg::regName
    %\t\t//register %!reg::regName
    if exists reg::field then
      %.%!reg::field
      let name := reg::regName."_".reg::field
    end if
    % access\n%
    #getter code
    %\t\tinline %!reg::CType% %!name%() {%

    let key := "counter_read_".reg::regName #access counter
    if exists counterMap[key] then
      %\n\t\t\t%!key%++;%
    end if
    if useCAS then
      %\n\t\t\tm_DDCreadRegAccess |= DDC_REGISTER_MASK_%!reg::regName%;\n\t\t\t%
    end if
    if exists regWithPeriphAccess[name] then #peripheral related access.
      let periphReadCode := regWithPeriphAccess[name]::codeRead
      if periphReadCode != "" then %\n%!periphReadCode%\n\t\t\t% end if
    end if
    !reg::getterCode%};\n% #normal access.
    #setter code
    %\t\tinline void set%!name%(const %!reg::CType
    if reg::isConst then 
      %) {% 
    else
      % value) {%!reg::setterCode
      if useCAS then
        %\n\t\t\tm_DDCwriteRegAccess |= DDC_REGISTER_MASK_%!reg::regName%;%
      end if
      if exists reg::field then %\n\t\t% end if
    end if

    let key := "counter_write_".reg::regName #access counter
    if exists counterMap[key] then
      %\n\t\t\t%!key%++;%
    end if
    

    if exists regWithPeriphAccess[name] then #peripheral related access.
      let periphWriteCode := regWithPeriphAccess[name]::codeWrite
      if periphWriteCode != "" then %\n%!periphWriteCode%\n\t\t% end if
    end if
    %};\n%
  between %\n%
  end foreach
end foreach

if exists useCounters then
%		//accessors for counters of component method and registers accesses.\n%
  foreach counter in counterMap do
    %		inline u64 const get_%!KEY%() { return %!KEY%;};\n%
  end foreach
end if
%
};
#endif
%
