
module HADL2Dot;
create OUT:Dot from IN:HADL;

rule Model2Root {
   from model : HADL!Model
   using {
      behaviors : HADL!Behavior = model.elements->select(e| e.oclIsKindOf(HADL!Behavior));
   }
   to
      root : Dot!Root (
            name <- model.name,
            strict <- false,
            directed <- true,
            nodes <- behaviors,
            statements <-
               behaviors->collect(f| thisModule.resolveTemp(f, 'stmt'))
               ->union(
                     behaviors
                        ->collect(f|
                              if f.oclIsKindOf(HADL!AggregateBehavior) then
                                 f.chunks->collect(c| c.call)
                              else
                                 f.choices
                                    ->select(c| c.oclIsKindOf(HADL!CallBehaviorChoice))
                                    ->collect(c| c.call)
                                    ->union(
                                          f.choices
                                             ->select(c| c.oclIsKindOf(HADL!LeafBehaviorChoice))
                                             ->collect(c|
                                                   Sequence{
                                                         thisModule.resolveTemp(c, 'stmt'),
                                                         thisModule.resolveTemp(c, 'edge')
                                                      }
                                                )
                                       )
                              endif
                           )
                        ->flatten()
                  )
         )
}

rule Behavior2Node {
   from behavior : HADL!Behavior
   to
      node : Dot!Node (
            name <- behavior.name
         ),

      stmt : Dot!NodeStatement (
            node <- node,
            attributes <- alist
         ),
      alist : Dot!AttributeList (
            attributes <- Sequence{shape, label}
         ),
      shape : Dot!Attribute (
            name <- 'shape',
            value <- 'Mrecord'
         ),
      label : Dot!Attribute (
            name <- 'label',
            value <-
               '"{' +
               if behavior.oclIsKindOf(HADL!AggregateBehavior) then
                  'aggregate'
               else
                  'alternative'
               endif +
               '\\n' + behavior.name +
               if behavior.attributes->isEmpty() then
                  ''
               else
                  '|' +
                  behavior.attributes
                     ->iterate(a; acc:String=''|
                           if acc = '' then
                              ''
                           else
                              acc + '\\n'
                           endif +
                           a.name
                        )
               endif +
               '}"'
         )
}

rule BehaviorCallInChunk2EdgeStatement {
   from call : HADL!BehaviorCall ( not call.owningChunk.oclIsUndefined() )
   to
      edge : Dot!EdgeStatement (
            contents <- Sequence{source, target},
            attributes <- alist
         ),
      source : Dot!NodeRef (
            node <- call.owningChunk.owningBehavior
         ),
      target : Dot!NodeRef (
            node <- call.behavior
         ),
      alist : Dot!AttributeList (
            attributes <- label
         ),
      label : Dot!Attribute (
            name <- 'label',
            value <-
               '"' + call.owningChunk.name +
               if call.owningChunk.condition.oclIsUndefined() then
                  ''
               else
                  ' [when ...]'
               endif + '"'
         )
}

rule BehaviorCallInChoice2EdgeStatement {
   from call : HADL!BehaviorCall ( not call.owningChoice.oclIsUndefined() )
   to
      edge : Dot!EdgeStatement (
            contents <- Sequence{source, target}
         ),
      source : Dot!NodeRef (
            node <- call.owningChoice.owningBehavior
         ),
      target : Dot!NodeRef (
            node <- call.behavior
         )
}

rule LeafBehaviorChoice2Node {
   from choice : HADL!LeafBehaviorChoice
   to
      node : Dot!Node (
            name <- choice.name
         ),

      stmt : Dot!NodeStatement (
            node <- node,
            attributes <- alist
         ),
      alist : Dot!AttributeList (
            attributes <- shape
         ),
      shape : Dot!Attribute (
            name <- 'shape',
            value <- 'ellipse'
         ),

      edge : Dot!EdgeStatement (
            contents <- Sequence{source, target}
         ),
      source : Dot!NodeRef (
            node <- choice.owningBehavior
         ),
      target : Dot!NodeRef (
            node <- node
         )
}

