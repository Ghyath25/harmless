
package HADL {

   abstract class LocatedElement {
      attribute location : String;
   }

   abstract class NamedElement extends LocatedElement {
      attribute name : String;
   }

   --------------------------------------------------------
   -- Top level
   --
   -- A model is composed of model elements.
   -- All elements have a name.
   --------------------------------------------------------

   class Model extends NamedElement {
      reference elements[*] container : ModelElement oppositeOf owningModel;
      attribute dataSize : Integer;
      attribute instructionSize : Integer;
   }

   abstract class ModelElement extends LocatedElement {
      reference owningModel : Model oppositeOf elements;
   }

   --------------------------------------------------------
   -- Typed elements
   --
   -- Only integer types are supported.
   -- They can be signed or unsigned, with a customizable
   -- size (in bits).
   -- "void" is translated as a zero-size typed element.
   --------------------------------------------------------

   class TypedElement extends NamedElement {
      attribute isSigned : Boolean;
      attribute size : Integer;
   }

   --------------------------------------------------------
   -- Components
   --
   -- An component is a collection of operations (services)
   -- provided by the architecture.
   -- It provides an abstraction that allows the instruction
   -- set to control the hardware resources without any
   -- precise knowledge of which resources implement which
   -- operations.
   --------------------------------------------------------
   
   class Component extends ModelElement, NamedElement {
      reference variables[*] container : ComponentVariable oppositeOf owningComponent;
      reference operations[1-*] container : Operation oppositeOf owningComponent;
   }

   --------------------------------------------------------
   -- Operations
   --
   -- An operation
   --    - is provided by an component
   --    - can be either a function or a procedure
   --    - can have parameters
   --    - can have local variables
   --    - has a body (= a block of statements)
   --------------------------------------------------------

   class Operation extends TypedElement {
      reference owningComponent : Component oppositeOf operations;
      attribute isFunction : Boolean;
      reference parameters[*] ordered container : Parameter oppositeOf owningOperation;
      reference localVariables[*] ordered container : LocalVariable oppositeOf owningOperation;
      reference body container : Block oppositeOf owningOperation;
   }

   --------------------------------------------------------
   -- Architectures
   --
   -- An architecture is a collection of resources that
   -- implement components.
   --
   -- An architecture can inherit the resources from its
   -- (optional) father architectures.
   --
   -- Each resource has port(s) that allow concurrent
   -- access to component operations.
   -- A port provides all or a subset of the component's
   -- operations.
   --------------------------------------------------------

   class Architecture extends ModelElement, NamedElement {
      reference fathers[*] : Architecture;
      reference resources[*] container : Resource oppositeOf owningArchitecture;
   }

   class Resource extends NamedElement {
      reference owningArchitecture : Architecture oppositeOf resources;
      reference component : Component;
      reference ports[1-*] container : Port oppositeOf owningResource;
   }
   
   class Port extends NamedElement {
      reference owningResource : Resource oppositeOf ports;
      reference operations[*] : Operation;
   }
   
   --------------------------------------------------------
   -- Pipelines
   --
   -- A pipeline is attached to a given architecture.
   -- A pipeline is composed of
   --    - an initialization statement block
   --    - a fetch expression associated with an instruction format
   --    - a sequence of stages
   --
   -- A stage is associated with a set of resource activations.
   -- A resource activation has :
   --    - a reference to a resource of the architecture
   --    - a possibly empty set of operations usable in this stage
   --      (empty means *all* operations are allowed)
   --    - a priority level
   --
   -- TODO Add sub-stages
   --------------------------------------------------------

   class Pipeline extends ModelElement, NamedElement {
      reference architecture : Architecture;
      reference init container : Block oppositeOf owningPipeline;
      reference expression container : Expression oppositeOf owningPipeline;
      reference behavior : Behavior;
      reference stages[1-*] ordered container : Stage oppositeOf owningPipeline;

      -- self.behavior.formats->size() = 1
   }

   class Stage extends NamedElement {
      reference owningPipeline : Pipeline oppositeOf stages;
      reference activations[*] container : ResourceActivation oppositeOf owningStage;
   }
   
   class ResourceActivation extends LocatedElement {
      reference owningStage : Stage oppositeOf activations;
      reference resource : Resource;
      reference portActivations[*] container : PortActivation oppositeOf owningResourceActivation;
      reference releaseStage[0-1] : Stage;
      reference bypassStages[*] : Stage;
      attribute priority : Integer;
      attribute isReusable : Boolean;

      -- Release stage must come after owning stage
      -- Bypass stages must come before owning stage
   }
   
   class PortActivation extends LocatedElement {
      reference port : Port;
      reference releaseStage[0-1] : Stage;
      reference bypassStages[*] : Stage;
      reference owningResourceActivation : ResourceActivation oppositeOf portActivations;

      -- Release stage must come after owning stage
      -- Bypass stages must come before owning stage
   }

   --------------------------------------------------------
   -- Instruction behaviors
   --
   -- An instruction behavior
   --    - is a model element
   --    - can have parameters
   --    - can have local variables
   --    - can have "before" and "after" statement blocks
   --
   -- There are two kinds of behaviors :
   --    - aggregate behaviors are composed of "chunks"
   --    - alternative behaviors are composed of "choices"
   --
   -- A chunk
   --    - has a name
   --    - can be composed of a call to another behavior
   --    - can have a condition (expression)
   --
   -- A choice can be
   --    - a "leaf" choice, with a name and a block of statements
   --    - a "call" choice, that calls another behavior
   --
   -- A behavior call
   --    - has a reference to a called behavior
   --    - can have actual parameters (expressions)
   --------------------------------------------------------

   abstract class Behavior extends ModelElement, NamedElement {
      reference parameters[*] ordered container : Parameter oppositeOf owningBehavior;
      reference localVariables[*] container : LocalVariable oppositeOf owningBehavior;
      reference attributes[*] container : Attribute oppositeOf owningBehavior;
      reference beforeBlock[0-1] container : Block oppositeOf owningBehaviorBefore;
      reference afterBlock[0-1] container : Block oppositeOf owningBehaviorAfter;
      reference formats[*] : Format oppositeOf behavior;
      reference syntaxes[*] : Syntax oppositeOf behavior;
   }

   class AggregateBehavior extends Behavior {
      reference chunks[*] ordered container : BehaviorChunk oppositeOf owningBehavior;
   }

   class BehaviorChunk extends LocatedElement {
      reference owningBehavior : AggregateBehavior oppositeOf chunks;
      reference call container : BehaviorCall oppositeOf owningChunk;
      reference condition[0-1] container : Expression oppositeOf owningBehaviorChunk;
      attribute label[0-1] : String;
   }

   class AlternativeBehavior extends Behavior {
      reference choices[1-*] container : BehaviorChoice oppositeOf owningBehavior;
   }

   abstract class BehaviorChoice extends LocatedElement {
      reference owningBehavior : AlternativeBehavior oppositeOf choices;
   }
   
   class LeafBehaviorChoice extends BehaviorChoice, NamedElement {
      reference body[0-1] container : Block oppositeOf owningChoice;
   }

   class CallBehaviorChoice extends BehaviorChoice {
      reference call container : BehaviorCall oppositeOf owningChoice;
   }
   
   class BehaviorCall extends LocatedElement {
      reference owningChoice[0-1] : CallBehaviorChoice oppositeOf call;
      reference owningChunk[0-1] : BehaviorChunk oppositeOf call;
      reference behavior : Behavior;
      reference actualParameters[*] ordered container : Expression oppositeOf owningBehaviorCallActual;
   }
   
   --------------------------------------------------------
   -- Variables and attributes
   --
   -- A variable can be
   --    - a global variable of the model
   --    - a local variable in a behavior or operation
   --    - a loop counter
   --    - a parameter of an operation or behavior
   --
   -- Variables are not typed, but can be identified as arrays.
   --
   -- Parameters can be either inputs or outputs.
   --
   -- TODO Rename Attribute to "Field"
   -- TODO Separate format parameters
   -- TODO restrict arrays to ComponentVariable ??
   --------------------------------------------------------

   abstract class DataContainer extends NamedElement {
   }

   abstract class TypedDataContainer extends DataContainer, TypedElement {
   }

   class Attribute extends TypedDataContainer {
      reference owningBehavior : Behavior oppositeOf attributes;
   }

   abstract class Variable extends TypedDataContainer {
      attribute arraySize[0-1] : Integer;
   }

   class ComponentVariable extends Variable {
      attribute isExternal : Boolean;
      reference owningComponent : Component oppositeOf variables;
   }

   class LocalVariable extends Variable {
      reference owningOperation[0-1] : Operation oppositeOf localVariables;
      reference owningBehavior[0-1] : Behavior oppositeOf localVariables;
   }

   class LoopVariable extends Variable {
      reference owningForStatement : ForStatement oppositeOf counter;
   }

   class Parameter extends Variable {
      attribute isOutput : Boolean;
      reference owningOperation[0-1] : Operation oppositeOf parameters;
      reference owningBehavior[0-1] : Behavior oppositeOf parameters;
   }
   
   --------------------------------------------------------
   -- Statements
   --
   -- Statements are imperative constructs.
   -- A block is composed of a sequence of statements.
   --
   -- The supported kinds of statements are
   --    - assignment statements
   --    - procedure call statements
   --    - if statements
   --    - for loop statements
   --    - return statements
   --
   -- An assignment statement assigns an expression
   -- to a variable
   --    - with a possible index if the variable is an array
   --    - with a possible range
   --------------------------------------------------------

   class Block extends LocatedElement {
      reference statements[*] ordered container : Statement oppositeOf owningBlock;
      reference owningOperation[0-1] : Operation oppositeOf body;
      reference owningPipeline[0-1] : Pipeline oppositeOf init;
      reference owningBehaviorBefore[0-1] : Behavior oppositeOf beforeBlock;
      reference owningBehaviorAfter[0-1] : Behavior oppositeOf afterBlock;
      reference owningChoice[0-1] : LeafBehaviorChoice oppositeOf body;
      reference owningIfStatementElse[0-1] : IfStatement oppositeOf elseClause;
      reference owningIfClauseThen[0-1] : IfClause oppositeOf thenClause;
      reference owningForStatement[0-1] : ForStatement oppositeOf body;
   }

   abstract class Statement extends LocatedElement {
      reference owningBlock : Block oppositeOf statements;
   }

   class AssignmentStatement extends Statement {
      reference target container : DataContainerRefExpression oppositeOf owningAssignmentStatementTarget;
      reference source container : Expression oppositeOf owningAssignmentStatementSource;
   }

   class ProcedureCallStatement extends Statement {
      reference call container : OperationCall oppositeOf owningProcedureCallStatement;
   }
   
   class OperationCall extends LocatedElement {
      attribute inline : Boolean;
      reference component[0-1] : Component; -- only for name resolution purpose in TCS
      reference calledOperation : Operation;
      reference actualParameters[*] ordered container : Expression oppositeOf owningOperationCall;
      reference owningProcedureCallStatement[0-1] : ProcedureCallStatement oppositeOf call;
      reference owningFunctionCallExpression[0-1] : FunctionCallExpression oppositeOf call;
   }

   class IfStatement extends Statement {
      reference ifClauses[1-*] ordered container : IfClause oppositeOf owningIfStatement;
      reference elseClause[0-1] container : Block oppositeOf owningIfStatementElse;
   }

   class IfClause extends LocatedElement {
      reference owningIfStatement : IfStatement oppositeOf ifClauses;
      reference condition container : Expression oppositeOf owningIfClause;
      reference thenClause container : Block oppositeOf owningIfClauseThen;
   }

   class ForStatement extends Statement {
      reference counter container : LoopVariable oppositeOf owningForStatement;
      reference range container : Range oppositeOf owningForStatement;
      reference body container : Block oppositeOf owningForStatement;
   }
   
   class ReturnStatement extends Statement {
      reference expression[0-1] container : Expression oppositeOf owningReturnStatement;
   }
   
   --------------------------------------------------------
   -- Expressions
   --
   -- The supported kinds of expressions are
   --    - function call expressions
   --    - variable use expressions
   --    - chunk use expressions
   --    - operator expressions
   --    - literal expressions (integer, boolean, based integer)
   --
   -- Variable and chunk expressions can specify a range.
   --------------------------------------------------------

   abstract class Expression extends LocatedElement {
      reference owningSliceFirst[0-1] : Slice oppositeOf first;
      reference owningSliceLast[0-1] : Slice oppositeOf last;
      reference owningSliceStep[0-1] : Slice oppositeOf step;
      reference owningOperatorExpressionSource[0-1] : OperatorExpression oppositeOf source;
      reference owningOperatorExpressionArguments[0-1] : OperatorExpression oppositeOf arguments;
      reference owningDataContainerRefExpression[0-1] : DataContainerRefExpression oppositeOf index;
      reference owningReturnStatement[0-1] : ReturnStatement oppositeOf expression;
      reference owningIfClause[0-1] : IfClause oppositeOf condition;
      reference owningAssignmentStatementSource[0-1] : AssignmentStatement oppositeOf source;
      reference owningBehaviorChunk[0-1] : BehaviorChunk oppositeOf condition;
      reference owningBehaviorCallActual[0-1] : BehaviorCall oppositeOf actualParameters;
      reference owningOperationCall[0-1] : OperationCall oppositeOf actualParameters;
      reference owningPipeline[0-1] : Pipeline oppositeOf expression;
      reference owningSyntaxExpression[0-1] : ComputedSyntaxExpression oppositeOf expression;
   }

   class FunctionCallExpression extends Expression {
      reference call container : OperationCall oppositeOf owningFunctionCallExpression;
   }

   class DataContainerRefExpression extends Expression {
      reference dataContainer : DataContainer;
      reference index[0-1] container : Expression oppositeOf owningDataContainerRefExpression;
      reference range[0-1] container : Range oppositeOf owningDataContainerRefExpression;
      reference owningAssignmentStatementTarget[0-1] : AssignmentStatement oppositeOf target;
      attribute extend : Boolean;
   }

   class OperatorExpression extends Expression {
      attribute operator : String;
      reference source container : Expression oppositeOf owningOperatorExpressionSource;
      reference arguments[*] ordered container : Expression oppositeOf owningOperatorExpressionArguments;
   }

   class IntegerLiteralExpression extends Expression {
      attribute value : Integer;
   }

   class BooleanLiteralExpression extends Expression {
      attribute value : Boolean;
   }

   class BasedLiteralExpression extends Expression {
      attribute base : BaseSpecifier;
      attribute value : String;
      reference owningChoice[0-1] : FormatChoice oppositeOf literals;
      reference owningPath[0-1] : Path oppositeOf value;

      -- base <> #decimal
   }

   enumeration BaseSpecifier {
      literal decimal;
      literal binary;
      literal octal;
      literal hexadecimal;
   }

   class Range extends LocatedElement {
      reference owningFormat[0-1] : AlternativeFormat oppositeOf range;
      reference owningPath[0-1] : Path oppositeOf range;
      reference owningForStatement[0-1] : ForStatement oppositeOf range;
      reference owningFieldAttributeFormat[0-1] : FieldAttributeFormat oppositeOf range;
      reference owningDataContainerRefExpression[0-1] : DataContainerRefExpression oppositeOf range;
      reference slices[1-*] ordered container : Slice oppositeOf owningRange;
      attribute shiftAmount : Integer;
      attribute right : Boolean;
      attribute shift : Boolean;
      attribute arithmetic : Boolean;
   }

   class Slice extends LocatedElement {
      reference owningRange : Range oppositeOf slices;
      reference first container : Expression oppositeOf owningSliceFirst;
      reference last[0-1] container : Expression oppositeOf owningSliceLast;
      reference step[0-1] container : Expression oppositeOf owningSliceStep;
   }

   --------------------------------------------------------
   -- Behavior paths
   --------------------------------------------------------

   class Path extends LocatedElement {
      reference owningSyntax[0-1] : Syntax oppositeOf paths;
      reference owningFormat[0-1] : Format oppositeOf paths;
      reference elements[1-*] ordered container : PathElement oppositeOf owningPath;
      reference range[0-1] container : Range oppositeOf owningPath;
      reference value[0-1] container : BasedLiteralExpression oppositeOf owningPath;

      -- self.owningSyntax.oclIsUndefined() xor self.owningFormat.oclIsUndefined()
      -- not self.range.oclIsUndefined() implies self.owningSyntax.owningFormat.oclIsUndefined()
      -- not self.range.oclIsUndefined() implies not self.value.oclIsUndefined()
   }

   class PathElement extends LocatedElement {
      reference owningPath : Path oppositeOf elements;
      reference behavior : Behavior;
      reference behaviorChunk[0-1] : BehaviorChunk;
      -- If behaviorChunk is defined, behavior is used only for resolution in TCS
   }

   --------------------------------------------------------
   -- Instruction formats
   --
   -- An instruction format can be
   --    - an aggregate format, composed of format "chunks"
   --    - an alternative format, composed of format "choices"
   --------------------------------------------------------

   abstract class Format extends ModelElement {
      reference behavior : Behavior oppositeOf formats;
      reference paths[*] container : Path oppositeOf owningFormat;
      reference attributeFormats[*] container : AttributeFormat oppositeOf owningFormat;
   }

   abstract class AttributeFormat extends LocatedElement {
      reference owningFormat : Format oppositeOf attributeFormats;
      reference "attribute" : Attribute;
   }

   class FieldAttributeFormat extends AttributeFormat {
      reference range container : Range oppositeOf owningFieldAttributeFormat;
   }

   class LiteralAttributeFormat extends AttributeFormat {
      attribute value : Integer;
   }
   
   class AggregateFormat extends Format {
      --
      -- An aggregate format must be associated with an aggregate behavior
      --    self.behavior.oclIsKindOf(AggregateBehavior)
      --
   }

   class AlternativeFormat extends Format {
      reference range container : Range oppositeOf owningFormat;
      reference choices[1-*] container : FormatChoice oppositeOf owningFormat;
      --
      -- An alternative format must be associated with an alternative behavior
      --    self.behavior.oclIsKindOf(AlternativeBehavior)
      --
   }

   abstract class FormatChoice extends LocatedElement {
      reference owningFormat : AlternativeFormat oppositeOf choices;
      reference literals[1-*] container : BasedLiteralExpression oppositeOf owningChoice;
   }

   class LeafFormatChoice extends FormatChoice {
      reference behaviorChoice : LeafBehaviorChoice;
   }

   class CallFormatChoice extends FormatChoice {
      reference behavior : Behavior;
   }
   
   --------------------------------------------------------
   -- Instruction syntax
   --------------------------------------------------------

   class NumberSyntax extends ModelElement {
      attribute base : BaseSpecifier;
      attribute prefix[0-1] : String;
      attribute suffix[0-1] : String;
   }
   
   abstract class Syntax extends ModelElement {
      reference behavior : Behavior oppositeOf syntaxes;
      reference parameters[*] ordered container : SyntaxParameter oppositeOf owningSyntax;
      reference paths[*] container : Path oppositeOf owningSyntax;
      reference attributeSyntaxes[*] container : AttributeSyntax oppositeOf owningSyntax;
   }

   class SyntaxParameter extends DataContainer {
      reference owningSyntax[0-1] : Syntax oppositeOf parameters;
   }

   class AggregateSyntax extends Syntax {
      reference echo container : SyntaxExpression oppositeOf owningSyntaxEcho;
   }

   class AttributeSyntax extends LocatedElement {
      reference owningSyntax : Syntax oppositeOf attributeSyntaxes;
      reference "attribute" : Attribute;
      reference expression container : SyntaxExpression oppositeOf owningAttributeSyntax;
   }
   
   class AlternativeSyntax extends Syntax {
      reference choices[1-*] ordered container : SyntaxChoice oppositeOf owningSyntax;
      reference before[0-1] container : SyntaxExpression oppositeOf owningSyntaxBefore;
      reference after[0-1] container : SyntaxExpression oppositeOf owningSyntaxAfter;
   }

   class SyntaxChoice extends LocatedElement {
      reference owningSyntax : AlternativeSyntax oppositeOf choices;
      reference behaviorChoice : LeafBehaviorChoice;
      reference expression container : SyntaxExpression oppositeOf owningChoice;
   }
   
   --------------------------------------------------------
   -- Syntax expressions
   --------------------------------------------------------
   
   abstract class SyntaxExpression extends LocatedElement {
      reference owningSyntaxCall[0-1] : SyntaxCall oppositeOf actualParameters;
      reference owningConcatenation[0-1] : ConcatenationSyntaxExpression oppositeOf expressions;
      reference owningAttributeSyntax[0-1] : AttributeSyntax oppositeOf expression;
      reference owningChoice[0-1] : SyntaxChoice oppositeOf expression;
      reference owningDecisionWhenTrue[0-1] : DecisionSyntaxExpression oppositeOf expressionWhenTrue;
      reference owningDecisionWhenFalse[0-1] : DecisionSyntaxExpression oppositeOf expressionWhenFalse;
      reference owningSyntaxBefore[0-1] : AlternativeSyntax oppositeOf before;
      reference owningSyntaxAfter[0-1] : AlternativeSyntax oppositeOf after;
      reference owningSyntaxEcho[0-1] : AggregateSyntax oppositeOf echo;
   }

   class SyntaxCall extends SyntaxExpression {
      reference behavior : Behavior;
      reference behaviorChunk[0-1] : BehaviorChunk;
      reference actualParameters[*] ordered container : SyntaxExpression oppositeOf owningSyntaxCall;
   }
   
   class DataContainerRefSyntaxExpression extends SyntaxExpression {
      reference dataContainer : DataContainer;
      -- dataContainer.oclIsKindOf(SyntaxParameter) or dataContainer.oclIsKindOf(BehaviorChunk)
   }

   class StringLiteralSyntaxExpression extends SyntaxExpression {
      attribute value : String;
   }
   
   class DecisionSyntaxExpression extends SyntaxExpression {
      reference expressionWhenTrue container : SyntaxExpression oppositeOf owningDecisionWhenTrue;
      reference expressionWhenFalse[0-1] container : SyntaxExpression oppositeOf owningDecisionWhenFalse;
   }

   class ImplicitValueSyntaxExpression extends SyntaxExpression {
      attribute defaultBase : BaseSpecifier;
   }
   
   class ComputedSyntaxExpression extends SyntaxExpression {
      attribute defaultBase : BaseSpecifier;
      reference expression container : Expression oppositeOf owningSyntaxExpression;
   }
   
   class ListSyntaxExpression extends SyntaxExpression {
      attribute prefix : String;
      attribute base : BaseSpecifier;
      attribute separator : String;
   }
   
   class ConcatenationSyntaxExpression extends SyntaxExpression {
      reference expressions[*] ordered container : SyntaxExpression oppositeOf owningConcatenation;
   }
}

package PrimitiveTypes {
   datatype Boolean;
   datatype Integer;
   datatype String;
}

