
--
-- HADLdIN dependency extraction
--
-- Preconditions
--
--    - Single variable assignment in operations and behaviors blocks.
--      Statement ordering should not be relevant : only data dependencies
--    - No return statement in procedures
--    - No functions
--    - All arguments in operation calls are simple variable references
--    - No for statement inside an if statement
--
-- TODO list :
--
--    [DONE] Transform assignment statements outside of if statements into dependency statements
--    [DONE] In assignment statements, collect dependencies from owning if statements
--    [DONE] Remove if statements
--    [DONE] Replace GlobalVariable with ComponentVariable
--

module HADL2HADLd;
create OUT:HADLdOUT from IN:HADLdIN;

-- Transform a block of statements
--    - exclude blocks inside if statements
--    - collect assignment statements inside if statements
rule TBlock { 
   from src : HADLdIN!Block (
         src.owningIfClauseThen.oclIsUndefined() and
         src.owningIfStatementElse.oclIsUndefined()
      )
   to
      dest : HADLdOUT!Block (
            statements <-
               src.statements
                  ->collect(s|
                        if s.oclIsKindOf(HADLdIN!IfStatement) then
                           s.getNonIfStatement()
                        else
                           s
                        endif
                     )
                  ->flatten()
         )
}

-- Transform an assignment statement
rule TAssignmentStatement { 
   from src : HADLdIN!AssignmentStatement
   to dest : HADLdOUT!DependencyStatement (
         targetVariable <- src.target.dataContainer,
         sourceVariables <- src.getSourceVariables()
      )
}

-------------------------------------------------------------------------------
-- Expression analysis
-- extract used variables
-------------------------------------------------------------------------------

helper context HADLdIN!DataContainerRefExpression def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
            if self.owningAssignmentStatementTarget.oclIsUndefined() then
               Sequence{self.dataContainer}
            else
               Sequence{}
            endif
      ->union(
            if not self.index.oclIsUndefined() then
               self.index.getSourceVariables()
            else
               Sequence{}
            endif
         )
      ->union(
            if not self.range.oclIsUndefined() then
               self.range.getSourceVariables()
            else
               Sequence{}
            endif
         );
      
helper context HADLdIN!OperatorExpression def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      self.source.getSourceVariables()
      ->union(self.arguments->collect(a| a.getSourceVariables()))
      ->flatten();

helper context HADLdIN!IntegerLiteralExpression def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      Sequence{};

helper context HADLdIN!BooleanLiteralExpression def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      Sequence{};

helper context HADLdIN!BasedLiteralExpression def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      Sequence{};

helper context HADLdIN!Range def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      self.slices->collect(s| s.getSourceVariables())->flatten();

helper context HADLdIN!Slice def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
            self.first.getSourceVariables()
      ->union(
            if not self.last.oclIsUndefined() then
               self.last.getSourceVariables()
            else
               Sequence{}
            endif
         )
      ->union(
            if not self.step.oclIsUndefined() then
               self.step.getSourceVariables()
            else
               Sequence{}
            endif
         );

-------------------------------------------------------------------------------
-- Statement analysis
-- extract used variables
-------------------------------------------------------------------------------

helper context HADLdIN!AssignmentStatement def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      self.target.getSourceVariables()
         ->union(self.source.getSourceVariables())
         ->union(self.owningBlock.getSourceVariables());

helper context HADLdIN!Block def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      if not self.owningIfClauseThen.oclIsUndefined() then
         self.owningIfClauseThen.owningIfStatement.ifClauses
            ->subSequence(
                  1,
                  self.owningIfClauseThen.owningIfStatement.ifClauses
                     ->indexOf(self.owningIfClauseThen)
               )
            ->collect(c| c.condition.getSourceVariables())
            ->flatten()
            ->union(self.owningIfClauseThen.owningIfStatement.owningBlock.getSourceVariables())
      else if not self.owningIfStatementElse.oclIsUndefined() then
         self.owningIfStatementElse.ifClauses
            ->collect(c| c.condition.getSourceVariables())
            ->flatten()
            ->union(self.owningIfStatementElse.owningBlock.getSourceVariables())
      else
         Sequence{}
      endif endif;

-------------------------------------------------------------------------------
-- Statement analysis
-- extract assignment statements from if statements
-------------------------------------------------------------------------------

helper context HADLdIN!IfStatement def:
   getNonIfStatement() : Sequence(HADLdIN!AssignmentStatement) =
      self.ifClauses->collect(c| c.thenClause.getNonIfStatement())
         ->union(
               if not self.elseClause.oclIsUndefined() then
                  self.elseClause.getNonIfStatement()
               else
                  Sequence{}
               endif
            );

helper context HADLdIN!Block def:
   getNonIfStatement() : Sequence(HADLdIN!AssignmentStatement) =
      self.statements
         ->collect(s|
                if s.oclIsKindOf(HADLdIN!IfStatement) then
                  s.getNonIfStatement()
               else
                  s
               endif
            )
         ->flatten();

--------------------------------------------------------------------------------
-- Straightforward copy rules
--------------------------------------------------------------------------------

rule TModel { 
   from src : HADLdIN!Model 
   to dest : HADLdOUT!Model (
         name <- src.name,
         elements <- src.elements,
         dataSize <- src.dataSize,
         instructionSize <- src.instructionSize
      )
}

rule TComponent { 
   from src : HADLdIN!Component 
   to dest : HADLdOUT!Component (
         name <- src.name,
         variables <- src.variables,
         operations <- src.operations
      )
}

rule TOperation { 
   from src : HADLdIN!Operation
   to dest : HADLdOUT!Operation (
         name <- src.name,
         parameters <- src.parameters,
         localVariables <- src.localVariables,
         body <- src.body
      )
}

rule TArchitecture { 
   from src : HADLdIN!Architecture 
   to dest : HADLdOUT!Architecture (
         name <- src.name,
         fathers <- src.fathers,
         resources <- src.resources
      )
}

rule TResource { 
   from src : HADLdIN!Resource 
   to dest : HADLdOUT!Resource (
         name <- src.name,
         component <- src.component,
         ports <- src.ports
      )
}
   
rule TPort { 
   from src : HADLdIN!Port 
   to dest : HADLdOUT!Port (
         name <- src.name,
         operations <- src.operations
      )
}
   
rule TPipeline { 
   from src : HADLdIN!Pipeline 
   to dest : HADLdOUT!Pipeline (
         name <- src.name,
         architecture <- src.architecture,
         init <- src.init,
         expression <- src.expression,
         body <- src.body,
         localVariables <- src.localVariables,
         format <- src.format,
         stages <- src.stages
      )
}

rule TStage { 
   from src : HADLdIN!Stage 
   to dest : HADLdOUT!Stage (
         name <- src.name,
         activations <- src.activations
      )
}
   
rule TResourceActivation { 
   from src : HADLdIN!ResourceActivation 
   to dest : HADLdOUT!ResourceActivation (
         resource <- src.resource,
         portActivations <- src.portActivations,
         releaseStage <- src.releaseStage,
         bypassStages <- src.bypassStages,
         priority <- src.priority,
         isReusable <- src.isReusable
      )
}
   
rule TPortActivation {
   from src : HADLdIN!PortActivation
   to dest : HADLdOUT!PortActivation (
         port <- src.port,
         releaseStage <- src.releaseStage,
         bypassStages <- src.bypassStages
      )
}

rule TAggregateBehavior { 
   from src : HADLdIN!AggregateBehavior 
   to dest : HADLdOUT!AggregateBehavior (
         name <- src.name,
         parameters <- src.parameters,
         localVariables <- src.localVariables,
         beforeBlock <- src.beforeBlock,
         afterBlock <- src.afterBlock,
         chunks <- src.chunks
      )
}

rule TBehaviorChunk { 
   from src : HADLdIN!BehaviorChunk 
   to dest : HADLdOUT!BehaviorChunk (
         name <- src.name,
         call <- src.call,
         condition <- src.condition
      )
}

rule TAlternativeBehavior { 
   from src : HADLdIN!AlternativeBehavior 
   to dest : HADLdOUT!AlternativeBehavior (
         name <- src.name,
         parameters <- src.parameters,
         localVariables <- src.localVariables,
         beforeBlock <- src.beforeBlock,
         afterBlock <- src.afterBlock,
         choices <- src.choices
      )
}

rule TLeafBehaviorChoice { 
   from src : HADLdIN!LeafBehaviorChoice 
   to dest : HADLdOUT!LeafBehaviorChoice (
         name <- src.name,
         body <- src.body
      )
}

rule TCallBehaviorChoice { 
   from src : HADLdIN!CallBehaviorChoice 
   to dest : HADLdOUT!CallBehaviorChoice (
         call <- src.call
      )
}
   
rule TBehaviorCall { 
   from src : HADLdIN!BehaviorCall 
   to dest : HADLdOUT!BehaviorCall (
         behavior <- src.behavior,
         actualParameters <- src.actualParameters
      )
}
   
rule TComponentVariable { 
   from src : HADLdIN!ComponentVariable
   to dest : HADLdOUT!ComponentVariable (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size,
         isExternal <- src.isExternal
      )
}

rule TLocalVariable { 
   from src : HADLdIN!LocalVariable 
   to dest : HADLdOUT!LocalVariable (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size
      )
}

rule TLoopVariable { 
   from src : HADLdIN!LoopVariable
   to dest : HADLdOUT!LoopVariable (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size
      )
}

rule TParameter { 
   from src : HADLdIN!Parameter
   to dest : HADLdOUT!Parameter (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size,
         isOutput <- src.isOutput
      )
}
   
rule TProcedureCallStatement { 
   from src : HADLdIN!ProcedureCallStatement 
   to dest : HADLdOUT!ProcedureCallStatement (
         call <- src.call
      )
}
   
rule TOperationCall { 
   from src : HADLdIN!OperationCall
   to dest : HADLdOUT!OperationCall (
         inline <- src.inline,
         component <- src.component,
         calledOperation <- src.calledOperation,
         actualParameters <-  src.actualParameters
      )
}

rule TForStatement { 
   from src : HADLdIN!ForStatement 
   to dest : HADLdOUT!ForStatement (
         counter <- src.counter,
         range <- src.range,
         body <- src.body
      )
}
   
rule TReturnStatement { 
   from src : HADLdIN!ReturnStatement
   to dest : HADLdOUT!ReturnStatement (
         expression <- src.expression
      )
}
   
rule TDataContainerRefExpression { 
   from src : HADLdIN!DataContainerRefExpression
   to dest : HADLdOUT!DataContainerRefExpression (
         dataContainer <- src.dataContainer,
         index <- src.index,
         range <- src.range,
         extend <- src.extend
      )
}

rule TOperatorExpression { 
   from src : HADLdIN!OperatorExpression
   to dest : HADLdOUT!OperatorExpression (
         operator <- src.operator,
         source <- src.source,
         arguments <- src.arguments
      )
}

rule TIntegerLiteralExpression { 
   from src : HADLdIN!IntegerLiteralExpression
   to dest : HADLdOUT!IntegerLiteralExpression (
         value <- src.value
      )
}

rule TBooleanLiteralExpression { 
   from src : HADLdIN!BooleanLiteralExpression 
   to dest : HADLdOUT!BooleanLiteralExpression (
         value <- src.value
      )
}

rule TBasedLiteralExpression { 
   from src : HADLdIN!BasedLiteralExpression
   to dest : HADLdOUT!BasedLiteralExpression (
         base <- src.base,
         value <- src.value
      )
}

rule TRange { 
   from src : HADLdIN!Range
   to dest : HADLdOUT!Range (
         slices <- src.slices,
         shiftAmount <- src.shiftAmount,
         right <- src.right,
         shift <- src.shift,
         arithmetic <- src.arithmetic
      )
}

rule TSlice { 
   from src : HADLdIN!Slice
   to dest : HADLdOUT!Slice (
         first <- src.first,
         last <- src.last,
         step <- src.step
      )
}

rule TAggregateFormat { 
   from src : HADLdIN!AggregateFormat 
   to dest : HADLdOUT!AggregateFormat (
         name <- src.name,
         behavior <- src.behavior,
         chunks <- src.chunks
      )
}

rule TFormatChunk { 
   from src : HADLdIN!FormatChunk 
   to dest : HADLdOUT!FormatChunk (
         behaviorChunk <- src.behaviorChunk,
         targetFormat <- src.targetFormat
      )
}
   
rule TAlternativeFormat { 
   from src : HADLdIN!AlternativeFormat 
   to dest : HADLdOUT!AlternativeFormat (
         name <- src.name,
         behavior <- src.behavior,
         choices <- src.choices
      )
}

rule TMatchFormatChoice { 
   from src : HADLdIN!MatchFormatChoice 
   to dest : HADLdOUT!MatchFormatChoice (
         matchedChoice <- src.matchedChoice
      )
}

rule TUseFormatChoice { 
   from src : HADLdIN!UseFormatChoice
   to dest : HADLdOUT!UseFormatChoice (
         usedFormat <- src.usedFormat
      )
}


