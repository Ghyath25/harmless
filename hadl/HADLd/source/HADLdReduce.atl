
--
-- HADLdIN dependency reduction
--
-- Preconditions
--
--    - Single variable assignment in operations and behaviors blocks.
--      Statement ordering should not be relevant : only data dependencies
--    - No return statement in procedures
--    - No functions
--    - All arguments in operation calls are simple variable references
--    - No for statement inside an if statement
--    - No if statement and no assignment statement
--    - A variable can be the target of at most one dependency
--
-- TODO list :
--
--    [DONE] collect leaf variables in dependencies
--    [DONE] remove local variables in operations
--    [DONE] Replace GlobalVariable with ComponentVariable
--

module HADLdMerge;
create OUT:HADLdOUT from IN:HADLdIN;

-- Procedures : keep only source and sink local variables
rule TProcedureOperation { 
   from src : HADLdIN!Operation
   to dest : HADLdOUT!Operation (
         name <- src.name,
         parameters <- src.parameters,
         localVariables <- src.localVariables->select(v| v.isSource() or v.isSink()),
         body <- src.body
      )
}

-- Pipelines : keep only source and sink local variables
rule TPipeline { 
   from src : HADLdIN!Pipeline 
   to dest : HADLdOUT!Pipeline (
         name <- src.name,
         architecture <- src.architecture,
         init <- src.init,
         expression <- src.expression,
         body <- src.body,
         localVariables <- src.localVariables->select(v| v.isSource() or v.isSink()),
         format <- src.format,
         stages <- src.stages
      )
}

-- Aggregate behaviors : keep only source and sink local variables
rule TAggregateBehavior { 
   from src : HADLdIN!AggregateBehavior 
   to dest : HADLdOUT!AggregateBehavior (
         name <- src.name,
         parameters <- src.parameters,
         localVariables <- src.localVariables->select(v| v.isSource() or v.isSink()),
         beforeBlock <- src.beforeBlock,
         afterBlock <- src.afterBlock,
         chunks <- src.chunks
      )
}

-- Alternative behaviors : keep only source and sink local variables
rule TAlternativeBehavior { 
   from src : HADLdIN!AlternativeBehavior 
   to dest : HADLdOUT!AlternativeBehavior (
         name <- src.name,
         parameters <- src.parameters,
         localVariables <- src.localVariables->select(v| v.isSource() or v.isSink()),
         beforeBlock <- src.beforeBlock,
         afterBlock <- src.afterBlock,
         choices <- src.choices
      )
}

-- Local variables : keep only source and sink local variables
rule TLocalVariable { 
   from src : HADLdIN!LocalVariable ( src.isSource() or src.isSink() )
   to dest : HADLdOUT!LocalVariable (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size
      )
}

-- Blocks : keep dependendency statements targeting sink variables
rule TBlock { 
   from src : HADLdIN!Block
   to
      dest : HADLdOUT!Block (
            statements <-
               src.statements->select(s|
                     if s.oclIsKindOf(HADLdIN!DependencyStatement) then
                        s.targetVariable.isSink()
                     else
                        true
                     endif
                  )
         )
}

-- Blocks : keep dependendency statements targeting sink variables
rule TDependencyStatement { 
   from src : HADLdIN!DependencyStatement ( src.targetVariable.isSink() )
   to dest : HADLdOUT!DependencyStatement (
         targetVariable <- src.targetVariable,
         sourceVariables <- src.getSourceVariables()
      )
}

-- Sink variables are
--    - (Output) parameters of operations and behaviors
--    - Component variables
--    - Local variables used in a pipeline 'run' clause
--    - Local variables passed to (input) parameters of operations or behaviors

helper context HADLdIN!Parameter def:
   isSink() : Boolean =
      true;

helper context HADLdIN!ComponentVariable def:
   isSink() : Boolean =
      true;

helper context HADLdIN!LocalVariable def:
   isSink() : Boolean =
      if not self.owningPipeline.oclIsUndefined() then
         self.owningPipeline.expression.dataContainer = self
      else
         HADLdIN!DataContainerRefExpression.allInstances()->exists(e|
               e.dataContainer = self and
               (
                  not e.owningOperationCall.oclIsUndefined() or
                  not e.owningBehaviorCallActual.oclIsUndefined()
               )
            )
      endif;

helper context HADLdIN!LoopVariable def:
   isSink() : Boolean =
      false;

-- Source variables are
--    - (Input) parameters of operations and behaviors
--    - Component variables
--    - Loop variables
--    - Local variables passed to (output) parameters of operations or behaviors

helper context HADLdIN!Parameter def:
   isSource() : Boolean =
      true;

helper context HADLdIN!ComponentVariable def:
   isSource() : Boolean =
      true;

helper context HADLdIN!LocalVariable def:
   isSource() : Boolean =
      HADLdIN!DataContainerRefExpression.allInstances()->exists(e|
            e.dataContainer = self and
            (
               not e.owningOperationCall.oclIsUndefined() or
               not e.owningBehaviorCallActual.oclIsUndefined()
            )
         );

helper context HADLdIN!LoopVariable def:
   isSource() : Boolean =
      true;

-- Traverse the dependency tree from this variable to its sources
-- Collect global variables and input parameters
helper context HADLdIN!DependencyStatement def:
   getSourceVariables() : Sequence(HADLdIN!Variable) =
      self.sourceVariables->collect(v|
            if v.isSource() then
               v
            else if v.dependenciesTarget->isEmpty() then
               Sequence{}
            else
               v.dependenciesTarget->asSequence()->first().getSourceVariables()
            endif endif
         )
         ->flatten();

--------------------------------------------------------------------------------
-- Straightforward copy rule
--------------------------------------------------------------------------------

-- Straightforward copy rule
rule TModel { 
   from src : HADLdIN!Model 
   to dest : HADLdOUT!Model (
         name <- src.name,
         elements <- src.elements,
         dataSize <- src.dataSize,
         instructionSize <- src.instructionSize
      )
}

-- Straightforward copy rule
rule TComponent { 
   from src : HADLdIN!Component 
   to dest : HADLdOUT!Component (
         name <- src.name,
         variables <- src.variables,
         operations <- src.operations
      )
}

-- Straightforward copy rule
rule TArchitecture { 
   from src : HADLdIN!Architecture 
   to dest : HADLdOUT!Architecture (
         name <- src.name,
         fathers <- src.fathers,
         resources <- src.resources
      )
}

-- Straightforward copy rule
rule TResource { 
   from src : HADLdIN!Resource 
   to dest : HADLdOUT!Resource (
         name <- src.name,
         component <- src.component,
         ports <- src.ports
      )
}
   
-- Straightforward copy rule
rule TPort { 
   from src : HADLdIN!Port 
   to dest : HADLdOUT!Port (
         name <- src.name,
         operations <- src.operations
      )
}
   
-- Straightforward copy rule
rule TStage { 
   from src : HADLdIN!Stage 
   to dest : HADLdOUT!Stage (
         name <- src.name,
         activations <- src.activations
      )
}
   
-- Straightforward copy rule
rule TResourceActivation { 
   from src : HADLdIN!ResourceActivation 
   to dest : HADLdOUT!ResourceActivation (
         resource <- src.resource,
         portActivations <- src.portActivations,
         releaseStage <- src.releaseStage,
         bypassStages <- src.bypassStages,
         priority <- src.priority,
         isReusable <- src.isReusable
      )
}
   
-- Straightforward copy rule
rule TPortActivation {
   from src : HADLdIN!PortActivation
   to dest : HADLdOUT!PortActivation (
         port <- src.port,
         releaseStage <- src.releaseStage,
         bypassStages <- src.bypassStages
      )
}

-- Straightforward copy rule
rule TBehaviorChunk { 
   from src : HADLdIN!BehaviorChunk 
   to dest : HADLdOUT!BehaviorChunk (
         name <- src.name,
         call <- src.call,
         condition <- src.condition
      )
}

-- Straightforward copy rule
rule TLeafBehaviorChoice { 
   from src : HADLdIN!LeafBehaviorChoice 
   to dest : HADLdOUT!LeafBehaviorChoice (
         name <- src.name,
         body <- src.body
      )
}

-- Straightforward copy rule
rule TCallBehaviorChoice { 
   from src : HADLdIN!CallBehaviorChoice 
   to dest : HADLdOUT!CallBehaviorChoice (
         call <- src.call
      )
}
   
-- Straightforward copy rule
rule TBehaviorCall { 
   from src : HADLdIN!BehaviorCall 
   to dest : HADLdOUT!BehaviorCall (
         behavior <- src.behavior,
         actualParameters <- src.actualParameters
      )
}
   
-- Straightforward copy rule
rule TComponentVariable { 
   from src : HADLdIN!ComponentVariable
   to dest : HADLdOUT!ComponentVariable (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size,
         isExternal <- src.isExternal
      )
}

-- Straightforward copy rule
rule TLoopVariable { 
   from src : HADLdIN!LoopVariable
   to dest : HADLdOUT!LoopVariable (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size
      )
}

-- Straightforward copy rule
rule TParameter { 
   from src : HADLdIN!Parameter
   to dest : HADLdOUT!Parameter (
         name <- src.name,
         isArray <- src.isArray,
         size <- src.size,
         isOutput <- src.isOutput
      )
}
   
-- Straightforward copy rule
rule TProcedureCallStatement { 
   from src : HADLdIN!ProcedureCallStatement 
   to dest : HADLdOUT!ProcedureCallStatement (
         call <- src.call
      )
}
   
-- Straightforward copy rule
rule TOperationCall { 
   from src : HADLdIN!OperationCall
   to dest : HADLdOUT!OperationCall (
         inline <- src.inline,
         component <- src.component,
         calledOperation <- src.calledOperation,
         actualParameters <-  src.actualParameters
      )
}

-- Straightforward copy rule
rule TForStatement { 
   from src : HADLdIN!ForStatement 
   to dest : HADLdOUT!ForStatement (
         counter <- src.counter,
         range <- src.range,
         body <- src.body
      )
}
   
-- Straightforward copy rule
rule TProcedureReturnStatement { 
   from src : HADLdIN!ReturnStatement
   to dest : HADLdOUT!ReturnStatement (
         expression <- src.expression
      )
}
   
-- Straightforward copy rule
rule TDataContainerRefExpression { 
   from src : HADLdIN!DataContainerRefExpression
   to dest : HADLdOUT!DataContainerRefExpression (
         dataContainer <- src.dataContainer,
         index <- src.index,
         range <- src.range,
         extend <- src.extend
      )
}

-- Straightforward copy rule
rule TOperatorExpression { 
   from src : HADLdIN!OperatorExpression
   to dest : HADLdOUT!OperatorExpression (
         operator <- src.operator,
         source <- src.source,
         arguments <- src.arguments
      )
}

-- Straightforward copy rule
rule TIntegerLiteralExpression { 
   from src : HADLdIN!IntegerLiteralExpression
   to dest : HADLdOUT!IntegerLiteralExpression (
         value <- src.value
      )
}

-- Straightforward copy rule
rule TBooleanLiteralExpression { 
   from src : HADLdIN!BooleanLiteralExpression 
   to dest : HADLdOUT!BooleanLiteralExpression (
         value <- src.value
      )
}

-- Straightforward copy rule
rule TBasedLiteralExpression { 
   from src : HADLdIN!BasedLiteralExpression
   to dest : HADLdOUT!BasedLiteralExpression (
         base <- src.base,
         value <- src.value
      )
}

-- Straightforward copy rule
rule TRange { 
   from src : HADLdIN!Range
   to dest : HADLdOUT!Range (
         slices <- src.slices,
         shiftAmount <- src.shiftAmount,
         right <- src.right,
         shift <- src.shift,
         arithmetic <- src.arithmetic
      )
}

-- Straightforward copy rule
rule TSlice { 
   from src : HADLdIN!Slice
   to dest : HADLdOUT!Slice (
         first <- src.first,
         last <- src.last,
         step <- src.step
      )
}

-- Straightforward copy rule
rule TAggregateFormat { 
   from src : HADLdIN!AggregateFormat 
   to dest : HADLdOUT!AggregateFormat (
         name <- src.name,
         behavior <- src.behavior,
         chunks <- src.chunks
      )
}

-- Straightforward copy rule
rule TFormatChunk { 
   from src : HADLdIN!FormatChunk 
   to dest : HADLdOUT!FormatChunk (
         behaviorChunk <- src.behaviorChunk,
         targetFormat <- src.targetFormat
      )
}
   
-- Straightforward copy rule
rule TAlternativeFormat { 
   from src : HADLdIN!AlternativeFormat 
   to dest : HADLdOUT!AlternativeFormat (
         name <- src.name,
         behavior <- src.behavior,
         choices <- src.choices
      )
}

-- Straightforward copy rule
rule TMatchFormatChoice { 
   from src : HADLdIN!MatchFormatChoice 
   to dest : HADLdOUT!MatchFormatChoice (
         matchedChoice <- src.matchedChoice
      )
}

-- Straightforward copy rule
rule TUseFormatChoice { 
   from src : HADLdIN!UseFormatChoice
   to dest : HADLdOUT!UseFormatChoice (
         usedFormat <- src.usedFormat
      )
}


