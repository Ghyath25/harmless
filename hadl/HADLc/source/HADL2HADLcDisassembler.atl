
module HADL2HADLcDisassembler;
create OUT:HADLc from IN:HADL;

rule TModel {
   from sourceModel : HADL!Model
   to
      targetModel : HADLc!Model (
            name <- sourceModel.name + 'Disassembler',
            includedFiles <- Sequence{includeStdlib, includeStdString, includeTypes, includeCustom, includeFields, includePaths, includeString, includeDebug, includeRunner},
            elements <-
               ---------- Function definitions for syntaxes
               sourceModel.elements
                  ->select(e| e.oclIsKindOf(HADL!Syntax))

               ---------- Function definitions for alternative behaviors with no syntax
               ->union(
                     sourceModel.elements
                        ->select(e| e.oclIsKindOf(HADL!AlternativeBehavior))
                        ->select(e| e.syntaxes->isEmpty())
                  )

               ---------- Function definitions for behaviors with several syntaxes
               ->union(
                     sourceModel.elements
                        ->select(e| e.oclIsKindOf(HADL!Behavior))
                        ->select(e| e.syntaxes->size() > 1)
                  )
         ),
      
      -- #include directives
      includeTypes : HADLc!IncludeFile (
            name <- 'hadl-types.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeCustom : HADLc!IncludeFile (
            name <- 'hadl-custom.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeStdString : HADLc!IncludeFile (
            name <- 'string.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeStdlib : HADLc!IncludeFile (
            name <- 'stdlib.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeFields : HADLc!IncludeFile (
            name <- 'hadl-fields.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includePaths : HADLc!IncludeFile (
            name <- 'hadl-paths.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeString : HADLc!IncludeFile (
            name <- 'hadl-string.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeDebug : HADLc!IncludeFile (
            name <- 'hadl-debug.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeRunner : HADLc!IncludeFile (
            name <- sourceModel.name + 'RunnerHeader.hadl.cpp',
            isStandard <- false,
            appearsInHeader <- true
         )
}

-------------------------------------------------------------------------------
-- Alternative behaviors with no syntax
-------------------------------------------------------------------------------

rule TAlternativeBehavior {
   from behavior : HADL!AlternativeBehavior ( behavior.syntaxes->isEmpty() )
   to
      function : HADLc!Function (
            name <- behavior.getDisassembleFunctionName(),
            parameters <- Sequence{functionParameterThis, bufferVariable, functionParameterCount, functionParameterArgs},
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false,
            body <- functionBody
         ),
      functionParameterThis : HADLc!Parameter (
            name <- '_this',
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      bufferVariable : HADLc!Parameter (
            name <- '_buffer',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      functionParameterCount : HADLc!Parameter (
            name <- '_count',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false
         ),
      functionParameterArgs : HADLc!Parameter (
            name <- '_args',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            isArray <- true
         ),
      functionBody : HADLc!Block (
            statements <- Sequence{functionDummyBlock, switchStatement}
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),
      switchStatement : HADLc!SwitchStatement (
            expression <- switchExpression,
            cases <- behavior.choices->collect(c| thisModule.resolveTemp(c, 'case'))
         ),
      switchExpression : HADLc!FieldRefExpression (
            expression <- switchExpressionVariable,
            fieldName <- '_choice',
            fromPointer <- true
         ),
      switchExpressionVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )

      do {
         thisModule.TPrint('(SYN) Disassembling behavior: ' + behavior.name, functionDummyBlock);
      }
}

rule TCallBehaviorChoice {
   from choice : HADL!CallBehaviorChoice
   to
      case : HADLc!Case (
            value <- caseValue,
            statements <- callStatement
         ),
      caseValue : HADLc!EnumLiteralRefExpression (
            name <- choice.getLiteralName()
         ),

      callStatement : HADLc!ExpressionStatement (
            expression <- call
         ),
      call : HADLc!FunctionCall (
            functionName <- choice.call.behavior.getDisassembleFunctionName(),
            actualParameters <-
               Sequence{functionArgumentCast, functionArgumentBuffer, functionArgumentCount, functionArgumentArgs}
         ),
      functionArgumentCast : HADLc!CastExpression (
            typeName <- choice.call.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            isArray <- false,
            expression <- functionArgumentTarget
         ),
      functionArgumentTarget : HADLc!FieldRefExpression (
            expression <- functionArgumentThis,
            fieldName <- '_target',
            fromPointer <- true
         ),
      functionArgumentThis : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      functionArgumentBuffer : HADLc!VariableRefExpression (
            variableName <- '_buffer'
         ),
      functionArgumentCount : HADLc!VariableRefExpression (
            variableName <- '_count'
         ),
      functionArgumentArgs : HADLc!VariableRefExpression (
            variableName <- '_args'
         )
}

-------------------------------------------------------------------------------
-- Behaviors with several syntaxes
-------------------------------------------------------------------------------

rule TBehavior {
   from behavior : HADL!Behavior ( behavior.syntaxes->size() > 1 )
   to
      function : HADLc!Function (
            name <- behavior.getDisassembleFunctionName(),
            parameters <- Sequence{functionParameterThis, bufferVariable, functionParameterCount, functionParameterArgs},
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false,
            body <- functionBody
         ),
      functionParameterThis : HADLc!Parameter (
            name <- '_this',
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      bufferVariable : HADLc!Parameter (
            name <- '_buffer',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      functionParameterCount : HADLc!Parameter (
            name <- '_count',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false
         ),
      functionParameterArgs : HADLc!Parameter (
            name <- '_args',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            isArray <- true
         ),
      functionBody : HADLc!Block (
            statements <- Sequence{functionDummyBlock, ifStatement}
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      ifStatement : HADLc!IfStatement (
            ifClauses <- behavior.syntaxes->collect(f| f.paths)->flatten()
            -- TODO Else Error
         )

      do {
         thisModule.TPrint('(SYN) Disassembling behavior: ' + behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- Paths
-- TODO path field condition
-------------------------------------------------------------------------------

rule TPath {
   from path : HADL!Path ( not path.owningSyntax.oclIsUndefined() )
   to
      ifClause : HADLc!IfClause (
            condition <- ifClauseCondition,
            thenClause <- thenClause
         ),
      ifClauseCondition : HADLc!FunctionCall (
            functionName <- 'HADL_checkPath<' + thisModule.getInstructionTypeName() + '>',
            actualParameters <-
               Sequence{ argumentInstr, argumentRange, argumentRangeSize, argumentMask, argumentValue, argumentParent, argumentPath, argumentPathSize }
                  ->union(thisModule.reverseSequence(path.elements))
         ),
      argumentInstr : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      argumentRange : HADLc!VariableRefExpression (
            variableName <- 'NULL'
         ),
      argumentRangeSize : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      argumentMask : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      argumentValue : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      argumentParent : HADLc!FieldRefExpression (
            expression <- argumentParentSource,
            fieldName <- '_parent',
            fromPointer <- true
         ),
      argumentParentSource : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      argumentPath : HADLc!FieldRefExpression (
            expression <- argumentPathSource,
            fieldName <- '_path',
            fromPointer <- true
         ),
      argumentPathSource : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      argumentPathSize : HADLc!IntegerLiteralExpression (
            value <- path.elements->size()
         ),

      thenClause : HADLc!ExpressionStatement (
            expression <- call
         ),
      call : HADLc!FunctionCall (
            functionName <- path.owningSyntax.getDisassembleFunctionName(),
            actualParameters <-
               Sequence{functionArgumentThis, functionArgumentBuffer, functionArgumentCount, functionArgumentArgs}
         ),
      functionArgumentThis : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      functionArgumentBuffer : HADLc!VariableRefExpression (
            variableName <- '_buffer'
         ),
      functionArgumentCount : HADLc!VariableRefExpression (
            variableName <- '_count'
         ),
      functionArgumentArgs : HADLc!VariableRefExpression (
            variableName <- '_args'
         )
}

rule TPathElement {
   from element : HADL!PathElement
   to
      expression : HADLc!EnumLiteralRefExpression (
            name <- element.getChunkOrChoice().getPathLiteralName()
         )
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.2. Aggregate syntax
-------------------------------------------------------------------------------
-- For each aggregate syntax, we generate
--
--    - a function definition
-------------------------------------------------------------------------------

rule TAggregateSyntax {
   from syntax : HADL!AggregateSyntax
   to
      function : HADLc!Function (
            name <- syntax.getDisassembleFunctionName(),
            parameters <-
               Sequence{functionParameterThis, bufferVariable, functionParameterCount, functionParameterArgs},
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false,
            body <- functionBody
         ),
      functionParameterThis : HADLc!Parameter (
            name <- '_this',
            typeName <- syntax.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      bufferVariable : HADLc!Parameter (
            name <- '_buffer',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      functionParameterCount : HADLc!Parameter (
            name <- '_count',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false
         ),
      functionParameterArgs : HADLc!Parameter (
            name <- '_args',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            isArray <- true
         ),
      functionBody : HADLc!Block (
            variables <-
               syntax.attributeSyntaxes
                  ->collect(s| thisModule.resolveTemp(s, 'bufferVariable')),
            statements <-
                  Sequence{functionDummyBlock}
                     ->union(syntax.attributeSyntaxes)
                     ->append(echoStatement)
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      echoStatement : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(syntax.echo),
            statements <-
               if syntax.echo.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(syntax.echo, 'statement')}
               else
                  Sequence{}
               endif
               ->append(strcpyStatement)
         ),
      strcpyStatement : HADLc!ExpressionStatement (
            expression <- strcpyCall
         ),
      strcpyCall : HADLc!FunctionCall (
            functionName <- 'strcpy',
            actualParameters <- Sequence{strcpyDestination, thisModule.TSyntaxExpressionTargetExpression(syntax.echo)}
         ),
      strcpyDestination : HADLc!VariableRefExpression (
            variable <- bufferVariable
         )

      do {
         thisModule.TPrint('(SYN) Disassembling syntax: ' + syntax.behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.5. Attribute syntax
-------------------------------------------------------------------------------
-- For each attribute syntax we generate a call to 'strcpy' with the source
-- expression as an operand.
-------------------------------------------------------------------------------

rule TAttributeSyntax {
   from syn : HADL!AttributeSyntax
   to
      statement : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(syn.expression),
            statements <-
               if syn.expression.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(syn.expression, 'statement')}
               else
                  Sequence{}
               endif
               ->append(strcpy)
         ),
      strcpy : HADLc!ExpressionStatement (
            expression <- strcpyCall
         ),
      strcpyCall : HADLc!FunctionCall (
            functionName <- 'strcpy',
            actualParameters <- Sequence{strcpyDestination, thisModule.TSyntaxExpressionTargetExpression(syn.expression)}
         ),
      strcpyDestination : HADLc!VariableRefExpression (
            variable <- bufferVariable
         ),

      bufferVariable : HADLc!Variable (
            name <- syn.getBufferVariableName(),
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false,
            "size" <- bufferVariableSize
         ),
      bufferVariableSize : HADLc!VariableRefExpression (
            variableName <- 'HADL_BUFFER_SIZE'
         )
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.6. Alternative syntax - before expression
-------------------------------------------------------------------------------
-- An alternative syntax can have an optional 'before' expression.
-- The before clause is transformed into a block with a call to 'strcpy'.
-------------------------------------------------------------------------------

unique lazy rule TAlternativeSyntaxBefore {
   from syntax : HADL!AlternativeSyntax (
         not syntax.before.oclIsUndefined()
      )
   to
      beforeBlock : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(syntax.before),
            statements <-
               if syntax.before.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(syntax.before, 'statement')}
               else
                  Sequence{}
               endif
               ->append(beforeStrcpyStatement)
         ),
      beforeStrcpyStatement : HADLc!ExpressionStatement (
            expression <- beforeStrcpyCall
         ),
      beforeStrcpyCall : HADLc!FunctionCall (
            functionName <- 'strcpy',
            actualParameters <- Sequence{beforeStrcpyDestination, thisModule.TSyntaxExpressionTargetExpression(syntax.before)}
         ),
      beforeStrcpyDestination : HADLc!VariableRefExpression (
            variable <- thisModule.resolveTemp(syntax, 'bufferVariable')
         )
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.7. Alternative syntax - after expression
-------------------------------------------------------------------------------
-- An alternative syntax can have an optional 'after' expression.
-- The after clause is transformed into a block with a call to 'strcat'.
-------------------------------------------------------------------------------

unique lazy rule TAlternativeSyntaxAfter {
   from syntax : HADL!AlternativeSyntax (
         not syntax.after.oclIsUndefined()
      )
   to
      afterBlock : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(syntax.after),
            statements <-
               if syntax.after.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(syntax.after, 'statement')}
               else
                  Sequence{}
               endif
               ->append(afterStrcatStatement)
         ),
      afterStrcatStatement : HADLc!ExpressionStatement (
            expression <- afterStrcatCall
         ),
      afterStrcatCall : HADLc!FunctionCall (
            functionName <- 'strcat',
            actualParameters <- Sequence{afterStrcatDestination, thisModule.TSyntaxExpressionTargetExpression(syntax.after)}
         ),
      afterStrcatDestination : HADLc!VariableRefExpression (
            variable <- thisModule.resolveTemp(syntax, 'bufferVariable')
         )
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.8. Alternative syntax - main rule
-------------------------------------------------------------------------------
-- For each alternative syntax, we generate a function definition.
-------------------------------------------------------------------------------

rule TAlternativeSyntax {
   from syntax : HADL!AlternativeSyntax
   to
      function : HADLc!Function (
            name <- syntax.getDisassembleFunctionName(),
            parameters <-
               Sequence{functionParameterThis, bufferVariable, functionParameterCount, functionParameterArgs},
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false,
            body <- functionBody
         ),
      functionParameterThis : HADLc!Parameter (
            name <- '_this',
            typeName <- syntax.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      bufferVariable : HADLc!Parameter (
            name <- '_buffer',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isArray <- false,
            isPointer <- true
         ),
      functionParameterCount : HADLc!Parameter (
            name <- '_count',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false
         ),
      functionParameterArgs : HADLc!Parameter (
            name <- '_args',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            isArray <- true
         ),
      functionBody : HADLc!Block (
            variables <-
               syntax.attributeSyntaxes->collect(s| thisModule.resolveTemp(s, 'bufferVariable')),
            statements <-
               Sequence{functionDummyBlock, bufferInitStatement}
               ->union(syntax.attributeSyntaxes)
               ->union(
                  if syntax.before.oclIsUndefined() then
                     Sequence{}
                  else
                     Sequence{ thisModule.TAlternativeSyntaxBefore(syntax) }
                  endif
               )
               ->append(switchStatement)
               ->union(
                  if syntax.after.oclIsUndefined() then
                     Sequence{}
                  else
                     Sequence{ thisModule.TAlternativeSyntaxAfter(syntax) }
                  endif
               )
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      bufferInitStatement : HADLc!ExpressionStatement (
            expression <- bufferInitExpression
         ),
      bufferInitExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- bufferInitLeft,
            arguments <- bufferInitRight
         ),
      bufferInitLeft : HADLc!OperatorExpression (
            operator <- '*',
            source <- bufferInitBuffer
         ),
      bufferInitBuffer : HADLc!VariableRefExpression (
            variableName <- '_buffer'
         ),
      bufferInitRight : HADLc!IntegerLiteralExpression (
            value <- 0
         ),

      switchStatement : HADLc!SwitchStatement (
            expression <- switchExpression,
            cases <- syntax.choices->collect(c| thisModule.resolveTemp(c, 'case'))
         ),
      switchExpression : HADLc!FieldRefExpression (
            expression <- switchExpressionVariable,
            fieldName <- '_choice',
            fromPointer <- true
         ),
      switchExpressionVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )

      do {
         thisModule.TPrint('(SYN) Disassembling with syntax: ' + syntax.behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.9. Alternative syntax choices
-------------------------------------------------------------------------------
-- Alternative syntax choice
-------------------------------------------------------------------------------

rule TSyntaxChoice {
   from choice : HADL!SyntaxChoice
   to
      case : HADLc!Case (
            value <- caseValue,
            statements <- body
         ),
      caseValue : HADLc!EnumLiteralRefExpression (
            name <- choice.behaviorChoice.getLiteralName()
         ),

      body : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(choice.expression),
            statements <-
               if choice.expression.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(choice.expression, 'statement')}
               else
                  Sequence{}
               endif
               ->append(strcatStatement)
         ),
      strcatStatement : HADLc!ExpressionStatement (
            expression <- strcatCall
         ),
      strcatCall : HADLc!FunctionCall (
            functionName <- 'strcat',
            actualParameters <- Sequence{strcatDestination, thisModule.TSyntaxExpressionTargetExpression(choice.expression)}
         ),
      strcatDestination : HADLc!VariableRefExpression (
            variableName <- '_buffer'
         )
}

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.11. Syntax calls
-------------------------------------------------------------------------------
-- A syntax call is transformed into a block of statements with a buffer
-- variable and a function call to the disassemble function for the called
-- syntax.
-------------------------------------------------------------------------------

rule TSyntaxCall {
   from call : HADL!SyntaxCall
   using {
      behavior : HADL!Behavior = call.getOwningBehavior();
   }
   to
      statement : HADLc!Block (
            variables <-
               call.actualParameters->collect(p| thisModule.TSyntaxExpressionBufferVariable(p))
               ->including(argsArray),
            statements <- 
               call.actualParameters
                  ->select(p| p.mapsToStatement())
                  ->collect(p| thisModule.resolveTemp(p, 'statement'))
                  ->append(callStatement)
         ),
      argsArray : HADLc!Variable (
            name <- '_tmpArgs',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            isArray <- true,
            init <- argsArrayExpression
         ),
      argsArrayExpression : HADLc!ArrayExpression (
            elements <- call.actualParameters->collect(p| thisModule.TSyntaxExpressionTargetExpression(p))
         ),
      callStatement : HADLc!ExpressionStatement (
            expression <- functionCall
         ),
      functionCall : HADLc!FunctionCall (
            functionName <- call.behavior.getDisassembleFunctionName(),
            actualParameters <-
               Sequence{functionArgumentCast, functionArgumentBuffer, functionArgumentCount, functionArgumentArgs}
         ),
      functionArgumentCast : HADLc!CastExpression (
            typeName <- call.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            isArray <- false,
            expression <- functionArgumentTarget
         ),
      functionArgumentTarget : HADLc!FieldRefExpression (
            expression <- functionArgumentThis,
            fieldName <-
               if not call.behaviorChunk.oclIsUndefined() then
                  call.behaviorChunk.getFieldName()
               else if behavior.oclIsKindOf(HADL!AggregateBehavior) then
                  behavior.chunks
                     ->select(c| c.call.behavior = call.behavior)
                     ->asSequence()->first()
                     .getFieldName()
               else
                  '_target'
               endif endif,
            fromPointer <- true
         ),
      functionArgumentThis : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      functionArgumentBuffer : HADLc!VariableRefExpression (
            variable <-
               if not call.owningChoice.oclIsUndefined() then
                  thisModule.resolveTemp(call.owningChoice.owningSyntax, 'bufferVariable')
               else
                  thisModule.TSyntaxExpressionBufferVariable(call)
               endif
         ),
      functionArgumentCount : HADLc!IntegerLiteralExpression (
            value <- call.actualParameters->size()
         ),
      functionArgumentArgs : HADLc!VariableRefExpression (
            variable <- argsArray
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.5. Parameter syntax expressions
-------------------------------------------------------------------------------

unique lazy rule TSyntaxExpressionBufferVariable {
   from sourceExpression : HADL!SyntaxExpression
   to
      bufferVariable : HADLc!Variable (
            name <- thisModule.newBufferName(),
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- not sourceExpression.hasSize(),
            isArray <- false,
            init <-
               if sourceExpression.hasInitValue() then
                  thisModule.resolveTemp(sourceExpression, 'bufferVariableValue')
               else
                  OclUndefined
               endif,
            "size" <-
               if sourceExpression.hasSize() then
                  thisModule.TSyntaxExpressionBufferVariableSize(sourceExpression)
               else
                  Sequence{}
               endif
         )
}

unique lazy rule TSyntaxExpressionBufferVariableSize {
   from sourceExpression : HADL!SyntaxExpression
   to
      bufferVariableSize : HADLc!VariableRefExpression (
            variableName <- 'HADL_BUFFER_SIZE'
         )
}

lazy rule TSyntaxExpressionTargetExpression {
   from sourceExpression : HADL!SyntaxExpression
   to
      targetExpression : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         )
}

rule TParameterRefSyntaxExpression {
   from sourceExpression : HADL!DataContainerRefSyntaxExpression (
         sourceExpression.dataContainer.oclIsKindOf(HADL!SyntaxParameter)
      )
   to
      bufferVariableValue : HADLc!ArrayElementExpression (
            expression <- variableRef,
            indices <- index
         ),
      variableRef : HADLc!VariableRefExpression (
            variableName <- '_args'
         ),
      index : HADLc!IntegerLiteralExpression (
            value <- sourceExpression.dataContainer.owningSyntax.parameters->indexOf(sourceExpression.dataContainer) - 1
         )
}

rule TAttributeRefSyntaxExpression {
   from sourceExpression : HADL!DataContainerRefSyntaxExpression (
         sourceExpression.dataContainer.oclIsKindOf(HADL!Attribute)
      )
   to
      bufferVariableValue : HADLc!VariableRefExpression (
            variableName <- sourceExpression.dataContainer.getBufferVariableName()
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.6. String literal syntax expressions
-------------------------------------------------------------------------------

rule TStringLiteralSyntaxExpression {
   from sourceExpression : HADL!StringLiteralSyntaxExpression
   to   
      bufferVariableValue : HADLc!StringLiteralExpression (
            value <- sourceExpression.value
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.7. Decision syntax expressions
-------------------------------------------------------------------------------

rule TDecisionSyntaxExpression {
   from sourceExpression : HADL!DecisionSyntaxExpression
   to   
      statement : HADLc!IfStatement (
            ifClauses <- ifClause,
            elseClause <-
               if sourceExpression.expressionWhenFalse.oclIsUndefined() then
                  thisModule.TDecisionSyntaxExpressionWithEmptyRightMember(sourceExpression)
               else
                  thisModule.TDecisionSyntaxExpressionWithRightMember(sourceExpression)
               endif
         ),
      ifClause : HADLc!IfClause (
            condition <- ifCondition,
            thenClause <- thenClause
         ),
      ifCondition : HADLc!FieldRefExpression (
            expression <- ifConditionVariable,
            fieldName <- sourceExpression.getOwningChunkOrAttributeName(),
            fromPointer <- true
         ),
      ifConditionVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      thenClause : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression.expressionWhenTrue),
            statements <-
               if sourceExpression.expressionWhenTrue.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(sourceExpression.expressionWhenTrue, 'statement')}
               else
                  Sequence{}
               endif
               ->append(thenAssignment)
         ),
      thenAssignment : HADLc!ExpressionStatement (
            expression <- thenExpression
         ),
      thenExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- thenLeft,
            arguments <- thisModule.TSyntaxExpressionTargetExpression(sourceExpression.expressionWhenTrue)
         ),
      thenLeft : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         )
}

unique lazy rule TDecisionSyntaxExpressionWithRightMember {
   from sourceExpression : HADL!DecisionSyntaxExpression (
         not sourceExpression.expressionWhenFalse.oclIsUndefined()
      )
   to   
      elseClause : HADLc!Block (
            variables <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression.expressionWhenFalse),
            statements <-
               if sourceExpression.expressionWhenFalse.mapsToStatement() then
                  Sequence{thisModule.resolveTemp(sourceExpression.expressionWhenFalse, 'statement')}
               else
                  Sequence{}
               endif
               ->append(elseAssignment)
         ),
      elseAssignment : HADLc!ExpressionStatement (
            expression <- elseExpression
         ),
      elseExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- elseLeft,
            arguments <- thisModule.TSyntaxExpressionTargetExpression(sourceExpression.expressionWhenFalse)
         ),
      elseLeft : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         )
}

unique lazy rule TDecisionSyntaxExpressionWithEmptyRightMember {
   from sourceExpression : HADL!DecisionSyntaxExpression (
         sourceExpression.expressionWhenFalse.oclIsUndefined()
      )
   to   
      elseClause : HADLc!ExpressionStatement (
            expression <- elseExpression
         ),
      elseExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- elseLeft,
            arguments <- elseRight
         ),
      elseLeft : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         ),
      elseRight : HADLc!StringLiteralExpression (
            value <- ''
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.8. Computed syntax expressions
-------------------------------------------------------------------------------

helper def:
   getNumberPrefix(base : HADL!BaseSpecifier) : String =
      let syntax : HADL!NumberSyntax =
         HADL!NumberSyntax.allInstances()->select(s| s.base = base)->asSequence()->first()
      in
         if syntax.oclIsUndefined() then
            ''
         else if syntax.prefix.oclIsUndefined() then
            ''
         else
            syntax.prefix
         endif endif;
      
helper def:
   getNumberSuffix(base : HADL!BaseSpecifier) : String =
      let syntax : HADL!NumberSyntax =
         HADL!NumberSyntax.allInstances()->select(s| s.base = base)->asSequence()->first()
      in
         if syntax.oclIsUndefined() then
            ''
         else if syntax.suffix.oclIsUndefined() then
            ''
         else
            syntax.suffix
         endif endif;
      
rule TComputedSyntaxExpression {
   from sourceExpression : HADL!ComputedSyntaxExpression
   to
      statement : HADLc!Block (
            variables <- sourceExpression.expression.getRanges(),
            statements <- callStatement
         ),
      callStatement : HADLc!ExpressionStatement (
            expression <- toStringCall
         ),
      toStringCall : HADLc!FunctionCall (
            functionName <- 'HADL_String_convert<' + thisModule.getInstructionTypeName() + '>',
            actualParameters <-
               Sequence{
                  toStringDestination,
                  sourceExpression.expression,
                  toStringBase,
                  toStringPrefix,
                  toStringSuffix
               }
         ),
      toStringDestination : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         ),
      toStringBase : HADLc!IntegerLiteralExpression (
            value <- thisModule.getBase(sourceExpression.defaultBase)
         ),
      toStringPrefix : HADLc!StringLiteralExpression (
            value <- thisModule.getNumberPrefix(sourceExpression.defaultBase)
         ),
      toStringSuffix : HADLc!StringLiteralExpression (
            value <- thisModule.getNumberSuffix(sourceExpression.defaultBase)
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.9. Implicit chunk value syntax expressions
-------------------------------------------------------------------------------

rule TImplicitValueSyntaxExpression {
   from sourceExpression : HADL!ImplicitValueSyntaxExpression
   to
      statement : HADLc!ExpressionStatement (
            expression <- toStringCall
         ),
      toStringCall : HADLc!FunctionCall (
            functionName <- 'HADL_String_convert<' + thisModule.getInstructionTypeName() + '>',
            actualParameters <-
               Sequence{
                  toStringDestination,
                  toStringSource,
                  toStringBase,
                  toStringPrefix,
                  toStringSuffix
               }
         ),
      toStringDestination : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         ),
      toStringSource : HADLc!FieldRefExpression (
            expression <- toStringSourceVariable,
            fieldName <- sourceExpression.getOwningChunkOrAttributeName(),
            fromPointer <- true
         ),
      toStringSourceVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      toStringBase : HADLc!IntegerLiteralExpression (
            value <- thisModule.getBase(sourceExpression.defaultBase)
         ),
      toStringPrefix : HADLc!StringLiteralExpression (
            value <- thisModule.getNumberPrefix(sourceExpression.defaultBase)
         ),
      toStringSuffix : HADLc!StringLiteralExpression (
            value <- thisModule.getNumberSuffix(sourceExpression.defaultBase)
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.10. List syntax expressions
-------------------------------------------------------------------------------

rule TListSyntaxExpression {
   from sourceExpression : HADL!ListSyntaxExpression
   to
      statement : HADLc!ExpressionStatement (
            expression <- listToStringCall
         ),
      listToStringCall : HADLc!FunctionCall (
            functionName <- 'HADL_String_convertList<' + thisModule.getInstructionTypeName() + '>',
            actualParameters <-
               Sequence{
                  listToStringDestination,
                  listToStringSource,
                  listToStringItemPrefix,
                  listToStringItemSeparator,
                  listToStringBase,
                  listToStringNumberPrefix,
                  listToStringNumberSuffix
               }
         ),
      listToStringDestination : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         ),
      listToStringSource : HADLc!FieldRefExpression (
            expression <- listToStringSourceVariable,
            fieldName <- sourceExpression.getOwningChunkOrAttributeName(),
            fromPointer <- true
         ),
      listToStringSourceVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         ),
      listToStringItemPrefix : HADLc!StringLiteralExpression (
            value <- sourceExpression.prefix
         ),
      listToStringItemSeparator : HADLc!StringLiteralExpression (
            value <- sourceExpression.separator
         ),
      listToStringBase : HADLc!IntegerLiteralExpression (
            value <- thisModule.getBase(sourceExpression.base)
         ),
      listToStringNumberPrefix : HADLc!StringLiteralExpression (
            value <- thisModule.getNumberPrefix(sourceExpression.base)
         ),
      listToStringNumberSuffix : HADLc!StringLiteralExpression (
            value <- thisModule.getNumberSuffix(sourceExpression.base)
         )
}

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.11. Concatenation syntax expressions
-------------------------------------------------------------------------------

rule TConcatenationSyntaxExpression {
   from sourceExpression : HADL!ConcatenationSyntaxExpression
   to
      statement : HADLc!Block (
            variables <- sourceExpression.expressions->collect(e| thisModule.TSyntaxExpressionBufferVariable(e)),
            statements <-
               sourceExpression.expressions
                  ->select(e| e.mapsToStatement())
                  ->collect(e| thisModule.resolveTemp(e, 'statement'))
               ->append(bufferInitStatement)
               ->union(strcatStatements)
         ),
         
      bufferInitStatement : HADLc!ExpressionStatement (
            expression <- bufferInitExpression
         ),
      bufferInitExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- bufferInitLeft,
            arguments <- bufferInitRight
         ),
      bufferInitLeft : HADLc!OperatorExpression (
            operator <- '*',
            source <- bufferInitBuffer
         ),
      bufferInitBuffer : HADLc!VariableRefExpression (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         ),
      bufferInitRight : HADLc!IntegerLiteralExpression (
            value <- 0
         ),

      strcatStatements : distinct HADLc!ExpressionStatement foreach(e in sourceExpression.expressions) (
            expression <- strcatCalls
         ),
      strcatCalls : distinct HADLc!FunctionCall foreach(e in sourceExpression.expressions) (
            functionName <- 'strcat',
            actualParameters <- strcatDestination,
            actualParameters <- strcatSource
         ),
      strcatDestination : distinct HADLc!VariableRefExpression foreach(e in sourceExpression.expressions) (
            variable <- thisModule.TSyntaxExpressionBufferVariable(sourceExpression)
         ),
      strcatSource : distinct HADLc!VariableRefExpression foreach(e in sourceExpression.expressions) (
            variable <- thisModule.TSyntaxExpressionBufferVariable(e)
         )
}

unique lazy rule TRangeInSourceExpressionGetField {
   from range : HADL!Range
   to
      getField : HADLc!FunctionCall (
            functionName <- range.getFunctionNameFieldGetValue(),
            actualParameters <-
               Sequence{
                  thisModule.resolveTemp(range.owningDataContainerRefExpression, 'getFieldData'),
                  getFieldRange, getFieldSize, getFieldShift, getFieldRight, getFieldRotate, getFieldArithmetic
               }
         ),
      getFieldRange : HADLc!VariableRefExpression (
            variable <- range
         ),
      getFieldSize : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      getFieldShift : HADLc!IntegerLiteralExpression (
            value <- range.shiftAmount
         ),
      getFieldRight : HADLc!IntegerLiteralExpression (
            value <- if range.right then 1 else 0 endif
         ),
      getFieldRotate : HADLc!IntegerLiteralExpression (
            value <- if range.shift then 0 else 1 endif
         ),
      getFieldArithmetic : HADLc!IntegerLiteralExpression (
            value <- if range.arithmetic then 1 else 0 endif
         )
}

helper def: bufferIndex : Integer = 0;

-------------------------------------------------------------------------------
-- Global variables and rules common to several modules
-------------------------------------------------------------------------------

rule TPrint (message : String, block : HADLc!Block) {
   to
      printStatement : HADLc!ExpressionStatement (
            expression <- printCall,
            owningBlock <- block
         ),
      printCall : HADLc!FunctionCall (
            functionName <- 'HADL_Debug_printMessage',
            actualParameters <- printArgument
         ),
      printArgument : HADLc!StringLiteralExpression (
            value <- message
         )
}

rule TAttributeRefExpression {
   from attrExpression : HADL!DataContainerRefExpression (
         attrExpression.dataContainer.oclIsKindOf(HADL!Attribute) and
         attrExpression.range.oclIsUndefined()
      )
   to
      fieldExpression : HADLc!FieldRefExpression (
            expression <- fieldExpressionVariable,
            fieldName <- attrExpression.dataContainer.name,
            fromPointer <- true
         ),
      fieldExpressionVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )
}

rule TAttributeRefExpressionWithRange {
   from attrExpression : HADL!DataContainerRefExpression (
         attrExpression.dataContainer.oclIsKindOf(HADL!Attribute) and
         not attrExpression.range.oclIsUndefined()
      )
   to
      wrapper : HADLc!WrapperExpression (
            expression <- thisModule.TRangeInSourceExpressionGetField(attrExpression.range)
         ),
      getFieldData : HADLc!FieldRefExpression (
            expression <- getFieldDataVariable,
            fieldName <- attrExpression.dataContainer.name,
            fromPointer <- true
         ),
      getFieldDataVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )
}

rule TBooleanLiteralExpression {
   from sourceLiteral : HADL!BooleanLiteralExpression
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- if sourceLiteral.value then 1 else 0 endif
         )
}

rule TOperatorExpression {
   from sourceExpression : HADL!OperatorExpression
   to
      targetExpression : HADLc!OperatorExpression (
            operator <-
               if sourceExpression.operator = '?not' then '!' else
               if sourceExpression.operator = '?and' then '&&' else
               if sourceExpression.operator = '?or' then '||' else
               if sourceExpression.operator = 'not' then '~' else
               if sourceExpression.operator = 'and' then '&' else
               if sourceExpression.operator = 'or' then '|' else
               if sourceExpression.operator = 'xor' then '^' else
               if sourceExpression.operator = '=' then '==' else
               if sourceExpression.operator = '/=' then '!=' else
               if sourceExpression.operator = 'asr' then '>>' else
               if sourceExpression.operator = 'lsl' then '<<' else
               if sourceExpression.operator = 'rem' then '%' else
                  -- TODO others: ?xor
                  sourceExpression.operator
               endif endif endif endif endif endif endif endif endif endif endif endif,
            source <- sourceExpression.source,
            arguments <- sourceExpression.arguments
         )
}

rule TBasedLiteralExpression {
   from sourceLiteral : HADL!BasedLiteralExpression (
         sourceLiteral.owningChoice.oclIsUndefined()
      )
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- sourceLiteral.getValue()
         )
}

rule TIntegerLiteralExpression {
   from sourceLiteral : HADL!IntegerLiteralExpression
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- sourceLiteral.value
         )
}


helper def: rangeIndex : Integer = 0;

rule TRange {
   from range : HADL!Range
   to
      variable : HADLc!Variable (
            name <- thisModule.newRangeVariableName(),
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            isArray <- false,
            size <- Sequence{sizeHeight, sizeWidth},
            init <- array
         ),
      sizeHeight : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      sizeWidth : HADLc!IntegerLiteralExpression (
            value <- 3
         ),
      array : HADLc!ArrayExpression (
            elements <- range.slices
         )
}
      
rule TSliceWithFirstLastAndStep {
   from slice : HADL!Slice (
         not slice.last.oclIsUndefined() and
         not slice.step.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  slice.last,
                  slice.step
               }
         )
}

rule TSliceWithFirstAndLast {
   from slice : HADL!Slice (
         not slice.last.oclIsUndefined() and
         slice.step.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  slice.last,
                  step
               }
         ),
      step : HADLc!IntegerLiteralExpression (
            value <- 1
         )
}

rule TSliceWithFirstOnly {
   from slice : HADL!Slice (
         slice.last.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  last,
                  step
               }
         ),
      last : HADLc!CopyExpression (
            copiedExpression <- slice.first
         ),
      step : HADLc!IntegerLiteralExpression (
            value <- 1
         )
}

