
module HADL2HADLcDecoder;
create OUT:HADLc from IN:HADL;

uses HADL2HADLcHelpers;

rule TModel {
   from sourceModel : HADL!Model
   to
      targetModel : HADLc!Model (
            name <- sourceModel.name + 'Decoder',
            includedFiles <- Sequence{includeStdlib, includeTypes, includeCustom, includeFields, includePaths, includeDebug, includeRunner},
            elements <-
               ---------- Range variables
               HADL!Range.allInstances()->select(r|
                     not r.owningFormat.oclIsUndefined() or
                     not r.owningFieldAttributeFormat.oclIsUndefined() or
                     not r.owningPath.oclIsUndefined()
                  )
               
               ---------- Function definitions for formats
               ->union(
                  sourceModel.elements
                     ->select(e| e.oclIsKindOf(HADL!Format))
                     ->collect(f| thisModule.resolveTemp(f, 'function'))
               )
               
               ---------- Function definitions for behaviors with no or several format(s)
               ->union(
                  sourceModel.elements
                     ->select(e| e.oclIsKindOf(HADL!Behavior))
                     ->select(b| b.formats->size() <> 1)
                     ->collect(f| thisModule.resolveTemp(f, 'function'))
               )
         ),
      
      -- #include directives
      includeTypes : HADLc!IncludeFile (
            name <- 'hadl-types.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeCustom : HADLc!IncludeFile (
            name <- 'hadl-custom.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeStdlib : HADLc!IncludeFile (
            name <- 'stdlib.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeFields : HADLc!IncludeFile (
            name <- 'hadl-fields.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includePaths : HADLc!IncludeFile (
            name <- 'hadl-paths.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeDebug : HADLc!IncludeFile (
            name <- 'hadl-debug.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeRunner : HADLc!IncludeFile (
            name <- sourceModel.name + 'RunnerHeader.hadl.cpp',
            isStandard <- true,
            appearsInHeader <- false
         )
}

-------------------------------------------------------------------------------
-- Aggregate behaviors without format
-- This is normally an aggregate format with no attribute
-------------------------------------------------------------------------------

rule TAggregateBehavior {
   from behavior : HADL!AggregateBehavior (
         behavior.formats->isEmpty()
      )
   to
      function : HADLc!Function (
            name <- behavior.getDecodeFunctionName(),
            parameters <- Sequence{functionParameterInstr, functionParameterParent, functionParameterPath},
            body <- functionBody,
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstr : HADLc!Parameter (
            name <- '_instr',
            typeName <- thisModule.getInstructionTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterParent : HADLc!Parameter (
            name <- '_parent',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterPath : HADLc!Parameter (
            name <- '_path',
            typeName <- behavior.owningModel.name + '_Paths_en',
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),

      functionBody : HADLc!Block (
            variables <- result,
            statements <-
               Sequence{ functionDummyBlock, assignParent, assignPath }
                  ->union(behavior.chunks)
                  ->including(returnStatement)
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      result : HADLc!Variable (
            name <- 'result',
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            init <- mallocCast
         ),
      mallocCast : HADLc!CastExpression (
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            expression <- mallocCall
         ),
      mallocCall : HADLc!FunctionCall (
            functionName <- 'malloc',
            actualParameters <- sizeof
         ),
      sizeof : HADLc!FunctionCall (
            functionName <- 'sizeof',
            actualParameters <- typeName
         ),
      typeName : HADLc!TypeExpression (
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- false
         ),
   
      assignParent : HADLc!ExpressionStatement (
            expression <- assignParentExpression
         ),
      assignParentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignParentLeft,
            arguments <- assignParentRight
         ),
      assignParentLeft : HADLc!FieldRefExpression (
            expression <- assignParentResult,
            fieldName <- '_parent',
            fromPointer <- true
         ),
      assignParentResult : HADLc!VariableRefExpression (
            variable <- result
         ),
      assignParentRight : HADLc!VariableRefExpression (
            variable <- functionParameterParent
         ),

      assignPath : HADLc!ExpressionStatement (
            expression <- assignPathExpression
         ),
      assignPathExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignPathLeft,
            arguments <- assignPathRight
         ),
      assignPathLeft : HADLc!FieldRefExpression (
            expression <- assignPathResult,
            fieldName <- '_path',
            fromPointer <- true
         ),
      assignPathResult : HADLc!VariableRefExpression (
            variable <- result
         ),
      assignPathRight : HADLc!VariableRefExpression (
            variable <- functionParameterPath
         ),
      returnStatement : HADLc!ReturnStatement (
            expression <- returnExpression
         ),
      returnExpression : HADLc!VariableRefExpression (
            variable <- result
         )

      do {
         thisModule.TPrint('(FMT) Decoding behavior: ' + behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- Behaviors with multiple formats
-------------------------------------------------------------------------------

helper def: decodeFunctionIndex : Integer = 0;

helper context HADL!Format def:
   decodeFunctionName : String = self.getDecodeFunctionName();

rule TBehaviorWithSeveralFormats {
   from behavior : HADL!Behavior (
         behavior.formats->size() > 1
      )
   to
      function : HADLc!Function (
            name <- behavior.getDecodeFunctionName(),
            parameters <- Sequence{functionParameterInstr, functionParameterParent, functionParameterPath},
            body <- functionBody,
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstr : HADLc!Parameter (
            name <- '_instr',
            typeName <- thisModule.getInstructionTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterParent : HADLc!Parameter (
            name <- '_parent',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterPath : HADLc!Parameter (
            name <- '_path',
            typeName <- behavior.owningModel.name + '_Paths_en',
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),

      functionBody : HADLc!Block (
            variables <- result,
            statements <- Sequence{functionDummyBlock, ifStatement, returnStatement}
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      ifStatement : HADLc!IfStatement (
            ifClauses <- behavior.formats->collect(f| f.paths)->flatten()
            -- TODO Else Error
         ),

      result : HADLc!Variable (
            name <- 'result',
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
   
      returnStatement : HADLc!ReturnStatement (
            expression <- returnExpression
         ),
      returnExpression : HADLc!VariableRefExpression (
            variable <- result
         )

      do {
         thisModule.TPrint('(FMT) Decoding behavior: ' + behavior.name, functionDummyBlock);
      }
}

rule TBehaviorChunk {
   from chunk : HADL!BehaviorChunk
   to
      statement : HADLc!ExpressionStatement (
            expression <- assignmentExpression
         ),
      assignmentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignmentLeft,
            arguments <- functionCall
         ),
      assignmentLeft : HADLc!FieldRefExpression (
            expression <- assignmentResult,
            fieldName <- chunk.getFieldName(),
            fromPointer <- true
         ),
      assignmentResult : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      functionCall : HADLc!FunctionCall (
            functionName <- chunk.call.behavior.getDecodeFunctionName(),
            actualParameters <- Sequence{decodeInstr, decodeParent, decodePath}
         ),
      decodeInstr : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      decodeParent : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      decodePath : HADLc!EnumLiteralRefExpression (
            name <- chunk.getPathLiteralName()
         )
}

-------------------------------------------------------------------------------
-- Paths
-- TODO path field condition
-------------------------------------------------------------------------------

rule TPath {
   from path : HADL!Path ( not path.owningFormat.oclIsUndefined() )
   to
      ifClause : HADLc!IfClause (
            condition <- ifClauseCondition,
            thenClause <- thenClause
         ),
      ifClauseCondition : HADLc!FunctionCall (
            functionName <- 'HADL_checkPath<' + thisModule.getInstructionTypeName() + '>',
            actualParameters <-
               Sequence{ argumentInstr, argumentRange, argumentRangeSize, argumentMask, argumentValue, argumentParent, argumentPath, argumentPathSize }
                  ->union(thisModule.reverseSequence(path.elements))
         ),
      argumentInstr : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      argumentRange : HADLc!VariableRefExpression (
            variable <-
               if path.range.oclIsUndefined() then
                  OclUndefined
               else
                  path.range
               endif,
            variableName <-
               if path.range.oclIsUndefined() then
                  'NULL'
               else
                  OclUndefined
               endif
         ),
      argumentRangeSize : HADLc!IntegerLiteralExpression (
            value <-
               if path.range.oclIsUndefined() then
                  0
               else
                  path.range.slices->size()
               endif
         ),
      argumentMask : HADLc!IntegerLiteralExpression (
            value <-
               if path.range.oclIsUndefined() then
                  0
               else
                  path.value.getMask()
               endif
         ),
      argumentValue : HADLc!IntegerLiteralExpression (
            value <-
               if path.range.oclIsUndefined() then
                  0
               else
                  path.value.getValue()
               endif
         ),
      argumentParent : HADLc!VariableRefExpression (
            variableName <- '_parent'
         ),
      argumentPath : HADLc!VariableRefExpression (
            variableName <- '_path'
         ),
      argumentPathSize : HADLc!IntegerLiteralExpression (
            value <- path.elements->size()
         ),

      thenClause : HADLc!ExpressionStatement (
            expression <- assignment
         ),
      assignment : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignmentLeft,
            arguments <- assignmentRight
         ),
      assignmentLeft : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      assignmentRight : HADLc!FunctionCall (
            functionName <- path.owningFormat.decodeFunctionName,
            actualParameters <- Sequence{decodeInstr, decodeParent, decodePath}
         ),
      decodeInstr : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      decodeParent : HADLc!VariableRefExpression (
            variableName <- '_parent'
         ),
      decodePath : HADLc!VariableRefExpression (
            variableName <- '_path'
         )
}

rule TPathElement {
   from element : HADL!PathElement
   to
      expression : HADLc!EnumLiteralRefExpression (
            name <- element.getChunkOrChoice().getPathLiteralName()
         )
}

-------------------------------------------------------------------------------
-- Aggregate formats
-------------------------------------------------------------------------------
-- For each aggregate format, we generate
--
--    - a function definition
-------------------------------------------------------------------------------

rule TAggregateFormat {
   from format : HADL!AggregateFormat
   to
      function : HADLc!Function (
            name <- format.decodeFunctionName,
            parameters <- Sequence{functionParameterInstr, functionParameterParent, functionParameterPath},
            body <- functionBody,
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstr : HADLc!Parameter (
            name <- '_instr',
            typeName <- thisModule.getInstructionTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterParent : HADLc!Parameter (
            name <- '_parent',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterPath : HADLc!Parameter (
            name <- '_path',
            typeName <- format.owningModel.name + '_Paths_en',
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),

      functionBody : HADLc!Block (
            variables <- result,
            statements <-
               Sequence{ functionDummyBlock, assignParent, assignPath }
                  ->union(format.attributeFormats)
                  ->union(format.behavior.chunks)
                  ->append(returnStatement)
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      result : HADLc!Variable (
            name <- 'result',
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            init <- mallocCast
         ),
      mallocCast : HADLc!CastExpression (
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            expression <- mallocCall
         ),
      mallocCall : HADLc!FunctionCall (
            functionName <- 'malloc',
            actualParameters <- sizeof
         ),
      sizeof : HADLc!FunctionCall (
            functionName <- 'sizeof',
            actualParameters <- typeName
         ),
      typeName : HADLc!TypeExpression (
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- false
         ),
   
      assignParent : HADLc!ExpressionStatement (
            expression <- assignParentExpression
         ),
      assignParentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignParentLeft,
            arguments <- assignParentRight
         ),
      assignParentLeft : HADLc!FieldRefExpression (
            expression <- assignParentResult,
            fieldName <- '_parent',
            fromPointer <- true
         ),
      assignParentResult : HADLc!VariableRefExpression (
            variable <- result
         ),
      assignParentRight : HADLc!VariableRefExpression (
            variable <- functionParameterParent
         ),

      assignPath : HADLc!ExpressionStatement (
            expression <- assignPathExpression
         ),
      assignPathExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignPathLeft,
            arguments <- assignPathRight
         ),
      assignPathLeft : HADLc!FieldRefExpression (
            expression <- assignPathResult,
            fieldName <- '_path',
            fromPointer <- true
         ),
      assignPathResult : HADLc!VariableRefExpression (
            variable <- result
         ),
      assignPathRight : HADLc!VariableRefExpression (
            variable <- functionParameterPath
         ),

      returnStatement : HADLc!ReturnStatement (
            expression <- returnExpression
         ),
      returnExpression : HADLc!VariableRefExpression (
            variable <- result
         )

      do {
         thisModule.TPrint('(FMT) Decoding behavior: ' + format.behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- Attribute formats with field specifications
-------------------------------------------------------------------------------
-- For each field attribute format, we generate an expression that computes
-- the value of the field.
-------------------------------------------------------------------------------

rule TFieldAttributeFormat {
   from fmt : HADL!FieldAttributeFormat
   to
      block : HADLc!Block (
            statements <- assignmentStatement
         ),
      assignmentStatement : HADLc!ExpressionStatement (
            expression <- assignmentExpression
         ),
      assignmentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignmentLeft,
            arguments <- thisModule.TRangeInExpression(fmt.range)
         ),
      assignmentLeft : HADLc!FieldRefExpression (
            expression <- assignmentResult,
            fieldName <- fmt.attribute.name,
            fromPointer <- true
         ),
      assignmentResult : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
         
      getFieldData : HADLc!VariableRefExpression (
            variableName <- '_instr'
         )
}

-------------------------------------------------------------------------------
-- Literal attribute formats
-------------------------------------------------------------------------------
-- For each literal attribute format, we generate a simple assignment.
-------------------------------------------------------------------------------

rule TLiteralAttributeFormat {
   from fmt : HADL!LiteralAttributeFormat
   to
      assignmentStatement : HADLc!ExpressionStatement (
            expression <- assignmentExpression
         ),
      assignmentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignmentLeft,
            arguments <- literal
         ),
      assignmentLeft : HADLc!FieldRefExpression (
            expression <- assignmentResult,
            fieldName <- fmt.attribute.name,
            fromPointer <- true
         ),
      assignmentResult : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      literal : HADLc!IntegerLiteralExpression (
            value <- fmt.value
         )
}

-------------------------------------------------------------------------------
-- Alternative formats
-------------------------------------------------------------------------------
-- For each alternative format, we generate
--
--    - a function definition
--
-- The function definition includes an 'if' statement that manages the
-- different choices.
-------------------------------------------------------------------------------

rule TAlternativeFormat {
   from format : HADL!AlternativeFormat
   to
      function : HADLc!Function (
            name <- format.decodeFunctionName,
            parameters <- Sequence{ functionParameterInstr, functionParameterParent, functionParameterPath},
            body <- functionBody,
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstr : HADLc!Parameter (
            name <- '_instr',
            typeName <- thisModule.getInstructionTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterParent : HADLc!Parameter (
            name <- '_parent',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterPath : HADLc!Parameter (
            name <- '_path',
            typeName <- format.owningModel.name + '_Paths_en',
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),

      functionBody : HADLc!Block (
            variables <- Sequence{field, result},
            statements <-
               Sequence{ functionDummyBlock, assignParent, assignPath }
                  ->union(format.attributeFormats)
                  ->union(Sequence{ifStatement, returnStatement})
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),
         
      field : HADLc!Variable (
            name <- '_field',
            typeName <- thisModule.getInstructionTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- thisModule.TRangeInExpression(format.range)
         ),
      getFieldData : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
         
      result : HADLc!Variable (
            name <- 'result',
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            init <- mallocCast
         ),
      mallocCast : HADLc!CastExpression (
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            expression <- mallocCall
         ),
      mallocCall : HADLc!FunctionCall (
            functionName <- 'malloc',
            actualParameters <- sizeof
         ),
      sizeof : HADLc!FunctionCall (
            functionName <- 'sizeof',
            actualParameters <- typeName
         ),
      typeName : HADLc!TypeExpression (
            typeName <- format.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- false
         ),

      assignParent : HADLc!ExpressionStatement (
            expression <- assignParentExpression
         ),
      assignParentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignParentLeft,
            arguments <- assignParentRight
         ),
      assignParentLeft : HADLc!FieldRefExpression (
            expression <- assignParentResult,
            fieldName <- '_parent',
            fromPointer <- true
         ),
      assignParentResult : HADLc!VariableRefExpression (
            variable <- result
         ),
      assignParentRight : HADLc!VariableRefExpression (
            variable <- functionParameterParent
         ),

      assignPath : HADLc!ExpressionStatement (
            expression <- assignPathExpression
         ),
      assignPathExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignPathLeft,
            arguments <- assignPathRight
         ),
      assignPathLeft : HADLc!FieldRefExpression (
            expression <- assignPathResult,
            fieldName <- '_path',
            fromPointer <- true
         ),
      assignPathResult : HADLc!VariableRefExpression (
            variable <- result
         ),
      assignPathRight : HADLc!VariableRefExpression (
            variable <- functionParameterPath
         ),

      ifStatement : HADLc!IfStatement (
            ifClauses <- format.choices->collect(c| thisModule.TFormatChoice(c))
            -- TODO Else Error
         ),

      returnStatement : HADLc!ReturnStatement (
            expression <- returnExpression
         ),
      returnExpression : HADLc!VariableRefExpression (
            variable <- result
         )

      do {
         thisModule.TPrint('(FMT) Decoding behavior: ' + format.behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- Format choices - common rules
-------------------------------------------------------------------------------
-- For each format choice, we generate an if clause that compares the current
-- instruction field with the choice value.
--
-- TODO support multiple values in a choice
-------------------------------------------------------------------------------

unique lazy rule TFormatChoice {
   from choice : HADL!FormatChoice
   to
      ifClause : HADLc!IfClause (
            condition <- ifClauseCondition,
            thenClause <- thisModule.resolveTemp(choice, 'thenClause')
         ),
      ifClauseCondition : HADLc!OperatorExpression (
            operator <- '==',
            source <- maskExpression,
            arguments <- choiceValue
         ),
      maskExpression : HADLc!OperatorExpression (
            operator <- '&',
            source <- field,
            arguments <- maskValue
         ),
      field : HADLc!VariableRefExpression (
            variableName <- '_field'
         ),
      maskValue : HADLc!IntegerLiteralExpression (
            value <- choice.literals->at(1).getMask() -- TODO support multiple values in a choice
         ),
      choiceValue : HADLc!IntegerLiteralExpression (
            value <- choice.literals->at(1).getValue() -- TODO support multiple values in a choice
         )
}

-------------------------------------------------------------------------------
-- Terminal format choices
-------------------------------------------------------------------------------
-- For each terminal alternative choice, we generate an if clause with an
-- assignment.
-------------------------------------------------------------------------------

rule TLeafFormatChoice {
   from choice : HADL!LeafFormatChoice
   to
      thenClause : HADLc!Block (
            statements <- assignmentStatement
         ),
         
      assignmentStatement : HADLc!ExpressionStatement (
            expression <- assignmentExpression
         ),
      assignmentExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- target,
            arguments <- enumerationLiteral
         ),
      target : HADLc!FieldRefExpression (
            expression <- resultVariableRef,
            fieldName <- '_choice',
            fromPointer <- true
         ),
      resultVariableRef : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      enumerationLiteral : HADLc!EnumLiteralRefExpression (
            name <- choice.behaviorChoice.getLiteralName()
         )

      do {
         thisModule.TPrint('(FMT) ... Matching #' + choice.behaviorChoice.name, thenClause);
      }
}

-------------------------------------------------------------------------------
-- Call format choices
-------------------------------------------------------------------------------
-- For each format choice with a call to another format, we generate an if
-- clause with two assignments.
-------------------------------------------------------------------------------

rule TCallFormatChoice {
   from choice : HADL!CallFormatChoice
   to
      thenClause : HADLc!Block (
            statements <- Sequence{assignChoice, assignTarget}
         ),

      assignChoice : HADLc!ExpressionStatement (
            expression <- assignChoiceExpression
         ),
      assignChoiceExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignChoiceLeft,
            arguments <- assignChoiceRight
         ),
      assignChoiceLeft : HADLc!FieldRefExpression (
            expression <- assignChoiceResult,
            fieldName <- '_choice',
            fromPointer <- true
         ),
      assignChoiceResult : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      assignChoiceRight : HADLc!EnumLiteralRefExpression (
            name <- choice.owningFormat.behavior.choices
                     ->select(c| c.oclIsKindOf(HADL!CallBehaviorChoice))
                     ->select(c| c.call.behavior = choice.behavior)
                     ->asSequence()->first()
                     .getLiteralName()
         ),
         
      assignTarget : HADLc!ExpressionStatement (
            expression <- assignTargetExpression
         ),
      assignTargetExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- assignTargetLeft,
            arguments <- assignTargetRight
         ),
      assignTargetLeft : HADLc!FieldRefExpression (
            expression <- assignTargetResult,
            fieldName <- '_target',
            fromPointer <- true
         ),
      assignTargetResult : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      assignTargetRight : HADLc!FunctionCall (
            functionName <- choice.behavior.getDecodeFunctionName(),
            actualParameters <- Sequence{decodeInstr, decodeParent, decodePath}
         ),
      decodeInstr : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      decodeParent : HADLc!VariableRefExpression (
            variableName <- 'result'
         ),
      decodePath : HADLc!EnumLiteralRefExpression (
            name <- choice.getPathLiteralName()
         )

      do {
         thisModule.TPrint('(FMT) ... Matching behavior ' + choice.behavior.name, thenClause);
      }
}

unique lazy rule TRangeInExpression {
   from range : HADL!Range
   to
      getField : HADLc!FunctionCall (
            functionName <- range.getFunctionNameFieldGetValue(),
            actualParameters <-
               Sequence{
                  thisModule.resolveTemp(
                     if not range.owningFormat.oclIsUndefined() then
                        range.owningFormat
                     else
                        range.owningFieldAttributeFormat
                     endif
                     , 'getFieldData'
                  ),
                  getFieldRange, getFieldSize, getFieldShift, getFieldRight, getFieldRotate, getFieldArithmetic
               }
         ),
      getFieldRange : HADLc!VariableRefExpression (
            variable <- range
         ),
      getFieldSize : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      getFieldShift : HADLc!IntegerLiteralExpression (
            value <- range.shiftAmount
         ),
      getFieldRight : HADLc!IntegerLiteralExpression (
            value <- if range.right then 1 else 0 endif
         ),
      getFieldRotate : HADLc!IntegerLiteralExpression (
            value <- if range.shift then 0 else 1 endif
         ),
      getFieldArithmetic : HADLc!IntegerLiteralExpression (
            value <- if range.arithmetic then 1 else 0 endif
         )
}

-------------------------------------------------------------------------------
-- Global variables and rules common to several modules
-------------------------------------------------------------------------------

rule TPrint (message : String, block : HADLc!Block) {
   to
      printStatement : HADLc!ExpressionStatement (
            expression <- printCall,
            owningBlock <- block
         ),
      printCall : HADLc!FunctionCall (
            functionName <- 'HADL_Debug_printMessage',
            actualParameters <- printArgument
         ),
      printArgument : HADLc!StringLiteralExpression (
            value <- message
         )
}

helper def: rangeIndex : Integer = 0;

rule TRange {
   from range : HADL!Range
   to
      variable : HADLc!Variable (
            name <- thisModule.newRangeVariableName(),
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            size <- Sequence{sizeHeight, sizeWidth},
            init <- array
         ),
      sizeHeight : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      sizeWidth : HADLc!IntegerLiteralExpression (
            value <- 3
         ),
      array : HADLc!ArrayExpression (
            elements <- range.slices
         )
}
      
rule TSliceWithFirstLastAndStep {
   from slice : HADL!Slice (
         not slice.last.oclIsUndefined() and
         not slice.step.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  slice.last,
                  slice.step
               }
         )
}

rule TSliceWithFirstAndLast {
   from slice : HADL!Slice (
         not slice.last.oclIsUndefined() and
         slice.step.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  slice.last,
                  step
               }
         ),
      step : HADLc!IntegerLiteralExpression (
            value <- 1
         )
}

rule TSliceWithFirstOnly {
   from slice : HADL!Slice (
         slice.last.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  last,
                  step
               }
         ),
      last : HADLc!CopyExpression (
            copiedExpression <- slice.first
         ),
      step : HADLc!IntegerLiteralExpression (
            value <- 1
         )
}

rule TIntegerLiteralExpression {
   from sourceLiteral : HADL!IntegerLiteralExpression
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- sourceLiteral.value
         )
}

