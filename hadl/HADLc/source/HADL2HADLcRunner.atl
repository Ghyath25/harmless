
module HADL2HADLcRunner;
create OUT:HADLc from IN:HADL;

uses HADL2HADLcHelpers;

rule TModel {
   from sourceModel : HADL!Model
   to
      targetModel : HADLc!Model (
            name <- sourceModel.name + 'Runner',
            includedFiles <- Sequence{includeStdlib, includeTypes, includeCustom, includeFields, includeArray, includeDebug, includeScheduler, includeDisassembler, includeDecoder},
            elements <-
               ---------- Component variables
               sourceModel.elements
                  ->select(e| e.oclIsKindOf(HADL!Component))
                  ->collect(e| e.variables)
                  ->flatten()
               
               ---------- Enumeration type for behavior paths
               ->append(
                  enumTypePaths
               )

               ---------- Enumeration types for alternative behaviors
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!AlternativeBehavior))->collect(f| thisModule.resolveTemp(f, 'enumType'))
               )
               
               ---------- Enumeration types for architectures
               ->append(
                  enumTypeResources
               )

               ---------- Enumeration type for components
               ->append(
                  enumTypeComponents
               )
               
               ---------- Enumeration type for pipelines
               ->append(
                  enumTypePipelines
               )
               
               ---------- Enumeration types for component operations
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Component))->collect(f| thisModule.resolveTemp(f, 'enumType'))
               )
               
               ---------- Enumeration types for pipeline stages
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Pipeline))->collect(f| thisModule.resolveTemp(f, 'enumType'))
               )
               
               ---------- Struct types for behaviors
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Behavior))->collect(f| thisModule.resolveTemp(f, 'structType'))
               )
               
               ---------- Function definitions for operations
               ->union(
                  sourceModel.getAllOperations()->collect(f| thisModule.resolveTemp(f, 'function'))
               )
               
               ---------- Function definitions for pipeline step
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Pipeline))->collect(f| thisModule.resolveTemp(f, 'stepFunction'))
               )
               
               ---------- Function definitions for behaviors
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Behavior))->collect(f| thisModule.resolveTemp(f, 'function'))
               )
               
               ---------- Creation function for global variables
               ->append(
                  createFunction
               )
               
               ---------- Pipeline representations
               ->union(
                  HADL!Port.allInstances()->collect(f| thisModule.resolveTemp(f, 'operationsVariable'))
               )
               ->union(
                  HADL!Port.allInstances()->collect(f| thisModule.resolveTemp(f, 'portVariable'))
               )
               ->union(
                  HADL!Stage.allInstances()->collect(f| thisModule.resolveTemp(f, 'stageSuccessorsVariable'))
               )
               ->union(
                  HADL!Stage.allInstances()->collect(f| thisModule.resolveTemp(f, 'stagePortsVariable'))
               )
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Pipeline))->collect(f| thisModule.resolveTemp(f, 'stagesVariable'))
               )
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Pipeline))->collect(f| thisModule.resolveTemp(f, 'pipelineVariable'))
               )

               ---------- Function definitions for pipeline init
               ->union(
                  sourceModel.elements->select(e| e.oclIsKindOf(HADL!Pipeline))->collect(f| thisModule.resolveTemp(f, 'initFunction'))
               )
               
         ),
      
      -- Initialization function for all global variables
      createFunction : HADLc!Function (
            name <- sourceModel.getCreateFunctionName(),
            typeName <- 'void',
            isEnum <- false,
            isStruct <- false,
            isPointer <- false,
            body <- createFunctionBody
         ),
      createFunctionBody : HADLc!Block (
            statements <-
               sourceModel.elements
                  ->select(e| e.oclIsKindOf(HADL!Component))
                  ->collect(e| e.variables)
                  ->flatten()
                  ->collect(e| thisModule.resolveTemp(e, 'createStatement'))
         ),

      -- #include directives
      includeTypes : HADLc!IncludeFile (
            name <- 'hadl-types.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeCustom : HADLc!IncludeFile (
            name <- 'hadl-custom.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeStdlib : HADLc!IncludeFile (
            name <- 'stdlib.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeFields : HADLc!IncludeFile (
            name <- 'hadl-fields.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeArray : HADLc!IncludeFile (
            name <- 'hadl-array.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeScheduler : HADLc!IncludeFile (
            name <- 'hadl-scheduler.h',
            isStandard <- false,
            appearsInHeader <- true
         ),
      includeDebug : HADLc!IncludeFile (
            name <- 'hadl-debug.h',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeDecoder : HADLc!IncludeFile (
            name <- sourceModel.name + 'DecoderHeader.hadl.cpp',
            isStandard <- false,
            appearsInHeader <- false
         ),
      includeDisassembler : HADLc!IncludeFile (
            name <- sourceModel.name + 'DisassemblerHeader.hadl.cpp',
            isStandard <- false,
            appearsInHeader <- false
         ),

      -- Enumeration type for pipelines
      enumTypePipelines : HADLc!EnumType (
            name <- sourceModel.name + '_Pipelines_en',
            literals <- sourceModel.elements
                           ->select(e| e.oclIsKindOf(HADL!Pipeline))
                           ->collect(e| thisModule.resolveTemp(e, 'literal'))
         ),

      -- Enumeration type for ports
      -- TODO one enum per architecture
      enumTypeResources : HADLc!EnumType (
            name <- sourceModel.name + '_Ports_en',
            literals <- HADL!Port.allInstances()->collect(p| thisModule.TPortLiteral(p))
         ),
         
      -- Enumeration type for components
      enumTypeComponents : HADLc!EnumType (
            name <- sourceModel.name + '_Components_en',
            literals <- sourceModel.elements
                           ->select(e| e.oclIsKindOf(HADL!Component))
                           ->collect(e| thisModule.resolveTemp(e, 'literal'))
         ),

      -- Enumeration type for behavior paths
      enumTypePaths : HADLc!EnumType (
            name <- sourceModel.name + '_Paths_en',
            literals <-
               Sequence{ enumLiteralRootPath }
                  ->union(
                        sourceModel.elements
                           ->select(e| e.oclIsKindOf(HADL!Behavior))
                           ->collect(e|
                                 if e.oclIsKindOf(HADL!AggregateBehavior) then
                                    e.chunks->collect(c|thisModule.TBehaviorChunkLiteral(c))
                                 else
                                    e.choices
                                       ->select(c| c.oclIsKindOf(HADL!CallBehaviorChoice))
                                       ->collect(c|thisModule.resolveTemp(c, 'pathLiteral'))
                                 endif
                              )
                           ->flatten()
                     )
         ),
      enumLiteralRootPath : HADLc!EnumLiteral (
            name <- sourceModel.name + '_Root_path'
         )
}

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.1. Aggregate behaviors
-------------------------------------------------------------------------------
-- For each aggregate behavior, we generate
--
--    - a struct type (structType)
--    - a function definition (function)
--
-- The ordering of chunks is preserved in the generated function.
-------------------------------------------------------------------------------

rule TAggregateBehavior {
   from behavior : HADL!AggregateBehavior
   to
      structType : HADLc!StructType (
            name <- behavior.getStructTypeName(),
            fields <-
               Sequence{ fieldPath, fieldParent }
                  ->union(behavior.attributes)
                  ->union(
                        behavior.chunks->collect(c| thisModule.TBehaviorChunkField(c))
                     )
         ),

      fieldPath : HADLc!StructField (
            name <- '_path',
            typeName <- behavior.owningModel.name + '_Paths_en',
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),
      fieldParent : HADLc!StructField (
            name <- '_parent',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),

      function : HADLc!Function (
            name <- behavior.getRunFunctionName(),
            parameters <- Sequence{
                              functionParameterPipelineData,
                              functionParameterTime,
                              functionParameterStartTime,
                              functionParameterStage,
                              functionParameterInstruction,
                              functionParameterThis
                           }->union(behavior.parameters->collect(p| thisModule.resolveTemp(p, 'functionParameter'))),
            body <- functionBody,
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterPipelineData : HADLc!Parameter (
            name <- '_pipeData',
            typeName <- 'HADL_PipelineData_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterTime : HADLc!Parameter (
            name <- '_time',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterStartTime : HADLc!Parameter (
            name <- '_startTime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterStage : HADLc!Parameter (
            name <- '_stage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstruction : HADLc!Parameter (
            name <- '_instr',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterThis : HADLc!Parameter (
            name <- '_this',
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
      functionBody : HADLc!Block (
            variables <- behavior.localVariables,
            statements <-
               if behavior.beforeBlock.oclIsUndefined() then
                  Sequence{functionDummyBlock}
               else
                  Sequence{functionDummyBlock, behavior.beforeBlock}
               endif
               ->union(
                  behavior.chunks->select(c| not c.call.oclIsUndefined())->collect(c| thisModule.resolveTemp(c, 'statement'))
               )
               ->union(
                  if behavior.afterBlock.oclIsUndefined() then
                     Sequence{}
                  else
                     Sequence{behavior.afterBlock}
                  endif
               )
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         )

      do {
         thisModule.TPrint('(FRG) Running behavior: ' + behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.3. Aggregate behavior chunks - rules
-------------------------------------------------------------------------------
-- For each behavior chunk, we generate a struct field and a function call
-- statement.
-- If the call is conditional, the generated function call is enclosed
-- by an if statement.
-------------------------------------------------------------------------------

unique lazy rule TBehaviorChunkField {
   from chunk : HADL!BehaviorChunk
   to
      field : HADLc!StructField (
            name <- chunk.getFieldName(),
            typeName <- chunk.call.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         )
}

unique lazy rule TBehaviorChunkLiteral {
   from chunk : HADL!BehaviorChunk
   to
      literal : HADLc!EnumLiteral (
            name <- chunk.getPathLiteralName()
         )
}

rule TBehaviorChunkWithoutCondition {
   from chunk : HADL!BehaviorChunk (
         chunk.condition.oclIsUndefined()
      )
   to
      statement : HADLc!ExpressionStatement (
            expression <- chunk.call
         )
}

rule TBehaviorChunkWithCondition {
  from chunk : HADL!BehaviorChunk (
         not chunk.condition.oclIsUndefined()
      )
  to
      statement : HADLc!IfStatement (
            ifClauses <- ifClause
         ),
      ifClause : HADLc!IfClause (
            condition <- chunk.condition,
            thenClause <- callStatement
         ),
      callStatement : HADLc!ExpressionStatement (
            expression <- chunk.call
         )
}

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.4. Alternative behavior transformation
-------------------------------------------------------------------------------
-- For each alternative behavior, we generate
--
--    - a struct type (structType) with two fields (choice, target)
--    - an enumeration type (enum)
--    - a function definition (function)
--
-- The function body contains a switch statement.
-------------------------------------------------------------------------------

rule TAlternativeBehavior {
   from behavior : HADL!AlternativeBehavior
   to
      structType : HADLc!StructType (
            name <- behavior.getStructTypeName(),
            fields <-
               Sequence{ fieldPath, fieldParent }
                  ->union(behavior.attributes)
                  ->union(
                        Sequence{ fieldChoice, fieldTarget }
                     )
         ),
      fieldChoice : HADLc!StructField (
            name <- '_choice',
            typeName <- behavior.getEnumerationTypeName(),
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),
      fieldTarget : HADLc!StructField (
            name <- '_target',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      fieldPath : HADLc!StructField (
            name <- '_path',
            typeName <- behavior.owningModel.name + '_Paths_en',
            isStruct <- false,
            isEnum <- true,
            isPointer <- false
         ),
      fieldParent : HADLc!StructField (
            name <- '_parent',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),

      enumType : HADLc!EnumType (
            name <- behavior.getEnumerationTypeName(),
            literals <- behavior.choices
         ),

      function : HADLc!Function (
            name <- behavior.getRunFunctionName(),
            parameters <- Sequence{
                              functionParameterPipelineData,
                              functionParameterTime,
                              functionParameterStartTime,
                              functionParameterStage,
                              functionParameterInstruction,
                              functionParameterThis
                           }->union(behavior.parameters->collect(p| thisModule.resolveTemp(p, 'functionParameter'))),
            body <- functionBody,
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterPipelineData : HADLc!Parameter (
            name <- '_pipeData',
            typeName <- 'HADL_PipelineData_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterTime : HADLc!Parameter (
            name <- '_time',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterStartTime : HADLc!Parameter (
            name <- '_startTime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterStage : HADLc!Parameter (
            name <- '_stage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstruction : HADLc!Parameter (
            name <- '_instr',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterThis : HADLc!Parameter (
            name <- '_this',
            typeName <- behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true
         ),
      functionBody : HADLc!Block (
            variables <- behavior.localVariables,
            statements <-
               if behavior.beforeBlock.oclIsUndefined() then
                  Sequence{functionDummyBlock, switchStatement}
               else
                  Sequence{functionDummyBlock, behavior.beforeBlock, switchStatement}
               endif
               ->union(
                  if behavior.afterBlock.oclIsUndefined() then
                     Sequence{}
                  else
                     Sequence{behavior.afterBlock}
                  endif
               )
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      switchStatement : HADLc!SwitchStatement (
            expression <- switchExpression,
            cases <- behavior.choices->collect(c| thisModule.resolveTemp(c, 'case'))
         ),
      switchExpression : HADLc!FieldRefExpression (
            expression <- switchExpressionVariable,
            fieldName <- '_choice',
            fromPointer <- true
         ),
      switchExpressionVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )

      do {
         thisModule.TPrint('(FRG) Running behavior: ' + behavior.name, functionDummyBlock);
      }
}

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.5. Behavior choices
-------------------------------------------------------------------------------
-- For each behavior choice, we generate
--
--    - an enumeration literal (literal)
--    - a case in a switch statement (case)
--
-- If the choice is leaf, the case body is derived from the choice body.
-------------------------------------------------------------------------------

rule TLeafBehaviorChoice {
   from choice : HADL!LeafBehaviorChoice
   to
      literal : HADLc!EnumLiteral (
            name <- choice.getLiteralName()
         ),

      case : HADLc!Case (
            value <- caseValue,
            statements <- choice.body
         ),
      caseValue : HADLc!EnumLiteralRefExpression (
            name <- choice.getLiteralName()
         )
}

rule TCallBehaviorChoice {
  from choice : HADL!CallBehaviorChoice
  to
      literal : HADLc!EnumLiteral (
            name <- choice.getLiteralName()
         ),

      pathLiteral : HADLc!EnumLiteral (
            name <- choice.getPathLiteralName()
         ),

      case : HADLc!Case (
            value <- caseValue,
            statements <- caseBody
         ),
      caseValue : HADLc!EnumLiteralRefExpression (
            name <- choice.getLiteralName()
         ),
      caseBody : HADLc!ExpressionStatement (
            expression <- choice.call
         )
}

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.6. Behavior calls
-------------------------------------------------------------------------------
-- A behavior call is mapped to a call to the corresponding 'run' function.
-------------------------------------------------------------------------------

rule TBehaviorCall {
   from sourceCall : HADL!BehaviorCall
   to
      targetCall : HADLc!FunctionCall (
            functionName <- sourceCall.behavior.getRunFunctionName(),
            actualParameters <- Sequence{
                                    targetCallArgumentPipelineData,
                                    targetCallArgumentTime,
                                    targetCallArgumentStartTime,
                                    targetCallArgumentStage,
                                    targetCallArgumentInstruction,
                                    targetCallArgumentCast
                                 }->union(sourceCall.actualParameters)
         ),
      targetCallArgumentPipelineData : HADLc!VariableRefExpression (
            variableName <- '_pipeData'
         ),
      targetCallArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         ),
      targetCallArgumentStartTime : HADLc!VariableRefExpression (
            variableName <- '_startTime'
         ),
      targetCallArgumentStage : HADLc!VariableRefExpression (
            variableName <- '_stage'
         ),
      targetCallArgumentInstruction : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      targetCallArgumentCast : HADLc!CastExpression (
            typeName <- sourceCall.behavior.getStructTypeName(),
            isStruct <- true,
            isEnum <- false,
            isPointer <- true,
            expression <- targetCallArgumentTarget
         ),
      targetCallArgumentTarget : HADLc!FieldRefExpression (
            expression <- targetCallArgumentThis,
            fieldName <-
               if not sourceCall.owningChoice.oclIsUndefined() then
                  '_target'
               else
                  sourceCall.owningChunk.getFieldName()
               endif,
            fromPointer <- true
         ),
      targetCallArgumentThis : HADLc!VariableRefExpression (
            variableName <- '_this'
         )
}

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.7. Attributes
-------------------------------------------------------------------------------

rule TAttribute {
   from attr : HADL!Attribute
   to
      field : HADLc!StructField (
            name <- attr.name,
            typeName <- thisModule.getDefaultDataTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         )
}

-------------------------------------------------------------------------------
-- 3. Operations
--    3.2. Operation transformation
-------------------------------------------------------------------------------
-- For each operation we generate
--
--    - a function definition (function)
-------------------------------------------------------------------------------

rule TOperation {
   from operation : HADL!Operation
   to
      function : HADLc!Function (
            name <- operation.getFunctionName(),
            typeName <- operation.getReturnTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            parameters <- Sequence{
                              functionParameterPipelineData,
                              functionParameterTime,
                              functionParameterStartTime,
                              functionParameterStage,
                              functionParameterInstruction,
                              functionParameterInline
                           }->union(
                              operation.parameters->collect(p| thisModule.resolveTemp(p, 'functionParameter'))
                           ),
            body <- functionBody
         ),
      functionParameterPipelineData : HADLc!Parameter (
            name <- '_pipeData',
            typeName <- 'HADL_PipelineData_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterTime : HADLc!Parameter (
            name <- '_time',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterStartTime : HADLc!Parameter (
            name <- '_startTime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionParameterStage : HADLc!Parameter (
            name <- '_stage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInstruction : HADLc!Parameter (
            name <- '_instr',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      functionParameterInline : HADLc!Parameter (
            name <- '_inline',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
      functionBody : HADLc!Block (
            variables <- operation.localVariables,
            statements <-
               Sequence{functionDummyBlock, ifStatement}
               ->append(operation.body)
         ),
      functionDummyBlock : HADLc!Block (
            -- See imperative block below
         ),

      ifStatement : HADLc!IfStatement (
            ifClauses <- ifClause
         ),
      ifClause : HADLc!IfClause (
            condition <- ifCondition,
            thenClause <- thisModule.TOperationSchedule(operation)
         ),
      ifCondition : HADLc!VariableRefExpression (
            variable <- functionParameterInline
         )

      do {
         thisModule.TPrint('(OPR) Executing operation: ' + operation.owningComponent.name + '.' + operation.name, functionDummyBlock);
      }
}

unique lazy rule TOperationSchedule {
   from operation : HADL!Operation
   to
      scheduleStatement : HADLc!ExpressionStatement (
            expression <- scheduleCall
         ),
      scheduleCall : HADLc!FunctionCall (
            functionName <- 'HADL_Scheduler_schedule',
            actualParameters <- Sequence{
                                    scheduleCallArgumentPipelineData,
                                    scheduleCallArgumentTime,
                                    scheduleCallArgumentStartTime,
                                    scheduleCallArgumentStage,
                                    scheduleCallArgumentInstruction,
                                    scheduleCallArgumentComponent,
                                    scheduleCallArgumentOperation
                                 }
         ),
      scheduleCallArgumentPipelineData : HADLc!VariableRefExpression (
            variableName <- '_pipeData'
         ),
      scheduleCallArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         ),
      scheduleCallArgumentStartTime : HADLc!VariableRefExpression (
            variableName <- '_startTime'
         ),
      scheduleCallArgumentStage : HADLc!VariableRefExpression (
            variableName <- '_stage'
         ),
      scheduleCallArgumentInstruction : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      scheduleCallArgumentComponent : HADLc!EnumLiteralRefExpression (
            name <- operation.owningComponent.getLiteralName()
         ),
      scheduleCallArgumentOperation : HADLc!EnumLiteralRefExpression (
            name <- operation.getLiteralName()
         )
}
   
-------------------------------------------------------------------------------
-- 7. Variables
--    7.2. Parameters
-------------------------------------------------------------------------------
-- A behavior parameter is mapped onto a C function parameter.
-------------------------------------------------------------------------------

rule TParameter {
   from sourceParameter : HADL!Parameter
   to
      functionParameter : HADLc!Parameter (
            name <- sourceParameter.name,
            typeName <- sourceParameter.getTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- sourceParameter.isOutput or sourceParameter.isArray()
         )
}

-------------------------------------------------------------------------------
-- 7. Variables
--    7.3. Local behavior or operation variables
-------------------------------------------------------------------------------
-- For each local variable in a behavior, we generate a local variable in a
-- function. If the source variable is an array, an init expression is
-- generated with a call to the array allocator function.
-------------------------------------------------------------------------------

rule TLocalVariable {
   from sourceVariable : HADL!LocalVariable
   to
      targetVariable : HADLc!Variable (
            name <- sourceVariable.name,
            typeName <- sourceVariable.getTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- sourceVariable.isArray(),
            init <-
               if sourceVariable.isArray() then
                  thisModule.TArrayLocalVariable(sourceVariable)
               else
                  OclUndefined
               endif
         ) 
}

unique lazy rule TArrayLocalVariable {
   from sourceVariable : HADL!LocalVariable (
         sourceVariable.isArray()
      )
   to
      allocatorCall : HADLc!FunctionCall (
            functionName <- sourceVariable.getFunctionNameArrayNew(),
            owningVariable <- sourceVariable
         )
}

-------------------------------------------------------------------------------
-- 7. Variables
--    7.4. Component variables
-------------------------------------------------------------------------------
-- For each global variable in a model,
-- we generate a global variable in a module
-------------------------------------------------------------------------------

rule TComponentVariable {
   from sourceVariable : HADL!ComponentVariable
   to
      targetVariable : HADLc!Variable (
            name <- sourceVariable.getVariableName(),
            typeName <- sourceVariable.getTypeName(),
            isStruct <- false,
            isEnum <- false,
            isPointer <- sourceVariable.isArray()
         ),

      createStatement : HADLc!ExpressionStatement (
            expression <- createExpression
         ),
      createExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- createLeft,
            arguments <-
               if sourceVariable.isArray() then
                  thisModule.TArrayComponentVariable(sourceVariable)
               else
                  thisModule.TScalarComponentVariable(sourceVariable)
               endif
         ),
      createLeft : HADLc!VariableRefExpression (
            variable <- sourceVariable
         )
}

unique lazy rule TScalarComponentVariable {
   from sourceVariable : HADL!ComponentVariable (
         not sourceVariable.isArray()
      )
   to
      createStatementValue : HADLc!VariableRefExpression (
            variableName <- 'HADL_UNDEFINED'
         )
}

unique lazy rule TArrayComponentVariable {
   from sourceVariable : HADL!ComponentVariable (
         sourceVariable.isArray()
      )
   to
      createStatementCall : HADLc!FunctionCall (
            functionName <- sourceVariable.getFunctionNameArrayNew()
         )
}

-------------------------------------------------------------------------------
-- 7. Variables
--    7.5. Loop variables
-------------------------------------------------------------------------------
-- For each loop counter, we generate a variable in the block that owns
-- the loop.
-------------------------------------------------------------------------------

rule TLoopVariable {
   from sourceVariable : HADL!LoopVariable
   to
      targetVariable : HADLc!Variable (
            name <- sourceVariable.name,
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            owningBlock <- sourceVariable.owningForStatement.owningBlock
         )
}

-------------------------------------------------------------------------------
-- 8. Imperative statements
--    8.1. Blocks
-------------------------------------------------------------------------------

rule TBlock {
   from sourceBlock : HADL!Block
   to
      targetBlock : HADLc!Block (
            statements <- sourceBlock.statements,
            variables <-
               if sourceBlock.statements->exists(s| s.oclIsKindOf(HADL!ForStatement)) then
                  Sequence{ thisModule.TBlockWithForStatement(sourceBlock) }
               else
                  Sequence{}
               endif
         )
}

unique lazy rule TBlockWithForStatement {
   from sourceBlock : HADL!Block (
         sourceBlock.statements->exists(s| s.oclIsKindOf(HADL!ForStatement))
      )
   to
      sliceCounter : HADLc!Variable (
            name <- '_i',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         )
}

-------------------------------------------------------------------------------
-- 8. Imperative statements
--    8.2. Assignment statements
-------------------------------------------------------------------------------
-- For each assignment statement to a scalar variable,
-- we generate an assignment statement
-------------------------------------------------------------------------------

rule TAssignmentStatement {
   from sourceAssignment : HADL!AssignmentStatement (
         sourceAssignment.target.range.oclIsUndefined() and
         sourceAssignment.target.index.oclIsUndefined() and
         if sourceAssignment.target.dataContainer.oclIsKindOf(HADL!Parameter) then
            not sourceAssignment.target.dataContainer.isOutput
         else
            true
         endif
      )
   to
      block : HADLc!Block (
            variables <- sourceAssignment.getRanges(),
            statements <- targetAssignment
         ),
      targetAssignment : HADLc!ExpressionStatement (
            expression <- targetExpression
         ),
      targetExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- targetLeft,
            arguments <- sourceAssignment.source
         ),
      targetLeft : HADLc!VariableRefExpression (
            variable <- sourceAssignment.target.dataContainer
         )
}

rule TAssignmentStatementDereference {
   from sourceAssignment : HADL!AssignmentStatement (
         sourceAssignment.target.range.oclIsUndefined() and
         sourceAssignment.target.index.oclIsUndefined() and
         if sourceAssignment.target.dataContainer.oclIsKindOf(HADL!Parameter) then
            sourceAssignment.target.dataContainer.isOutput
         else
            false
         endif
      )
   to
      block : HADLc!Block (
            variables <- sourceAssignment.getRanges(),
            statements <- targetAssignment
         ),
      targetAssignment : HADLc!ExpressionStatement (
            expression <- targetExpression
         ),
      targetExpression : HADLc!OperatorExpression (
            operator <- '=',
            source <- targetLeft,
            arguments <- sourceAssignment.source
         ),
      targetLeft : HADLc!OperatorExpression (
            operator <- '*',
            source <- targetVariable
         ),
      targetVariable : HADLc!VariableRefExpression (
            variable <- sourceAssignment.target.dataContainer
         )
}

rule TAssignmentStatementWithIndex {
   from sourceAssignment : HADL!AssignmentStatement (
         sourceAssignment.target.range.oclIsUndefined() and
         not sourceAssignment.target.index.oclIsUndefined()
      )
   to
      block : HADLc!Block (
            variables <- sourceAssignment.getRanges(),
            statements <- targetStatement
         ),
      targetStatement : HADLc!ExpressionStatement (
            expression <- arrayWrite
         ),
      arrayWrite : HADLc!FunctionCall (
            functionName <- sourceAssignment.getFunctionNameArraySetValue(),
            actualParameters <- Sequence{targetExpression, sourceAssignment.target.index, sourceAssignment.source, arrayWriteArgumentTime}
         ),
      targetExpression : HADLc!VariableRefExpression (
            variable <- sourceAssignment.target.dataContainer
         ),
      arrayWriteArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         )
}

rule TAssignmentStatementWithTargetRange {
   from sourceAssignment : HADL!AssignmentStatement (
         not sourceAssignment.target.range.oclIsUndefined()
      )
   to
      block : HADLc!Block (
            variables <- sourceAssignment.getRanges(),
            statements <- targetStatement
         ),
      targetStatement : HADLc!ExpressionStatement (
            expression <-
               if not sourceAssignment.target.index.oclIsUndefined() then
                  thisModule.TRangeInTargetExpressionWithIndexArrayWriteField(sourceAssignment.target.range)
               else
                  thisModule.TRangeInTargetExpressionSetField(sourceAssignment.target.range)
               endif
         )
}

-------------------------------------------------------------------------------
-- 8. Imperative statements
--    8.3. Procedure call statements
-------------------------------------------------------------------------------
-- For each procedure call statement, we generate a function call.
-------------------------------------------------------------------------------

rule TProcedureCallStatement {
   from procedureCall : HADL!ProcedureCallStatement
   to
      block : HADLc!Block (
            variables <- procedureCall.getRanges(),
            statements <- targetStatement
         ),
      targetStatement : HADLc!ExpressionStatement (
            expression <- functionCall
         ),
      functionCall : HADLc!FunctionCall (
            functionName <- procedureCall.call.calledOperation.getFunctionName(),
            actualParameters <- Sequence{
                                    functionCallArgumentPipelineData,
                                    functionCallArgumentTime,
                                    functionCallArgumentStartTime,
                                    functionCallArgumentStage,
                                    functionCallArgumentInstruction,
                                    functionCallArgumentInline
                                 }->union(
                                    procedureCall.call.actualParameters
                                 )
         ),
      functionCallArgumentPipelineData : HADLc!VariableRefExpression (
            variableName <- '_pipeData'
         ),
      functionCallArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         ),
      functionCallArgumentStartTime : HADLc!VariableRefExpression (
            variableName <- '_startTime'
         ),
      functionCallArgumentStage : HADLc!VariableRefExpression (
            variableName <- '_stage'
         ),
      functionCallArgumentInstruction : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      functionCallArgumentInline : HADLc!IntegerLiteralExpression (
            value <- if procedureCall.call.inline then 1 else 0 endif
         )
}

-------------------------------------------------------------------------------
-- 8. Imperative statements
--    8.4. If statements
-------------------------------------------------------------------------------
-- If statements and if clauses are translated directly.
-- The if statement is enclosed in a block to support possible range variables.
-------------------------------------------------------------------------------

rule TIfStatement {
   from sourceIf : HADL!IfStatement
   to
      block : HADLc!Block (
            variables <- sourceIf.getRanges(),
            statements <- targetIf
         ),
      targetIf : HADLc!IfStatement (
            ifClauses <- sourceIf.ifClauses,
            elseClause <- sourceIf.elseClause
         )
}

rule TIfClause {
   from sourceIf : HADL!IfClause
   to
      targetIf : HADLc!IfClause (
            condition <- sourceIf.condition,
            thenClause <- sourceIf.thenClause
         )
}

-------------------------------------------------------------------------------
-- 8. Imperative statements
--    8.5. Return statements
-------------------------------------------------------------------------------
-- Return statement are transformed directly.
-- The return statement is enclosed in a block to support possible range
-- variables.
-------------------------------------------------------------------------------

rule TReturnStatement {
   from sourceReturn : HADL!ReturnStatement
   to
      block : HADLc!Block (
            variables <- sourceReturn.getRanges(),
            statements <- targetReturn
         ),
      targetReturn : HADLc!ReturnStatement (
         expression <- sourceReturn.expression
      )
}

-------------------------------------------------------------------------------
-- 8. Imperative statements
--    8.6. Loop statements
-------------------------------------------------------------------------------
-- Loops
-------------------------------------------------------------------------------

rule TForStatement {
   from sourceFor : HADL!ForStatement
   to
      forSlices : HADLc!ForStatement (
            counterName <- '_i',
            first <- forSlicesFirst,
            last <- forSlicesLast,
            step <- forSlicesStep,
            body <- forSlicesBody
         ),
      forSlicesFirst : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      forSlicesLast : HADLc!IntegerLiteralExpression (
            value <- sourceFor.range.slices->size()-1
         ),
      forSlicesStep : HADLc!IntegerLiteralExpression (
            value <- 1
         ),
      forSlicesBody : HADLc!Block (
            variables <- sourceFor.range,
            statements <- forCounter
         ),

      forCounter : HADLc!ForStatement (
            counterName <- sourceFor.counter.name,
            first <- forCounterFirst,
            last <- forCounterLast,
            step <- forCounterStep,
            body <- sourceFor.body
         ),

      forCounterFirst : HADLc!ArrayElementExpression (
            expression <- forCounterFirstVariable,
            indices <- Sequence{forCounterFirstSlice, forCounterFirstIndex}
         ),
      forCounterFirstVariable : HADLc!VariableRefExpression (
            variable <- sourceFor.range
         ),
      forCounterFirstSlice : HADLc!VariableRefExpression (
            variableName <- '_i'
         ),
      forCounterFirstIndex : HADLc!IntegerLiteralExpression (
            value <- 0
         ),

      forCounterLast : HADLc!ArrayElementExpression (
            expression <- forCounterLastVariable,
            indices <- Sequence{forCounterLastSlice, forCounterLastIndex}
         ),
      forCounterLastVariable : HADLc!VariableRefExpression (
            variable <- sourceFor.range
         ),
      forCounterLastSlice : HADLc!VariableRefExpression (
            variableName <- '_i'
         ),
      forCounterLastIndex : HADLc!IntegerLiteralExpression (
            value <- 1
         ),

      forCounterStep : HADLc!ArrayElementExpression (
            expression <- forCounterStepVariable,
            indices <- Sequence{forCounterStepSlice, forCounterStepIndex}
         ),
      forCounterStepVariable : HADLc!VariableRefExpression (
            variable <- sourceFor.range
         ),
      forCounterStepSlice : HADLc!VariableRefExpression (
            variableName <- '_i'
         ),
      forCounterStepIndex : HADLc!IntegerLiteralExpression (
            value <- 2
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.2. Variable references - rules
-------------------------------------------------------------------------------

unique lazy rule TVariableRefExpression {
   from sourceExpression : HADL!DataContainerRefExpression
   to
      targetExpression : HADLc!VariableRefExpression (
            variable <- sourceExpression.dataContainer
         )
}

unique lazy rule TReferencedVariableRefExpression {
   from sourceExpression : HADL!DataContainerRefExpression
   to
      targetExpression : HADLc!OperatorExpression (
            operator <- '&',
            source <- targetExpressionVariable
         ), 
      targetExpressionVariable : HADLc!VariableRefExpression (
            variable <- sourceExpression.dataContainer
         )
}

unique lazy rule TDereferencedVariableRefExpression {
   from sourceExpression : HADL!DataContainerRefExpression
   to
      targetExpression : HADLc!OperatorExpression (
            operator <- '*',
            source <- targetExpressionVariable
         ), 
      targetExpressionVariable : HADLc!VariableRefExpression (
            variable <- sourceExpression.dataContainer
         )
}

rule TSimpleVariableRefExpression {
   from sourceExpression : HADL!DataContainerRefExpression (
         sourceExpression.dataContainer.oclIsKindOf(HADL!Variable) and
         sourceExpression.index.oclIsUndefined() and
         sourceExpression.range.oclIsUndefined() and
         sourceExpression.owningAssignmentStatementTarget.oclIsUndefined()
      )
   to
      wrapper : HADLc!WrapperExpression (
            expression <-
               if sourceExpression.passByReference() then
                  thisModule.TReferencedVariableRefExpression(sourceExpression)
               else if sourceExpression.dereference() then
                  thisModule.TDereferencedVariableRefExpression(sourceExpression)
               else
                  thisModule.TVariableRefExpression(sourceExpression)
               endif endif
         )
}

rule TVariableRefExpressionWithRange {
   from sourceExpression : HADL!DataContainerRefExpression (
         sourceExpression.dataContainer.oclIsKindOf(HADL!Variable) and
         sourceExpression.index.oclIsUndefined() and
         not sourceExpression.range.oclIsUndefined() and
         sourceExpression.owningAssignmentStatementTarget.oclIsUndefined()
      )
  to
      wrapper : HADLc!WrapperExpression (
            expression <- thisModule.TRangeInSourceExpressionGetField(sourceExpression.range)
         ),
      getFieldData : HADLc!WrapperExpression (
            expression <-
               if sourceExpression.passByReference() then
                  thisModule.TReferencedVariableRefExpression(sourceExpression)
               else
                  thisModule.TVariableRefExpression(sourceExpression)
               endif
         )
}

rule TVariableRefExpressionWithIndex {
   from sourceExpression : HADL!DataContainerRefExpression (
         sourceExpression.dataContainer.oclIsKindOf(HADL!Variable) and
         not sourceExpression.index.oclIsUndefined() and
         sourceExpression.range.oclIsUndefined() and
         sourceExpression.owningAssignmentStatementTarget.oclIsUndefined()
      )
   to
      call : HADLc!FunctionCall (
            functionName <- sourceExpression.getFunctionNameArrayGetValue(sourceExpression.extend),
            actualParameters <- Sequence{
                  if sourceExpression.passByReference() then
                     thisModule.TReferencedVariableRefExpression(sourceExpression)
                  else
                     thisModule.TVariableRefExpression(sourceExpression)
                  endif,
                  sourceExpression.index,
                  arrayReadArgumentTime
               }
         ),
      arrayReadArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         )
}

rule TVariableRefExpressionWithIndexAndRange {
   from sourceExpression : HADL!DataContainerRefExpression (
         sourceExpression.dataContainer.oclIsKindOf(HADL!Variable) and
         not sourceExpression.index.oclIsUndefined() and
         not sourceExpression.range.oclIsUndefined() and
         sourceExpression.owningAssignmentStatementTarget.oclIsUndefined()
      )
   to
      wrapper : HADLc!WrapperExpression (
            expression <- thisModule.TRangeInSourceExpressionGetField(sourceExpression.range)
         ),
      getFieldData : HADLc!FunctionCall (
            functionName <- sourceExpression.getFunctionNameArrayGetValue(sourceExpression.extend),
            actualParameters <- Sequence{
                  if sourceExpression.passByReference() then
                     thisModule.TReferencedVariableRefExpression(sourceExpression)
                  else
                     thisModule.TVariableRefExpression(sourceExpression)
                  endif,
                  sourceExpression.index,
                  arrayReadArgumentTime
               }
         ),
      arrayReadArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         )
}

rule TVariableRefExpressionAsTargetWithRange {
   from sourceExpression : HADL!DataContainerRefExpression (
         if sourceExpression.dataContainer.oclIsKindOf(HADL!Variable) then
            not sourceExpression.range.oclIsUndefined() and
            not sourceExpression.owningAssignmentStatementTarget.oclIsUndefined() and
            (
               if sourceExpression.dataContainer.oclIsKindOf(HADL!Parameter) then
                  not sourceExpression.dataContainer.isOutput
               else
                  false
               endif
               or sourceExpression.dataContainer.isArray()
            )
         else
            false
         endif
      )
  to
      setFieldTarget : HADLc!VariableRefExpression (
            variable <- sourceExpression.dataContainer
         )
}

rule TReferencedVariableRefExpressionAsTargetWithRange {
   from sourceExpression : HADL!DataContainerRefExpression (
         if sourceExpression.dataContainer.oclIsKindOf(HADL!Variable) then
            not sourceExpression.range.oclIsUndefined() and
            not sourceExpression.owningAssignmentStatementTarget.oclIsUndefined() and
            if sourceExpression.dataContainer.oclIsKindOf(HADL!Parameter) then
               sourceExpression.dataContainer.isOutput
            else
               true
            endif
            and not sourceExpression.dataContainer.isArray()
         else
            false
         endif
      )
  to
      setFieldTarget : HADLc!OperatorExpression (
            operator <- '&',
            source <- setFieldTargetVariable
         ),
      setFieldTargetVariable : HADLc!VariableRefExpression (
            variable <- sourceExpression.dataContainer
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.3. Attribute references
-------------------------------------------------------------------------------
-- Attribute expressions
-------------------------------------------------------------------------------

rule TSimpleAttributeRefExpression {
   from attrExpression : HADL!DataContainerRefExpression (
         attrExpression.dataContainer.oclIsKindOf(HADL!Attribute) and
         attrExpression.range.oclIsUndefined()
      )
   to
      fieldExpression : HADLc!FieldRefExpression (
            expression <- fieldExpressionVariable,
            fieldName <- attrExpression.dataContainer.name,
            fromPointer <- true
         ),
      fieldExpressionVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )
}

rule TAttributeRefExpressionWithRange {
   from attrExpression : HADL!DataContainerRefExpression (
         attrExpression.dataContainer.oclIsKindOf(HADL!Attribute) and
         not attrExpression.range.oclIsUndefined()
      )
   to
      wrapper : HADLc!WrapperExpression (
            expression <- thisModule.TRangeInSourceExpressionGetField(attrExpression.range)
         ),
      getFieldData : HADLc!FieldRefExpression (
            expression <- getFieldDataVariable,
            fieldName <- attrExpression.dataContainer.name,
            fromPointer <- true
         ),
      getFieldDataVariable : HADLc!VariableRefExpression (
            variableName <- '_this'
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.4. Function calls
-------------------------------------------------------------------------------

rule TFunctionCallExpression {
   from sourceFunctionCall : HADL!FunctionCallExpression
   to
      targetFunctionCall : HADLc!FunctionCall (
            functionName <- sourceFunctionCall.call.calledOperation.getFunctionName(),
            actualParameters <- Sequence{
                                    targetFunctionCallArgumentPipelineData,
                                    targetFunctionCallArgumentTime,
                                    targetFunctionCallArgumentStartTime,
                                    targetFunctionCallArgumentStage,
                                    targetFunctionCallArgumentInstruction,
                                    targetFunctionCallArgumentInline
                                 }->union(
                                    sourceFunctionCall.call.actualParameters
                                 )
         ),
      targetFunctionCallArgumentPipelineData : HADLc!VariableRefExpression (
            variableName <- '_pipeData'
         ),
      targetFunctionCallArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         ),
      targetFunctionCallArgumentStartTime : HADLc!VariableRefExpression (
            variableName <- '_startTime'
         ),
      targetFunctionCallArgumentStage : HADLc!VariableRefExpression (
            variableName <- '_stage'
         ),
      targetFunctionCallArgumentInstruction : HADLc!VariableRefExpression (
            variableName <- '_instr'
         ),
      targetFunctionCallArgumentInline : HADLc!IntegerLiteralExpression (
            value <- if sourceFunctionCall.call.inline then 1 else 0 endif
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.5. Integer literals
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.6. Boolean literals
-------------------------------------------------------------------------------

rule TBooleanLiteralExpression {
   from sourceLiteral : HADL!BooleanLiteralExpression
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- if sourceLiteral.value then 1 else 0 endif
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.7. Operator expressions
-------------------------------------------------------------------------------
-- TODO special non-C operators
-------------------------------------------------------------------------------

rule TOperatorExpression {
   from sourceExpression : HADL!OperatorExpression
   to
      targetExpression : HADLc!OperatorExpression (
            operator <-
               if sourceExpression.operator = '!' then '!' else
               if sourceExpression.operator = '&&' then '&&' else
               if sourceExpression.operator = '||' then '||' else
               if sourceExpression.operator = '~' then '~' else
               if sourceExpression.operator = '&' then '&' else
               if sourceExpression.operator = '|' then '|' else
               if sourceExpression.operator = '^' then '^' else
               if sourceExpression.operator = '=' then '==' else
               if sourceExpression.operator = '!=' then '!=' else
               if sourceExpression.operator = 'asr' then '>>' else
               if sourceExpression.operator = 'lsl' then '<<' else
               if sourceExpression.operator = 'rem' then '%' else
                  -- TODO others: ?xor
                  sourceExpression.operator
               endif endif endif endif endif endif endif endif endif endif endif endif,
            source <- sourceExpression.source,
            arguments <- sourceExpression.arguments
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.9. Ranges - rules
-------------------------------------------------------------------------------

unique lazy rule TRangeInTargetExpressionSetField {
   from range : HADL!Range (
         range.owningForStatement.oclIsUndefined() and
         if range.owningDataContainerRefExpression.oclIsUndefined() then
            false
         else if range.owningDataContainerRefExpression.owningAssignmentStatementTarget.oclIsUndefined() then
            false
         else
            range.owningDataContainerRefExpression.index.oclIsUndefined()
         endif endif
      )
   to
      setField : HADLc!FunctionCall (
            functionName <- range.getFunctionNameFieldSetValue(),
            actualParameters <-
               Sequence{
                  range.owningDataContainerRefExpression,
                  range.owningDataContainerRefExpression.owningAssignmentStatementTarget.source,
                  setFieldRange, setFieldSize
               }
         ),
      setFieldRange : HADLc!VariableRefExpression (
            variable <- range
         ),
      setFieldSize : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         )
}

unique lazy rule TRangeInTargetExpressionWithIndexArrayWriteField {
   from range : HADL!Range (
         range.owningForStatement.oclIsUndefined() and
         if range.owningDataContainerRefExpression.oclIsUndefined() then
            false
         else if range.owningDataContainerRefExpression.owningAssignmentStatementTarget.oclIsUndefined() then
            false
         else
            not range.owningDataContainerRefExpression.index.oclIsUndefined()
         endif endif
      )
   to
      arrayWriteField : HADLc!FunctionCall (
            functionName <- range.getFunctionNameArraySetField(),
            actualParameters <-
               Sequence{
                  range.owningDataContainerRefExpression,
                  range.owningDataContainerRefExpression.index,
                  range.owningDataContainerRefExpression.owningAssignmentStatementTarget.source,
                  arrayWriteFieldArgumentRange, arrayWriteFieldArgumentSize, arrayWriteFieldArgumentTime
               }
         ),
      arrayWriteFieldArgumentRange : HADLc!VariableRefExpression (
            variable <- range
         ),
      arrayWriteFieldArgumentSize : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      arrayWriteFieldArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         )
}

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.13. Based integer literals
-------------------------------------------------------------------------------
-- Based integer literals that do not belong to format choices are
-- transformed into integer values.
-- Based literals with "don't care" digits are not allowed here.
-------------------------------------------------------------------------------

rule TBasedLiteralExpression {
   from sourceLiteral : HADL!BasedLiteralExpression (
         sourceLiteral.owningChoice.oclIsUndefined()
      )
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- sourceLiteral.getValue()
         )
}

rule TComponent {
   from component : HADL!Component
   to
      literal : HADLc!EnumLiteral (
            name <- component.getLiteralName()
         ),

      enumType : HADLc!EnumType (
            name <- component.getEnumerationTypeName(),
            literals <- component.operations->collect(o| thisModule.TOperationLiteral(o))
         )
}

unique lazy rule TOperationLiteral {
   from operation : HADL!Operation
   to
      literal : HADLc!EnumLiteral (
            name <- operation.getLiteralName()
         )
}

unique lazy rule TPortLiteral {
   from port : HADL!Port
   to
      literal : HADLc!EnumLiteral (
            name <- port.getLiteralName()
         )
}

rule TPipeline {
   from pipeline : HADL!Pipeline
   to
      literal : HADLc!EnumLiteral (
            name <- pipeline.getLiteralName()
         ),
         
      -- Pipeline static representation (global variable)
      pipelineVariable : HADLc!Variable (
            name <- pipeline.getVariableName(),
            typeName <- 'HADL_Pipeline_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- pipelineVariableValue
         ),
      pipelineVariableValue : HADLc!ArrayExpression (
            elements <- Sequence{
                           pipelineRepName,
                           pipelineRepNumberOfStages,
                           pipelineRepStagesRep
                        }
         ),
      pipelineRepName : HADLc!StringLiteralExpression (
            value <- pipeline.name
         ),
      pipelineRepNumberOfStages : HADLc!IntegerLiteralExpression (
            value <- pipeline.stages->size()
         ),
      pipelineRepStagesRep : HADLc!VariableRefExpression (
            variable <- stagesVariable
         ),
      
      -- Pipeline stages static representation (global variable)
      stagesVariable : HADLc!Variable (
            name <- pipeline.getStagesVariableName(),
            typeName <- 'HADL_Stage_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            "size" <- stagesVariableSize,
            init <- stagesVariableValue
         ),
      stagesVariableSize : HADLc!IntegerLiteralExpression (
            value <- pipeline.stages->size()
         ),
      stagesVariableValue : HADLc!ArrayExpression (
            elements <- pipeline.stages->collect(s| thisModule.resolveTemp(s, 'stageRep'))
         ),

      -- Pipeline init function
      initFunction : HADLc!Function (
            name <- pipeline.getInitFunctionName(),
            typeName <- 'HADL_PipelineData_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            body <- initBody
         ),

      initBody : HADLc!Block (
            variables <- Sequence{initPipeData, initTime, initStage, initPtrTime, initStartTime, initPtrStage, initDummyInstructionVariable},
            statements <- Sequence{pipeline.init, initReturnStatement}
         ),
      initPipeData : HADLc!Variable (
            name <- '_pipeData',
            typeName <- 'HADL_PipelineData_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- initPipeDataValue
         ),
      initPipeDataValue : HADLc!FunctionCall (
            functionName <- 'HADL_Scheduler_newPipelineData',
            actualParameters <- Sequence{initPipeDataValuePipe, initPipeDataValueStages, initPipeDataValueResources}
         ),
      initPipeDataValuePipe : HADLc!OperatorExpression (
            operator <- '&',
            source <- initPipeDataValuePipeVariable
         ),
      initPipeDataValuePipeVariable : HADLc!VariableRefExpression (
            variableName <- pipeline.getVariableName()
         ),
      initPipeDataValueStages : HADLc!IntegerLiteralExpression (
            value <- pipeline.stages->size()
         ),
      initPipeDataValueResources : HADLc!IntegerLiteralExpression (
            value <- HADL!Port.allInstances()->size() -- TODO restrict to current architecture
         ),
   
      initTime : HADLc!Variable (
            name <- '_dtime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- initTimeValue
         ),
      initTimeValue : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      initPtrTime : HADLc!Variable (
            name <- '_time',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- initPtrTimeValue
         ),
      initPtrTimeValue : HADLc!OperatorExpression (
            operator <- '&',
            source <- initPtrTimeVariable
         ),
      initPtrTimeVariable : HADLc!VariableRefExpression (
            variable <- initTime
         ),
      initStartTime : HADLc!Variable (
            name <- '_startTime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- initStartTimeValue
         ),
      initStartTimeValue : HADLc!IntegerLiteralExpression (
            value <- 0
         ),

      initStage : HADLc!Variable (
            name <- '_dstage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- initStageValue
         ),
      initStageValue : HADLc!IntegerLiteralExpression (
            value <- 0-1
         ),
      initPtrStage : HADLc!Variable (
            name <- '_stage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- initPtrStageValue
         ),
      initPtrStageValue : HADLc!OperatorExpression (
            operator <- '&',
            source <- initPtrStageVariable
         ),
      initPtrStageVariable : HADLc!VariableRefExpression (
            variable <- initStage
         ),

      initDummyInstructionVariable : HADLc!Variable (
            name <- '_instr',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- initDummyInstructionVariableValue
         ),
      initDummyInstructionVariableValue : HADLc!VariableRefExpression (
            variableName <- 'NULL'
         ),

      initReturnStatement : HADLc!ReturnStatement (
            expression <- initReturnPipeData
         ),
      initReturnPipeData : HADLc!VariableRefExpression (
            variableName <- '_pipeData'
         ),

      -- Pipeline step function
      stepFunction : HADLc!Function (
            name <- pipeline.getStepFunctionName(),
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            parameters <- Sequence{stepFunctionPipelineDataParameter, stepFunctionTimeParameter},
            body <- stepBody
         ),
      stepFunctionPipelineDataParameter : HADLc!Parameter (
            name <- '_pipeData',
            typeName <- 'HADL_PipelineData_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true
         ),
      stepFunctionTimeParameter : HADLc!Parameter (
            name <- '_dtime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false
         ),
         
      stepBody : HADLc!Block (
            variables <- pipeline.expression.getRanges()->union(Sequence{stepStage, stepPtrStage, stepPtrTime, stepStartTime, stepDummyInstructionVariable, instructionVariable, bufferVariable}),
            statements <- Sequence{disassembleCallStatement, asmDumpCallStatement, runCallStatement}
         ),

      stepStage : HADLc!Variable (
            name <- '_dstage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- stepStageValue
         ),
      stepStageValue : HADLc!EnumLiteralRefExpression (
            name <- pipeline.stages->first().getLiteralName()
         ),
      stepPtrStage : HADLc!Variable (
            name <- '_stage',
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- stepPtrStageValue
         ),
      stepPtrStageValue : HADLc!OperatorExpression (
            operator <- '&',
            source <- stepPtrStageVariable
         ),
      stepPtrStageVariable : HADLc!VariableRefExpression (
            variable <- stepStage
         ),
      stepPtrTime : HADLc!Variable (
            name <- '_time',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- stepPtrTimeValue
         ),
      stepPtrTimeValue : HADLc!OperatorExpression (
            operator <- '&',
            source <- stepPtrTimeVariable
         ),
      stepPtrTimeVariable : HADLc!VariableRefExpression (
            variable <- stepFunctionTimeParameter
         ),
      stepStartTime : HADLc!Variable (
            name <- '_startTime',
            typeName <- 'HADL_Time_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- stepStartTimeValue
         ),
      stepStartTimeValue : HADLc!VariableRefExpression (
            variable <- stepFunctionTimeParameter
         ),

      stepDummyInstructionVariable : HADLc!Variable (
            name <- '_instr',
            typeName <- 'void',
            isStruct <- false,
            isEnum <- false,
            isPointer <- true,
            init <- stepDummyInstructionVariableValue
         ),
      stepDummyInstructionVariableValue : HADLc!VariableRefExpression (
            variableName <- 'NULL'
         ),

         
      instructionVariable : HADLc!Variable (
            name <- '_idata',
            typeName <- pipeline.behavior.getStructTypeName(),
            isEnum <- false,
            isStruct <- true,
            isPointer <- true,
            init <- instructionVariableDecode
         ),
      instructionVariableDecode : HADLc!FunctionCall (
            functionName <- pipeline.behavior.getDecodeFunctionName(),
            actualParameters <- Sequence{pipeline.expression, decodeParent, decodePath}
         ),
      decodeParent : HADLc!VariableRefExpression (
            variableName <- 'NULL'
         ),
      decodePath : HADLc!EnumLiteralRefExpression (
            name <- pipeline.owningModel.name + '_Root_path'
         ),
      
      bufferVariable : HADLc!Variable (
            name <- '_buffer',
            typeName <- 'char',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            "size" <- bufferVariableSize
         ),
      bufferVariableSize : HADLc!VariableRefExpression (
            variableName <- 'HADL_BUFFER_SIZE'
         ),

      disassembleCallStatement : HADLc!ExpressionStatement (
            expression <- disassembleCallExpression
         ),
      disassembleCallExpression : HADLc!FunctionCall (
            functionName <- pipeline.behavior.getDisassembleFunctionName(),
            actualParameters <- Sequence{disassembleCallThisArgument, disassembleCallBufferArgument, disassembleCallCountArgument, disassembleCallArgsArgument}
         ),
      disassembleCallThisArgument : HADLc!VariableRefExpression (
            variable <- instructionVariable
         ),
      disassembleCallBufferArgument : HADLc!VariableRefExpression (
            variable <- bufferVariable
         ),
      disassembleCallCountArgument : HADLc!IntegerLiteralExpression (
            value <- 0
         ),
      disassembleCallArgsArgument : HADLc!VariableRefExpression (
            variableName <- 'NULL'
         ),
         
      asmDumpCallStatement : HADLc!ExpressionStatement (
            expression <- asmDumpCallExpression
         ),
      asmDumpCallExpression : HADLc!FunctionCall (
            functionName <- 'HADL_Debug_asmDump',
            actualParameters <- asmDumpArgument
         ),
      asmDumpArgument : HADLc!VariableRefExpression (
            variable <- bufferVariable
         ),

      runCallStatement : HADLc!ExpressionStatement (
            expression <- runCallExpression
         ),
      runCallExpression : HADLc!FunctionCall (
            functionName <- pipeline.behavior.getRunFunctionName(),
            actualParameters <- Sequence{
                                    runCallArgumentPipelineData,
                                    runCallArgumentTime,
                                    runCallArgumentStartTime,
                                    runCallArgumentStage,
                                    runCallArgumentInstruction,
                                    runCallArgumentThis
                                 }
         ),
      runCallArgumentPipelineData : HADLc!VariableRefExpression (
            variableName <- '_pipeData'
         ),
      runCallArgumentTime : HADLc!VariableRefExpression (
            variableName <- '_time'
         ),
      runCallArgumentStartTime : HADLc!VariableRefExpression (
            variableName <- '_startTime'
         ),
      runCallArgumentStage : HADLc!VariableRefExpression (
            variableName <- '_stage'
         ),
      runCallArgumentInstruction : HADLc!VariableRefExpression (
            variableName <- '_idata'
         ),
      runCallArgumentThis : HADLc!VariableRefExpression (
            variable <- instructionVariable
         ),

      enumType : HADLc!EnumType (
            name <- pipeline.getEnumerationTypeName(),
            literals <- pipeline.stages->collect(s| thisModule.resolveTemp(s, 'literal'))
         )
}

rule TStage {
   from stage : HADL!Stage
   using {
      ports : Sequence(HADL!Port) = stage.getPorts();
   }
   to
      literal : HADLc!EnumLiteral (
            name <- stage.getLiteralName()
         ),

      -- Stage static representation
      stageSuccessorsVariable : HADLc!Variable (
            name <- stage.getSuccessorsVariableName(),
            typeName <- 'unsigned',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            "size" <- stageSuccessorsVariableSize, -- TODO
            init <- stageSuccessorsVariableValue -- TODO
         ),
      stageSuccessorsVariableSize : HADLc!IntegerLiteralExpression (
            value <- 1 -- TODO
         ),
      stageSuccessorsVariableValue : HADLc!ArrayExpression (
            elements <- stageRepSuccessorsElement -- TODO
         ),
      stageRepSuccessorsElement : HADLc!EnumLiteralRefExpression (
            name <- stage.getNextStage().getLiteralName() -- TODO
         ),
         
      -- Stage representation from pipeline representation
      stageRep : HADLc!ArrayExpression (
            elements <- Sequence{
                           stageRepName,
                           stageRepNumberOfSuccessors,
                           stageRepSuccessors,
                           stageRepNumberOfPorts,
                           stageRepPorts
                        }
         ),
      stageRepName : HADLc!StringLiteralExpression (
            value <- stage.name
         ),
      stageRepNumberOfSuccessors : HADLc!IntegerLiteralExpression (
            value <- 1 -- TODO
         ),
      stageRepSuccessors : HADLc!VariableRefExpression (
            variable <- stageSuccessorsVariable
         ),
      stageRepNumberOfPorts : HADLc!IntegerLiteralExpression (
            value <- ports->size()
         ),
      stageRepPorts : HADLc!VariableRefExpression (
            variable <- stagePortsVariable
         ),
      
      -- Stage ports variable
      stagePortsVariable : HADLc!Variable (
            name <- stage.getPortsVariableName(),
            typeName <- 'HADL_PortUsage_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            "size" <- stagePortsVariableSize,
            init <- stagePortsValue
         ),
      stagePortsVariableSize : HADLc!IntegerLiteralExpression (
            value <- ports->size()
         ),
      stagePortsValue : HADLc!ArrayExpression (
            -- See imperative block
         )

   do {
      for(a in stage.activations) {
         for(p in a.getPorts()) {
            thisModule.TPortUsage(p, stagePortsValue, a.isReusable);
         }
      }
   }
}

rule TPortUsage (port : HADL!Port, expr : HADLc!ArrayExpression, reusable : Boolean) {
   to
      portUsageRep : HADLc!ArrayExpression (
            elements <- Sequence{portUsageRef, portUsageReusable},
            owningArrayExpression <- expr
         ),
      portUsageRef : HADLc!OperatorExpression (
            operator <- '&',
            source <- portUsageVariable
         ),
      portUsageVariable : HADLc!VariableRefExpression (
            variableName <- port.getPortVariableName()
         ),
      portUsageReusable : HADLc!IntegerLiteralExpression (
            value <- if reusable then 1 else 0 endif
         )
}

rule TPort {
   from port : HADL!Port
   to
      portVariable : HADLc!Variable (
            name <- port.getPortVariableName(),
            typeName <- 'HADL_Port_t',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            init <- portVariableValue
         ),
      portVariableValue : HADLc!ArrayExpression (
            elements <- Sequence{
                           portVariableValueName,
                           portVariableValueId,
                           portVariableValueComponent,
                           portVariableValueNumberOfOperations,
                           portVariableValueOperations
                        }
         ),
      portVariableValueName : HADLc!StringLiteralExpression (
            value <- port.owningResource.name + '.' + port.name
         ),
      portVariableValueId : HADLc!EnumLiteralRefExpression (
            name <- port.getLiteralName()
         ),
      portVariableValueComponent : HADLc!EnumLiteralRefExpression (
            name <- port.owningResource.component.getLiteralName()
         ),
      portVariableValueNumberOfOperations : HADLc!IntegerLiteralExpression (
            value <- port.getOperations()->size()
         ),
      portVariableValueOperations : HADLc!VariableRefExpression (
            variable <- operationsVariable
         ),

      operationsVariable : HADLc!Variable (
            name <- port.getOperationsVariableName(),
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            "size" <- operationsVariableSize, 
            init <- operationsVariableValue
         ),
      operationsVariableSize : HADLc!IntegerLiteralExpression (
            value <- port.getOperations()->size()
         ),
      operationsVariableValue : HADLc!ArrayExpression (
            elements <- port.getOperations()->collect(o| thisModule.TOperationLiteralRef(o))
         )
}

lazy rule TOperationLiteralRef {
   from operation : HADL!Operation
   to
      operationRep : HADLc!EnumLiteralRefExpression (
            name <- operation.getLiteralName()
         )
}

unique lazy rule TRangeInSourceExpressionGetField {
   from range : HADL!Range
   to
      getField : HADLc!FunctionCall (
            functionName <- range.getFunctionNameFieldGetValue(),
            actualParameters <-
               Sequence{
                  thisModule.resolveTemp(
                     range.owningDataContainerRefExpression
                     , 'getFieldData'
                  ),
                  getFieldRange, getFieldSize, getFieldShift, getFieldRight, getFieldRotate, getFieldArithmetic
               }
         ),
      getFieldRange : HADLc!VariableRefExpression (
            variable <- range
         ),
      getFieldSize : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      getFieldShift : HADLc!IntegerLiteralExpression (
            value <- range.shiftAmount
         ),
      getFieldRight : HADLc!IntegerLiteralExpression (
            value <- if range.right then 1 else 0 endif
         ),
      getFieldRotate : HADLc!IntegerLiteralExpression (
            value <- if range.shift then 0 else 1 endif
         ),
      getFieldArithmetic : HADLc!IntegerLiteralExpression (
            value <- if range.arithmetic then 1 else 0 endif
         )
}

-------------------------------------------------------------------------------
-- Component variables and rules common to several modules
-------------------------------------------------------------------------------

helper def: rangeIndex : Integer = 0;

rule TRange {
   from range : HADL!Range
   to
      variable : HADLc!Variable (
            name <- thisModule.newRangeVariableName(),
            typeName <- 'int',
            isStruct <- false,
            isEnum <- false,
            isPointer <- false,
            size <- Sequence{sizeHeight, sizeWidth},
            init <- array
         ),
      sizeHeight : HADLc!IntegerLiteralExpression (
            value <- range.slices->size()
         ),
      sizeWidth : HADLc!IntegerLiteralExpression (
            value <- 3
         ),
      array : HADLc!ArrayExpression (
            elements <- range.slices
         )
}
      
rule TPrint (message : String, block : HADLc!Block) {
   to
      printStatement : HADLc!ExpressionStatement (
            expression <- printCall,
            owningBlock <- block
         ),
      printCall : HADLc!FunctionCall (
            functionName <- 'HADL_Debug_printMessage',
            actualParameters <- printArgument
         ),
      printArgument : HADLc!StringLiteralExpression (
            value <- message
         )
}

rule TSliceWithFirstLastAndStep {
   from slice : HADL!Slice (
         not slice.last.oclIsUndefined() and
         not slice.step.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  slice.last,
                  slice.step
               }
         )
}

rule TSliceWithFirstAndLast {
   from slice : HADL!Slice (
         not slice.last.oclIsUndefined() and
         slice.step.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  slice.last,
                  step
               }
         ),
      step : HADLc!IntegerLiteralExpression (
            value <- 1
         )
}

rule TSliceWithFirstOnly {
   from slice : HADL!Slice (
         slice.last.oclIsUndefined()
      )
   to
      array : HADLc!ArrayExpression (
            elements <-
               Sequence{
                  slice.first,
                  last,
                  step
               }
         ),
      last : HADLc!CopyExpression (
            copiedExpression <- slice.first
         ),
      step : HADLc!IntegerLiteralExpression (
            value <- 1
         )
}

rule TIntegerLiteralExpression {
   from sourceLiteral : HADL!IntegerLiteralExpression
   to
      targetLiteral : HADLc!IntegerLiteralExpression (
            value <- sourceLiteral.value
         )
}

