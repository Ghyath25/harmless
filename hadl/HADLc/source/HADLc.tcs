
syntax HADLc {
  
  ---------------------------------------------------------
  -- Top level
  ---------------------------------------------------------

  template Model main
    : "#ifndef" name []
      "#define" name []
      [ includedFiles elements ]{nbNL=2, indentIncr=0}
      "#endif" []
    ;

  template ModelElement abstract;

   template IncludeFile
      :  "#include" name{as=stringSymbol}
      ;

  ---------------------------------------------------------
  -- Typed elements
  ---------------------------------------------------------

  template TypedElement abstract;

  function signature(TypeSpecification)
    : (isStruct ? "struct")
      (isEnum ? "enum")
      typeName
      (isPointer ? "*")
    ;

  ---------------------------------------------------------
  -- Struct types
  ---------------------------------------------------------

  template StructType
    : "struct" name
      (isDefined(fields)?
        "{" [
          fields
        ] "}"
      )
      ";"
    ;

  template StructField
    : $signature name
      (isDefined(size)?
         "[" size{separator="]["} "]"
         : (isArray? "[" "]")
      )
      ";"
    ;

  ---------------------------------------------------------
  -- Enum types
  ---------------------------------------------------------

  template EnumType
    : "enum" name
      (isDefined(literals)?
        "{" [
          literals{separator=","}
        ] "}"
      )
      ";"
    ;
    
  template EnumLiteral
    : name
    ;

  ---------------------------------------------------------
  -- Functions
  ---------------------------------------------------------

  template Function
    : $signature name "(" parameters{separator=","} ")"
      (isDefined(body)?
        body : ";"
      )
    ;

  template Parameter
    : $signature name (isArray? "[" "]")
    ;

  template Variable
    : $signature name
      (isDefined(size)? "[" size{separator="]["} "]" : (isArray? "[" "]"))
      (isDefined(init)? "=" init) ";"
    ;

  ---------------------------------------------------------
  -- Statements
  ---------------------------------------------------------
  
  template Statement abstract;

  template Block
    : "{" [
        variables
        statements
      ] "}"
    ;
    
  template ExpressionStatement
    : expression ";"
    ;

  template IfStatement
    : [ ifClauses{separator="else"} ]{indentIncr=0}
      (isDefined(elseClause)?
         "else" elseClause
      )
   ;

  template IfClause
    : "if" "(" condition ")" thenClause
    ;

  template SwitchStatement
    : "switch" "(" expression ")" "{" [
        cases
        (isDefined(defaultStatements)?
            "default" ":" [ defaultStatements ]
        )
      ] "}"
    ;
  
  template Case
    : "case" 'value' ":"
      [ statements "break" ";" ]
    ;

   template ForStatement
      : "for" "("
               counterName "=" first
            ";"
               "(" first "<=" last ")"
               "?" "(" counterName "<=" last ")"
               ":" "(" counterName ">=" last ")"
            ";"
               "(" first "<=" last ")"
               "?" "(" counterName "+=" step ")"
               ":" "(" counterName "-=" step ")"
         ")"
        body
      ;

   template WhileStatement
      :  "while" "(" expression ")"
         body
      ;

   template BreakStatement
      :  "break" ";"
      ;

   template ReturnStatement
      :  "return" (isDefined(expression)? expression) ";"
      ;

  ---------------------------------------------------------
  -- Expressions
  ---------------------------------------------------------
  
  template Expression abstract operatored;

  template FunctionCall
    : functionName "(" actualParameters{separator=","} ")"
    ;

  template ArrayElementExpression
    : expression
      "[" indices{separator="]["} "]"
    ;

  template VariableRefExpression
    : (isDefined(variableName)? variableName)
      (isDefined(variable)? variable{refersTo=name})
    ;

  template FieldRefExpression
    : expression
      (fromPointer? "->" : ".")
      fieldName
    ;

  template EnumLiteralRefExpression
    : name
    ;

  template IntegerLiteralExpression
    : 'value'
    ;

  template StringLiteralExpression
    : 'value'{as=stringSymbol}
    ;

   template ArrayExpression
      : "{" elements{separator=","} "}"
      ;

   template CopyExpression
      : copiedExpression
      ;

   template WrapperExpression
      : expression
      ;

   template ConditionalExpression
      : "(" "(" condition ")" "?" "(" then ")" ":" "(" else ")" ")"
      ;

   operatorTemplate OperatorExpression
      (
         operators = negOp addOp subOp mulOp divOp remOp
                     ltOp leqOp gtOp geqOp eqOp neqOp
                     notOp andOp orOp
                     bnotOp bandOp borOp bxorOp
                     lslOp asrOp
                     indOp drfOp
                     assignOp,
         source = 'source',
         storeOpTo = operator,
         storeRightTo = arguments
      );

   template TypeExpression
      :  $signature
      ;

   template CastExpression
      :  "(" $signature ")" "(" expression ")"
      ;

  ---------------------------------------------------------

  symbols {
      lcurly = "{":leftSpace,rightNone;
      rcurly = "}":leftNone,rightSpace;
      lsquare = "[":leftNone,rightNone;
      rsquare = "]":leftNone,rightNone;
      lparen = "(";
      rparen = ")";
      colon = ":";
      comma = ",";
      semi = ";":leftNone,rightSpace;
      star = "*":leftSpace,rightSpace;
      slash = "/";
      minus = "-";
      plus = "+";
      leq = "<=";
      lt = "<";
      geq = ">=";
      gt = ">";
      eq = "=";
      eq2 = "==";
      ne = "!=";
      excl = "!":rightNone;
      uscore = "_":leftSpace,rightNone;
      amp = "&":rightNone;
      rarrow = "->":leftNone,rightNone;
      percent = "%";
      gt2 = ">>";
      lt2 = "<<";
      amp2 = "&&";
      pipe = "|";
      pipe2 = "||";
      tilde = "~":rightNone;
      pluseq = "+=";
      circ = "^";
  }

   operators {
      priority 0 {
         notOp = excl, 1;
         bnotOp = tilde, 1;
         negOp = minus, 1;
         posOp = plus, 1;
         indOp = amp, 1;
         drfOp = star, 1;
      }

      priority 1 {
         mulOp = star, 2;
         divOp = slash, 2;
         remOp = percent, 2;
      }

      priority 2 {
         addOp = plus, 2;
         subOp = minus, 2;
      }

      priority 3 {
         asrOp = gt2, 2;
         lslOp = lt2, 2;
      }
      
      priority 4 {
         leqOp = leq, 2;
         ltOp = lt, 2;
         geqOp = geq, 2;
         gtOp = gt, 2;
      }

      priority 5 {
         eqOp = eq2, 2;
         neqOp = ne, 2;
      }

      priority 6 {
         bandOp = amp, 2;
      }

      priority 7 {
         bxorOp = circ, 2;
      }

      priority 8 {
         borOp = pipe, 2;
      }

      priority 9 {
         andOp = amp2, 2;
      }
      
      priority 10 {
         orOp = pipe2, 2;
      }

      priority 11 {
         assignOp = eq, 2;
      }
   }

}

