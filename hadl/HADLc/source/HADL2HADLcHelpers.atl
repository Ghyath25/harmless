
library HADL2HADLcHelpers;

helper context HADL!Model def:
   getCreateFunctionName() : String =
      self.name + '_create';

-------------------------------------------------------------------------------
-- 5. Formats
--    5.1. Common helpers
-------------------------------------------------------------------------------
-- getDecodeFunctionName
--
--    Returns the name of the function used for decoding a given instruction
--    format. The function name is obtained by concatenating the model name,
--    the format name and suffix 'decode'.
-------------------------------------------------------------------------------

helper context HADL!Behavior def:
   getDecodeFunctionName() : String =
      self.owningModel.name + '_' + self.name + '_decode';

helper context HADL!Format def:
   getDecodeFunctionName() : String =
      self.owningModel.name + '_' + self.behavior.name +
      self.paths
         ->asSequence()
         ->iterate(p; acc1:String=''|
               acc1 +
               p.elements
                  ->iterate(e; acc2:String=''|
                        acc2 + '_' +
                        e.behavior.name +
                        if e.behaviorChunk.oclIsUndefined() then
                           ''
                        else
                           '_' + e.behaviorChunk.label
                        endif
                     ) +
               if not p.range.oclIsUndefined() then
                  '_' + thisModule.newDecodeFunctionIndex().toString()
               else
                  ''
               endif
            ) +
      '_decode';

helper def: newDecodeFunctionIndex() : Integer =
   thisModule.refSetValue('decodeFunctionIndex', thisModule.decodeFunctionIndex+1).decodeFunctionIndex;

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.1. Common helpers
-------------------------------------------------------------------------------
-- getDisassembleFunctionName
--
--    Returns the name of the function that disassembles to a certain
--    instruction syntax.
-------------------------------------------------------------------------------

helper context HADL!Behavior def:
   getDisassembleFunctionName() : String =
      self.owningModel.name + '_' + self.name + '_disassemble';

helper context HADL!Syntax def:
   getDisassembleFunctionName() : String =
      self.owningModel.name + '_' + self.behavior.name +
      self.paths
         ->asSequence()
         ->iterate(p; acc1:String=''|
               acc1 +
               p.elements
                  ->iterate(e; acc2:String=''|
                        acc2 + '_' +
                        e.behavior.name +
                        if e.behaviorChunk.oclIsUndefined() then
                           ''
                        else
                           e.behaviorChunk.label
                        endif
                     )
            ) +
      '_disassemble';

-------------------------------------------------------------------------------
-- 6. Syntax
--    6.3. Attributes and aggregate syntax chunks - helpers
-------------------------------------------------------------------------------
-- getBufferVariableName
--
--    Returns the name of the variable that will hold the result of a
--    disassembling operation for a given chunk.
--    The name is obtained by suffixing the chunk name with 'buffer'.
-------------------------------------------------------------------------------

helper context HADL!NamedElement def:
   getBufferVariableName() : String =
      self.name + '_buffer';

-- TODO remove this helper
--helper context HADL!SyntaxChunk def:
--   getBufferVariableName() : String =
--      self.behaviorChunk.getBufferVariableName();

helper context HADL!AttributeSyntax def:
   getBufferVariableName() : String =
      self.attribute.getBufferVariableName();

-- TODO: remove this helper
-- See helper HADL!BehaviorChoice::getLiteralName
--helper context HADL!CallSyntaxChoice def:
--   getLiteralName() : String =
--      self.owningSyntax.owningModel.name + '_' +
--      self.owningSyntax.behavior.name + '_' +
--      self.call.syntax.behavior.name + '_choice';

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.1. Common helpers
-------------------------------------------------------------------------------
-- Each behavior will be mapped onto a C struct type and a 'run' function.
--
-- getStructTypeName
--
--    The name of the struct type is obtained by concatenating the name of the
--    model, the name of the behavior and suffix 'st'.
--
-- getRunFunctionName
--
--    The name of the 'run' function is obtained by concatenating the name of
--    the model, the name of the behavior and suffix 'run'.
-------------------------------------------------------------------------------

helper context HADL!BehaviorChunk def:
   getFieldName() : String =
      if self.label.oclIsUndefined() then
         'chunk' + '_' + self.call.behavior.getStructTypeName()
      else
         'chunk' + '_' + self.label
      endif;

helper context HADL!Behavior def:
   getStructTypeName() : String =
      self.owningModel.name + '_' + self.name + '_st';

helper context HADL!Behavior def:
   getRunFunctionName() : String =
      self.owningModel.name + '_' + self.name + '_run';

-------------------------------------------------------------------------------
-- 4. Behaviors
--    4.4. Alternative behaviors - helpers
-------------------------------------------------------------------------------
-- getEnumerationTypeName
--
--    Returns the name of the enum type generated from each alternative
--    behavior. The name is obtained by concatenating the model name, the
--    behavior name and suffix 'en'.
--
-- getLiteralName
--
--    Returns the enum literal name for a given behavior choice. The name
--    depends on whether the choice is terminal or calls another behavior.
--    It is obtained by concatenating the model name, the behavior name,
--    the choice name (terminal) or the called behavior name.
-------------------------------------------------------------------------------

helper context HADL!Behavior def:
   getEnumerationTypeName() : String =
      self.owningModel.name + '_' + self.name + '_en';

helper context HADL!BehaviorChoice def:
   getLiteralName() : String =
      self.owningBehavior.owningModel.name +
      '_' + self.owningBehavior.name +
      '_' +
      if self.oclIsKindOf(HADL!LeafBehaviorChoice) then
         self.name
      else
         self.call.behavior.name
      endif +
      '_choice';

helper context HADL!CallBehaviorChoice def:
   getPathLiteralName() : String =
      self.owningBehavior.owningModel.name +
      '_' + self.owningBehavior.name +
      '_' + self.call.behavior.name +
      '_path';

helper context HADL!BehaviorChunk def:
   getPathLiteralName() : String =
      self.owningBehavior.owningModel.name +
      '_' + self.owningBehavior.name +
      '_' + self.call.behavior.name +
      if self.label.oclIsUndefined() then
         ''
      else
         '_' + self.label
      endif +
      '_path';

helper context HADL!CallFormatChoice def:
   getPathLiteralName() : String =
      self.owningFormat.owningModel.name +
      '_' + self.owningFormat.behavior.name +
      '_' + self.behavior.name +
      '_path';

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.1. Variable references - helpers
-------------------------------------------------------------------------------
-- isOutput
--
--    A variable reference expression is detected as an output if it is passed
--    as an argument to a behavior or operation call where the corresponding
--    parameter is an output parameter.
--
--    This helper is used to identify when a variable should be passed by
--    reference when calling a function.
-------------------------------------------------------------------------------

helper context HADL!Variable def:
   isArray() : Boolean =
      not self.arraySize.oclIsUndefined();

helper context HADL!DataContainerRefExpression def:
   passByReference() : Boolean =
      if self.dataContainer.oclIsKindOf(HADL!Parameter) or self.dataContainer.isArray() then
         false
      else if not self.owningBehaviorCallActual.oclIsUndefined() then
         let index : Integer =
            self.owningBehaviorCallActual.actualParameters->indexOf(self)
         in
            self.owningBehaviorCallActual.behavior.parameters->at(index).isOutput
      else if not self.owningOperationCall.oclIsUndefined() then
         let index : Integer =
            self.owningOperationCall.actualParameters->indexOf(self)
         in
            self.owningOperationCall.calledOperation.parameters->at(index).isOutput
      else
         false
      endif endif endif;
    
helper context HADL!DataContainerRefExpression def:
   dereference() : Boolean =
      if self.dataContainer.oclIsKindOf(HADL!Parameter) and
         not self.dataContainer.isArray() and
         self.index.oclIsUndefined() and
         self.range.oclIsUndefined()
      then
         -- If this expression references an output parameter of a behavior or operation,
         -- with no index or range, we may consider dereferencing it
         if self.dataContainer.isOutput then
            -- If the expression itself is an argument in a behavior or operation call,
            -- dereferencing should occur only if the corresponding parameter is not
            -- an output parameter.
            -- Otherwise, dereferencing must be applied.
            if not self.owningOperationCall.oclIsUndefined() then
               not self.owningOperationCall.calledOperation.parameters->at(
                     self.owningOperationCall.actualParameters->indexOf(self)
                  ).isOutput
            else if not self.owningBehaviorCallActual.oclIsUndefined() then
               not self.owningBehaviorCallActual.behavior.parameters->at(
                     self.owningBehaviorCallActual.actualParameters->indexOf(self)
                  ).isOutput
            else
               true
            endif endif
         else
            false
         endif
      else
         false
      endif;
   
-------------------------------------------------------------------------------
-- 3. Operations
--    3.1. Helpers
-------------------------------------------------------------------------------
--
-- getAllOperations
--
--    Returns all the operations owned by all components in the given model.
--
-- getReturnTypeName
--
--    Returns name of the C return type of an operation.
--    Operations in HADL are either procedures (return type is 'void')
--    or functions (return type is the default integer scalar type).
--
-- getFunctionName
--
--    Each operation is mapped to a C function which name is the
--    concatenation of the model name and the operation name.
-------------------------------------------------------------------------------

helper context HADL!Model def:
   getAllOperations() : Sequence(HADL!Operation) =
      self.elements
         ->select(e| e.oclIsKindOf(HADL!Component))
         ->collect(e| e.operations)
         ->flatten();
      
helper context HADL!Operation def:
   getReturnTypeName() : String =
      if self.isFunction then
         thisModule.getDefaultDataTypeName()
      else
         'void'
      endif;

helper context HADL!Operation def:
   getFunctionName() : String =
      self.owningComponent.owningModel.name + '_' + self.owningComponent.name + '_' + self.name;

-------------------------------------------------------------------------------
-- 7. Variables
--    7.1. Common helpers
-------------------------------------------------------------------------------
-- getTypeName
--
--    Returns the name of the C type for a given variable. Type can be
--       - HADL_Array_t (for array variables)
--       - Integer type (otherwise)
-------------------------------------------------------------------------------

helper context HADL!ComponentVariable def:
   getVariableName() : String =
      self.owningComponent.name + '_' + self.name;

helper context HADL!Attribute def:
   getDataTypeName() : String =
      thisModule.getDefaultDataTypeName();

helper context HADL!Variable def:
   getDataTypeName() : String =
      if self."size".oclIsUndefined() then
         thisModule.getDefaultDataTypeName()
      else
         thisModule.getDataTypeName(self."size")
      endif;

helper context HADL!Variable def:
   getTypeName() : String =
      if self.isArray() then
         'HADL_Array_t'
      else
         self.getDataTypeName()
      endif;

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.3. Common rules
-------------------------------------------------------------------------------

helper context HADL!SyntaxExpression def:
   hasInitValue() : Boolean =
      false;

helper context HADL!DataContainerRefSyntaxExpression def:
   hasInitValue() : Boolean =
      true;

helper context HADL!StringLiteralSyntaxExpression def:
   hasInitValue() : Boolean =
      true;

helper context HADL!SyntaxCall def:
   hasSize() : Boolean =
      true;

helper context HADL!SyntaxExpression def:
   hasSize() : Boolean =
      false;

helper context HADL!ComputedSyntaxExpression def:
   hasSize() : Boolean =
      true;

helper context HADL!ImplicitValueSyntaxExpression def:
   hasSize() : Boolean =
      true;

helper context HADL!ListSyntaxExpression def:
   hasSize() : Boolean =
      true;

helper context HADL!ConcatenationSyntaxExpression def:
   hasSize() : Boolean =
      true;

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.8. Ranges - helpers
-------------------------------------------------------------------------------

helper def: newRangeIndex() : Integer =
   thisModule.refSetValue('rangeIndex', thisModule.rangeIndex+1).rangeIndex;

helper def:
   newRangeVariableName() : String =
      '_r' + thisModule.newRangeIndex().toString();

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.11. Range lookup in statements and expressions
-------------------------------------------------------------------------------
-- These helpers return a set of ranges that can be found in a statement or
-- an expression.
-------------------------------------------------------------------------------

helper context HADL!AssignmentStatement def:
   getRanges() : Sequence(HADL!Range) =
      self.source.getRanges()->union(self.target.getRanges());

helper context HADL!ProcedureCallStatement def:
   getRanges() : Sequence(HADL!Range) =
      self.call.actualParameters->collect(p| p.getRanges())->flatten();

helper context HADL!IfStatement def:
   getRanges() : Sequence(HADL!Range) =
      self.ifClauses->collect(c| c.condition.getRanges())->flatten();

helper context HADL!ReturnStatement def:
   getRanges() : Sequence(HADL!Range) =
      self.expression.getRanges();

helper context HADL!ForStatement def:
   getRanges() : Sequence(HADL!Range) =
      Sequence{self.range};

helper context HADL!FunctionCallExpression def:
   getRanges() : Sequence(HADL!Range) =
      self.call.actualParameters->collect(p| p.getRanges());

helper context HADL!DataContainerRefExpression def:
   getRanges() : Sequence(HADL!Range) =
      Sequence{self.range};

helper context HADL!OperatorExpression def:
   getRanges() : Sequence(HADL!Range) =
      self.source.getRanges()->union(self.arguments->collect(a| a.getRanges()));

helper context HADL!IntegerLiteralExpression def:
   getRanges() : Sequence(HADL!Range) =
      Sequence{};

helper context HADL!BooleanLiteralExpression def:
   getRanges() : Sequence(HADL!Range) =
      Sequence{};

helper context HADL!BasedLiteralExpression def:
   getRanges() : Sequence(HADL!Range) =
      Sequence{};

-------------------------------------------------------------------------------
-- 9. Data processing expressions
--    9.12. Helpers for based integer literals
-------------------------------------------------------------------------------
-- getBase
--
--    Returns an integer equal to the base of a based literal.
--    The base is obtained from the base specifier.
--
-- getMask
--
--    Returns an AND mask that allows to nullify the "don't care" bits in
--    an expression.
--
-- getValue
--
--    Returns the value of a based literal, with all "don't care" digits
--    set to zero.
-------------------------------------------------------------------------------

helper def:
   getBase(base : HADL!BaseSpecifier) : Integer =
      if base = #binary then
         2
      else if base = #octal then
         8
      else if base = #decimal then
         10
      else
         16
      endif endif endif;

helper context HADL!BasedLiteralExpression def:
   getBase() : Integer =
      thisModule.getBase(self.base);

helper context HADL!BasedLiteralExpression def:
   getMask() : Integer =
      thisModule.getMask(self.value, self.getBase());

helper def:
   getMask(choiceValue : String, base : Integer) : Integer =
      let head : String = choiceValue.substring(choiceValue.size(),choiceValue.size()) in
      let tail : String = choiceValue.substring(1,choiceValue.size()-1) in
      if head = '-' then
         0
      else
         base-1
      endif
      + base *
      if tail = '' then
         0
      else
         thisModule.getMask(tail, base)
      endif;

helper context HADL!BasedLiteralExpression def:
   getValue() : Integer =
      thisModule.getBasedIntegerValue(self.value, self.getBase());

helper def:
   getBasedIntegerValue(choiceValue : String, base : Integer) : Integer =
      let digits : Sequence(String) =
         Sequence {
               '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
               'A', 'B', 'C', 'D', 'E', 'F'
            } in
      let head : String = choiceValue.substring(choiceValue.size(),choiceValue.size()) in
      let tail : String = choiceValue.substring(1,choiceValue.size()-1) in
      if head = '-' then
         0
      else
         digits->indexOf(head.toUpper())-1
      endif
      + base *
      if tail = '' then
         0
      else
         thisModule.getBasedIntegerValue(tail, base)
      endif;

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.1. Common helpers
-------------------------------------------------------------------------------
-- These helpers allow to generate unique names for buffer variables.
--
-- bufferIndex
--
--    A number that should be appended to the name of the current buffer
--    variable.
--
-- newBufferIndex
--
--    Returns a new number for a buffer variable. Attribute bufferIndex is
--    updated.
--
-- currentBufferName
--
--    Returns the last generated name for a buffer variable.
--
-- newBufferName
--
--    Returns a new name for a buffer variable.
-------------------------------------------------------------------------------

helper def: newBufferIndex() : Integer =
   thisModule.refSetValue('bufferIndex', thisModule.bufferIndex+1).bufferIndex;

helper def: currentBufferName() : String =
   '_buf' + thisModule.bufferIndex.toString();

helper def: newBufferName() : String =
   '_buf' + thisModule.newBufferIndex().toString();

-------------------------------------------------------------------------------
-- 10. Syntax expressions
--    10.2. Helpers
-------------------------------------------------------------------------------
-- mapsToStatement
--
--    Returns true if the receiving syntax expression is transformed into
--    a C statement.
--
-- getOwningAttribute
--
--    Return the syntax chunk that owns a given syntax expression.
--    This helper explores the composition tree until the owner is found.
--    If no owning syntax chunk is found, OclUndefined is returned.
-------------------------------------------------------------------------------

helper context HADL!SyntaxCall def:
   mapsToStatement() : Boolean =
      true;

helper context HADL!DataContainerRefSyntaxExpression def:
   mapsToStatement() : Boolean =
      false;

helper context HADL!StringLiteralSyntaxExpression def:
   mapsToStatement() : Boolean =
      false;

helper context HADL!DecisionSyntaxExpression def:
   mapsToStatement() : Boolean =
      true;

helper context HADL!ComputedSyntaxExpression def:
   mapsToStatement() : Boolean =
      true;

helper context HADL!ImplicitValueSyntaxExpression def:
   mapsToStatement() : Boolean =
      true;

helper context HADL!ListSyntaxExpression def:
   mapsToStatement() : Boolean =
      true;

helper context HADL!ConcatenationSyntaxExpression def:
   mapsToStatement() : Boolean =
      true;

helper context HADL!SyntaxExpression def:
   getOwningChunkOrAttributeName() : String =
      if not self.owningSyntaxCall.oclIsUndefined() then
         self.owningSyntaxCall.owningChunk.behaviorChunk.name
      else if not self.owningConcatenation.oclIsUndefined() then
         self.owningConcatenation.getOwningChunkOrAttributeName()
      else if not self.owningAttributeSyntax.oclIsUndefined() then
         self.owningAttributeSyntax.attribute.name
      else if not self.owningDecisionWhenTrue.oclIsUndefined() then
         self.owningDecisionWhenTrue.getOwningChunkOrAttributeName()
      else if not self.owningDecisionWhenFalse.oclIsUndefined() then
         self.owningDecisionWhenFalse.getOwningChunkOrAttributeName()
      else
         '__undefined__'
      endif endif endif endif endif;

helper context HADL!SyntaxExpression def:
   getOwningBehavior() : String =
      if not self.owningSyntaxCall.oclIsUndefined() then
         self.owningSyntaxCall.getOwningBehavior()
      else if not self.owningConcatenation.oclIsUndefined() then
         self.owningConcatenation.getOwningBehavior()
      else if not self.owningDecisionWhenTrue.oclIsUndefined() then
         self.owningDecisionWhenTrue.getOwningBehavior()
      else if not self.owningDecisionWhenFalse.oclIsUndefined() then
         self.owningDecisionWhenFalse.getOwningBehavior()
      else if not self.owningAttributeSyntax.oclIsUndefined() then
         self.owningAttributeSyntax.owningSyntax.behavior
      else if not self.owningChoice.oclIsUndefined() then
         self.owningChoice.owningSyntax.behavior
      else if not self.owningSyntaxBefore.oclIsUndefined() then
         self.owningSyntaxBefore.behavior
      else if not self.owningSyntaxAfter.oclIsUndefined() then
         self.owningSyntaxAfter.behavior
      else -- if not self.owningSyntaxEcho.oclIsUndefined() then
         self.owningSyntaxEcho.behavior
      endif endif endif endif endif endif endif endif;

-------------------------------------------------------------------------------
-- 11. Hardware model
--    11.1. Components
-------------------------------------------------------------------------------

helper context HADL!Component def:
   getLiteralName() : String =
      self.owningModel.name + '_' + self.name + '_iface';

helper context HADL!Component def:
   getEnumerationTypeName() : String =
      self.owningModel.name + '_' + self.name + '_en';

helper context HADL!Operation def:
   getLiteralName() : String =
      self.owningComponent.owningModel.name + '_' + self.owningComponent.name + '_' + self.name + '_op';

-------------------------------------------------------------------------------
-- 11. Hardware model
--    11.2. Architectures
-------------------------------------------------------------------------------

helper context HADL!Architecture def:
   getEnumTypeName() : String =
      self.owningModel.name + '_' + self.name + '_en';

helper context HADL!Architecture def:
   getAllResources() : Sequence(HADL!Resource) =
      self.resources->union(
            self.fathers
               ->collect(f| f.getAllResources())
               ->flatten()
         );
      
helper context HADL!Port def:
   getLiteralName() : String =
      self.owningResource.owningArchitecture.owningModel.name + '_' +
      self.owningResource.owningArchitecture.name + '_' +
      self.owningResource.name + '_' +
      self.name + '_res';

-------------------------------------------------------------------------------
-- 11. Hardware model
--    11.3. Pipelines
-------------------------------------------------------------------------------

helper context HADL!Pipeline def:
   getInitFunctionName() : String =
      self.owningModel.name + '_' + self.name + '_init';

helper context HADL!Pipeline def:
   getStepFunctionName() : String =
      self.owningModel.name + '_' + self.name + '_step';

helper context HADL!Pipeline def:
   getEnumerationTypeName() : String =
      self.owningModel.name + '_' + self.name + '_en';

helper context HADL!Stage def:
   getLiteralName() : String =
      self.owningPipeline.owningModel.name + '_' + self.owningPipeline.name + '_' + self.name + '_stage';

helper context HADL!Pipeline def:
   getLiteralName() : String =
      self.owningModel.name + '_' + self.name + '_pipe';

helper context HADL!Pipeline def:
   getVariableName() : String =
      self.owningModel.name + '_' + self.name + '_rep';

helper context HADL!Pipeline def:
   getStagesVariableName() : String =
      self.owningModel.name + '_' + self.name + '_stages_rep';

helper context HADL!Stage def:
   getNextStage() : HADL!Stage =
      let stages : Sequence(HADL!Stage) = self.owningPipeline.stages in
      let index : Integer =  stages->indexOf(self) in
      if stages->size() = index then
         self
      else
         stages->at(index+1)
      endif;

helper context HADL!Stage def:
   getSuccessorsVariableName() : String =
      self.owningPipeline.owningModel.name + '_' + self.owningPipeline.name + '_' + self.name + '_succ_rep';

helper context HADL!Stage def:
   getPortsVariableName() : String =
      self.owningPipeline.owningModel.name + '_' + self.owningPipeline.name + '_' + self.name + '_ports_rep';

helper context HADL!ResourceActivation def:
   getPorts() : Sequence(HADL!Port) =
      if self.portActivations->isEmpty() then
         self.resource.ports
      else
         self.portActivations->collect(a| a.port)
      endif;

helper context HADL!Stage def:
   getPorts() : Sequence(HADL!Port) =
      self.activations->collect(a| a.getPorts())->flatten();
      
helper context HADL!Port def:
   getPortVariableName() : String =
      self.owningResource.owningArchitecture.owningModel.name + '_' +
      self.owningResource.owningArchitecture.name + '_' +
      self.owningResource.name + '_' +
      self.name + '_port';
   
helper context HADL!Port def:
   getOperationsVariableName() : String =
      self.owningResource.owningArchitecture.owningModel.name + '_' +
      self.owningResource.owningArchitecture.name + '_' +
      self.owningResource.name + '_' +
      self.name + '_port_op';
   
helper context HADL!Port def:
   getOperations() : Sequence(HADL!Operation) =
      if self.operations->isEmpty() then
         self.owningResource.component.operations
      else
         self.operations
      endif;
      
-------------------------------------------------------------------------------
-- Data types
-------------------------------------------------------------------------------

helper def:
   getInstructionTypeName() : String =
      thisModule.getDataTypeName(HADL!Model.allInstances()->asSequence()->first().instructionSize);

helper def:
   getDataTypeName(s : Integer) : String =
      'HADL_Int' +
      Sequence{8, 16, 32, 64, 128}->iterate(t; r:Integer=0|
            if r < s then
               t
            else
               r
            endif
         ).toString();

helper def:
   getDefaultDataTypeName() : String =
      thisModule.getDataTypeName(HADL!Model.allInstances()->asSequence()->first().dataSize);

-------------------------------------------------------------------------------
-- Library functions
-------------------------------------------------------------------------------

helper context HADL!Range def:
   getFunctionNameFieldSetValue() : String =
      'HADL_Field_setValue';
      
helper context HADL!Range def:
   getFunctionNameFieldGetValue() : String =
      'HADL_Field_getValue<' +
      if self.owningDataContainerRefExpression.oclIsUndefined() then
         thisModule.getInstructionTypeName()
      else
         self.owningDataContainerRefExpression.dataContainer.getDataTypeName()
      endif +
      ',' +
      if self.owningDataContainerRefExpression.oclIsUndefined() then
         thisModule.getInstructionTypeName()
      else
         thisModule.getDefaultDataTypeName()
      endif +
      '>';
      
helper context HADL!Variable def:
   getFunctionNameArrayNew() : String =
      'HADL_Array_new';

helper context HADL!AssignmentStatement def:
   getFunctionNameArraySetValue() : String =
      'HADL_Array_setValue';

helper context HADL!DataContainerRefExpression def:
   getFunctionNameArrayGetValue(extend : Boolean) : String =
      'HADL_Array_getValue<' +
      if extend then '' else 'unsigned ' endif +
      self.dataContainer.getDataTypeName() +
      ',' +
      thisModule.getDefaultDataTypeName() +
      '>';

helper context HADL!Range def:
   getFunctionNameArraySetField() : String =
      'HADL_Array_setField<' +
      self.owningDataContainerRefExpression.dataContainer.getDataTypeName() +
      ',' +
      thisModule.getDefaultDataTypeName() +
      '>';

--------------------------------------------------------
-- Behavior paths
--------------------------------------------------------

-- Get the chunk or choice corresponding to a given path element
-- Requires that the path element is not the first in the path
helper context HADL!PathElement def:
   getChunkOrChoice() : OclAny =
      if self.behaviorChunk.oclIsUndefined() then
         let index : Integer = self.owningPath.elements->indexOf(self) in
         let successorBehavior : HADL!Behavior =
            if index = self.owningPath.elements->size() then
               if not self.owningPath.owningFormat.oclIsUndefined() then
                  self.owningPath.owningFormat.behavior
               else -- if not self.owningPath.owningSyntax.oclIsUndefined() then
                  self.owningPath.owningSyntax.behavior
               endif
            else
               self.owningPath.elements->at(index+1).behavior
            endif
            in
         if self.behavior.oclIsKindOf(HADL!AggregateBehavior) then
            self.behavior.chunks
               ->select(c| c.call.behavior = successorBehavior)
         else
            self.behavior.choices
               ->select(c| c.oclIsKindOf(HADL!CallBehaviorChoice))
               ->select(c| c.call.behavior = successorBehavior)
         endif
         ->asSequence()->first()
      else
         self.behaviorChunk
      endif;

--------------------------------------------------------

helper def:
   reverseSequence(seq : Sequence(OclAny)) : Sequence(OclAny) =
      if seq->size() <= 1 then
         seq
      else
         thisModule.reverseSequence(seq->subSequence(2, seq->size()))->append(seq->first())
      endif;

