\section{\'Etat de l'art}
Un ADL ou \og Architecture Description Language \fg est un moyen de description commun à l'architecte matériel et au concepteur d'outils pour une même architecture. Le premier facteur ayant favorisé le développement des langages ADLs est l'avènement des ASIPs (Application-Specific Instruction set Processors ). Le second facteur est l'intérêt grandissant pour les DSPs (Digital Signal Prosessors ) ainsi que pour les SoCs (System-on-Chips).

Des langages tels que VHDL ou VERILOG permettent déjà de décrire des architectures matérielles. Cependant, un ADL se situe à un niveau d'abstraction plus élevé et permet:
\begin{itemize}
\item la vérification sur l'architecture;
\item des modifications rapides sur l'architecture ou le jeu d'instruction pour évaluer les performances (pour l'exploration matérielle lors de la phase de conception : \emph{Design Space Exploration});
\item une description plus rapide d'un processeur;
\item l'obtention d'un modèle de processeur plus rapide (le niveau de finesse est moins élevé, on ne modélise pas forcément tous les bus).
\end{itemize}
Les outils qui peuvent être généré de manière automatique peuvent être un simulateur du processeur, mais aussi l'assembleur, l'éditeur de liens, l'assembleur et le déboggueur.

\subsection{Classification des ADL matériel}
Parmi les ADLs les plus connus, nous citerons ISDL\cite{main97ISDL}, nML \cite{Rajesh99}, MIMOLA\cite{Leupers98}, LISA\cite{zivojnovic96lisa,pees99lisa} et EXPRESSION\cite{halambi99expression}. D'autre part, ces ADLs sont classés en trois catégories:
\begin{description}
\item[ADLs orientés jeu d'instruction]  Cette catégorie se focalisent sur les aspects jeu d'instruction (nML et ISDL par exemple).. L'objectif annoncé de ce type d'ADL est de fournir un compilateur ou/et un simulateur de type ISS\footnote{Instruction Set Simulator. Simulateur fonctionnel, non précis temporellement}. Il n'est pas possible de réaliser un simulateur temporel en ayant uniquement des informations sur le jeu d'instruction;
\item[ADLs orientés structure interne ou exploration] Cette catégorie va plutôt décrire la structure interne de l'architecture à l'exemple de MIMOLA qui permet de décrire les connexions entre les éléments composant l'architecture. Dans ce cas l'objectif est la production de code HDL\footnote{\emph{Hardware Description Language}: Langage de description très proche du matériel comme CHDL ou Verilog}. Grâce aux informations contenues dans une description MIMOLA, il est possible de produire un simulateur mais ce n'est pas l'objectif. Grâce à ce type d'ADL, c'est la partie exploration matérielle qui est privilégiée. Il est possible de considérer ce type d'ADL comme complémentaire du premier. En effet, pour produire un compilateur optimisant, il faut des informations sur la structure interne. 
\item[ADLs mixtes] LISA et EXPRESSION tentent de couvrir les deux domaines. Ils fournissent 
une chaîne de développement qui permet l'exploration matérielle, la génération de code HDL mais aussi la génération d'outils.
\end{description}

\subsection{Un ADL mixte}
Le langage proposé entre dans la catégorie des ADLs mixtes. Les 2 paragraphes suivants abordent les points importants d'EXPRESSION et le LISA.

\paragraph{EXPRESSION}

EXPRESSION est un ADL développé par le \emph{Departement of Information and  Computer Science} de l'université de Californie (Irvine). Cet ADL est très fortement orienté vers la phase de conception (exploration), mais la génération de simulateurs et de compilateurs a aussi été abordée. 

L'utilisateur a la charge de spécifier les interconnexions entre les entités. Les concepteurs d'EXPRESSION justifient ce choix par leur volonté de produire un simulateur précis et un compilateur à partir de la description réalisée avec leur ADL. Le niveau d'abstraction auquel travaille EXPRESSION se trouve juste au dessus du niveau des portes logiques. Dans la description, le grain du modèle permet d'aller décrire les bascules (latche) entre les différentes éléments. 

\paragraph{LISA}
LISA (\emph{Language for Instruction-Set Architecture}) est un langage qui a été élaboré à l'université d'Aix la Chappelle, à l'institut ISS. C'est actuellement la société CoWare\footnote{\url{http://www.coware.com/products/processordesigner_tech.php}} qui est chargée du développement, après le rachat de LisaTek. LISA permet la génération automatique d'un nombre conséquent d'outils à partir d'une description de l'architecture matérielle: compilateur C, Assembleur, éditeur de liens et simulateur pour la phase de conception (exploration), mais aussi la production d'un code VHDL pour l'implémentation. Toutes les informations sont réunies dans une même description pour éviter les problèmes de cohérence entre les différents outils.
 
LISA a été développé à travers 6 modèles:
\begin{itemize}
\item le \emph{modèle mémoire} contient les informations pour permettre de décrire à la fois les zones mémoires, et le registres;
\item le \emph{modèle de ressources} permet de lister les ressources matérielles disponibles ainsi que les 
possibilités d'utilisation des ressources. Par exemple, capacité d'un registre à être accessible en lecture/écriture;
\item le \emph{modèle comportemental} permet de décrire une activité matérielle sous la forme d'une machine à état. L'exécution d'une instruction change l'état du système;
\item le \emph{modèle du jeu d'instruction} permet de vérifier la validité d'une instruction, par exemple, la compatibilité entre le mode d'adressage et l'instruction associée;
\item le \emph{modèle temporel} définit les séquences entre les instructions et le temps d'attente entre les enchaînements. Il donne aussi le temps d'exécution des instructions;
\item le \emph{modèle de la micro-architecture} permet de regrouper les fonctionnalités dans une seule entité (par exemple l'addition et la soustraction dans l'UAL).
\end{itemize}
Pour la génération de simulateurs, les \emph{modèles de ressources} et \emph{de micro-architecture} ne sont pas utilisés (ils le sont pour la génération du code VHDL notamment).



%cadre général, à mettre après la présentation de LISA et EXPRESSION.
\subsection{Position des travaux par rapport à l'état de l'art}
Le simulateur généré, précis temporellement, doit d'une part pouvoir s'interfacer avec d'autres outils ayant besoin en entrée du temps exact nécessaire pour l'exécution d'une séquence de code:
\begin{itemize}
\item outil OTAWA de l'IRIT pour le calcul de WCET comme c'est l'objectif dans le cadre de MasCotTE;
\item mise au point de compilateurs optimisants, pour tester différentes solutions d'ordonnancement des instructions.
\end{itemize}

Il doit d'autre part permettre d'aider à la conception et à la validation des application temps réel par:
\begin{itemize}
\item la simulation offrant les services classiques fournis par les simulateurs commerciaux présents dans les chaînes de développement : exécution pas à pas, points d'arrêts, couverture de code, visualisation de l'état du système (mémoire, registres, registres spéciaux, \ldots);
\item l'intégration d'outils de validation de plus haut niveau \cite{Briday-PhD-04} : suivi temporel des variables, détection de l'ordonnancement des tâches, surveillance des dépassement de pile;
\item la simulation dans un environnement distribué, avec plusieurs processeurs communicants à travers un bus de communication (CAN par exemple). 
\end{itemize}

Contrairement à d'autres langages de description d'architecture matérielle, l'objectif ici n'est pas d'aider à la conception de processeurs, et donc de permettre de raffiner la description jusqu'à permettre de synthétiser un prototype de simulateur dans un langage de description matériel (VHDL ou Verilog par exemple), nous ne nous intéressons qu'à la \emph{détermination des aspects temporels du processeur}. Dans ce contexte, une modélisation du comportement du/des pipeline à un niveau d'abstraction plus élevé, par des automates par exemple, est envisagée. Une approche par automate permet notamment de déporter une part importante du calcul au moment de la génération du simulateur, comme cela est montré plus loin.

